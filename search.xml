<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSS 基础 笔记整合（共7篇）</title>
      <link href="/2021/08/15/css-ji-chu-bi-ji-zheng-he/"/>
      <url>/2021/08/15/css-ji-chu-bi-ji-zheng-he/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础-笔记整合-（共7篇）"><a href="#CSS-基础-笔记整合-（共7篇）" class="headerlink" title="CSS 基础 笔记整合 （共7篇）"></a>CSS 基础 笔记整合 （共7篇）</h1><p>对以前的笔记进行了整理。</p><ul><li><p><a href="https://tzhiy.github.io/2021/07/19/css-1-7/">CSS 基础总结 1/7 | tzhiy’s Blog</a></p><p>CSS 简介、基础选择器、字体属性、文本属性、CSS 引入方式</p></li><li><p><a href="https://tzhiy.github.io/2021/07/20/css-2-7/">CSS 基础总结 2/7 | tzhiy’s Blog</a></p><p>Emmet 语法、CSS 三大特性</p></li><li><p><a href="https://tzhiy.github.io/2021/07/20/css-3-7/">CSS 基础总结 3/7 | tzhiy’s Blog</a></p><p>盒子模型、圆角边框、盒子阴影、文字阴影</p></li><li><p><a href="https://tzhiy.github.io/2021/07/22/css-4-7/">CSS 基础总结 4/7 | tzhiy’s Blog</a></p><p>浮动、常见网页布局、清除浮动</p></li><li><p><a href="https://tzhiy.github.io/2021/07/23/css-5-7/">CSS 基础总结 5/7 | tzhiy’s Blog</a></p><p>学成在线案例</p></li><li><p><a href="https://tzhiy.github.io/2021/07/29/css-6-7/#toc-heading-13">CSS 基础总结 6/7 | tzhiy’s Blog</a></p><p>定位、网页布局总结、元素的显示与隐藏</p></li><li><p><a href="https://tzhiy.github.io/2021/07/31/css-7-7/">CSS 基础总结 7/7 | tzhiy’s Blog</a></p><p>精灵图、字体图标、三角、用户界面样式、vertical-align 属性样式、溢出文字省略号显示、常见布局技巧、CSS 初始化</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
            <tag> 整合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 基础 DOM</title>
      <link href="/2021/08/14/js-ji-chu-dom/"/>
      <url>/2021/08/14/js-ji-chu-dom/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-基础-DOM"><a href="#JS-基础-DOM" class="headerlink" title="JS 基础 DOM"></a>JS 基础 DOM</h1><h2 id="1-DOM-简介"><a href="#1-DOM-简介" class="headerlink" title="1 DOM 简介"></a>1 DOM 简介</h2><p>文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言（HTML或者XML）的标准编程接口。</p><p>W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。</p><img src="image-20210814144234682.png" alt="image-20210814144234682" style="zoom:80%;"><ul><li>文档：一个页面就是一个文档，DOM 中使用 doucument  来表示</li><li>元素：页面中的所有标签都是元素，DOM中使用 element 表示</li><li>节点：网页中的所有内容都是节点（标签，属性，文本，注释等），DOM中使用node表示</li></ul><p>DOM 把以上内容都看做是对象</p><h2 id="2-获取元素"><a href="#2-获取元素" class="headerlink" title="2 获取元素"></a>2 获取元素</h2><h3 id="2-1-根据ID获取"><a href="#2-1-根据ID获取" class="headerlink" title="2.1 根据ID获取"></a>2.1 根据ID获取</h3><p><code>getElementByld()</code> 返回带ID的元素对象</p><pre class="line-numbers language-none"><code class="language-none">doucument.getElementByld('id名')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>console.dir()</code> 可以打印我们获取的元素对象</p><h3 id="2-2-根据标签名获取"><a href="#2-2-根据标签名获取" class="headerlink" title="2.2 根据标签名获取"></a>2.2 根据标签名获取</h3><p><code>getElementByTagName()</code> 返回带有标签名的<strong>对象的集合</strong></p><pre class="line-numbers language-none"><code class="language-none">doucument.getElementsByTagName('标签名');//或者根据标签名获取父元素内部所有指定标签名的子元素ol.getElementsByTagName('li');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>返回的是获取过来元素对象的集合，以伪数组的形式存储</p><h3 id="2-3-通过H5新增方法获取"><a href="#2-3-通过H5新增方法获取" class="headerlink" title="2.3 通过H5新增方法获取"></a>2.3 通过H5新增方法获取</h3><table><thead><tr><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>document.getElementsByClassName('类名')</code></td><td align="center">根据类名返回元素对象合集</td></tr><tr><td align="center"><code>document.querySelector('选择器');</code></td><td align="center">根据指定选择器返回第一个元素对象</td></tr><tr><td align="center"><code>document.querySelectorAll('选择器');</code></td><td align="center">根据指定选择器返回所有元素对象</td></tr></tbody></table><p><code>querySelector</code> 和 <code>querySelectorAll</code> 里面的选择器需要加符号,比如: <code>document.querySelector('#nav');</code></p><h3 id="2-4-获取特殊元素"><a href="#2-4-获取特殊元素" class="headerlink" title="2.4 获取特殊元素"></a>2.4 获取特殊元素</h3><table><thead><tr><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>document.body;</code></td><td align="center">返回body元素对象</td></tr><tr><td align="center"><code>document.documentElement;</code></td><td align="center">返回html元素对象</td></tr></tbody></table><h2 id="3-事件基础"><a href="#3-事件基础" class="headerlink" title="3 事件基础"></a>3 事件基础</h2><p>触发-响应机制。</p><h3 id="3-1-执行步骤"><a href="#3-1-执行步骤" class="headerlink" title="3.1 执行步骤"></a>3.1 执行步骤</h3><ol><li>获取事件源</li><li>注册事件(绑定事件)</li><li>添加事件处理程序(采取函数赋值形式)</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;    // 1. 获取事件源    var div = document.querySelector('div');    // 2. 绑定事件 注册事件    // div.onclick     // 3. 添加事件处理程序     div.onclick = function() {        console.log('我被选中了');    }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-鼠标事件"><a href="#3-2-鼠标事件" class="headerlink" title="3.2 鼠标事件"></a>3.2 鼠标事件</h3><table><thead><tr><th align="center">鼠标事件</th><th align="center">触发条件</th></tr></thead><tbody><tr><td align="center">onclick</td><td align="center">鼠标点击左键触发</td></tr><tr><td align="center">onmouseover</td><td align="center">鼠标经过触发</td></tr><tr><td align="center">onmouseout</td><td align="center">鼠标离开触发</td></tr><tr><td align="center">onfocus</td><td align="center">获得鼠标焦点触发</td></tr><tr><td align="center">onblur</td><td align="center">失去鼠标焦点触发</td></tr><tr><td align="center">onmousemove</td><td align="center">鼠标移动触发</td></tr><tr><td align="center">onmouseup</td><td align="center">鼠标弹起触发</td></tr><tr><td align="center">onmousedown</td><td align="center">鼠标按下触发</td></tr></tbody></table><h2 id="4-操作元素"><a href="#4-操作元素" class="headerlink" title="4 操作元素"></a>4 操作元素</h2><p>我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。</p><h3 id="4-1-元素内容"><a href="#4-1-元素内容" class="headerlink" title="4.1 元素内容"></a>4.1 元素内容</h3><pre class="line-numbers language-none"><code class="language-none">element.innerText//从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉。element.innerHTML//起始位置到终止位置的全部内容，包括HTML标签，同时保留空格和换行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-元素属性"><a href="#4-2-元素属性" class="headerlink" title="4.2 元素属性"></a>4.2 元素属性</h3><pre class="line-numbers language-none"><code class="language-none">// 元素.属性img.src = "xxx";input.value = "xxx";input.type = "xxx";input.checked = "xxx";input.selected = true / false;input.disabled = true / false;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-样式属性"><a href="#4-3-样式属性" class="headerlink" title="4.3 样式属性"></a>4.3 样式属性</h3><ol><li>行内样式</li></ol><pre class="line-numbers language-none"><code class="language-none">// element.stylediv.style.backgroundColor = 'pink';div.style.width = '250px';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>类名样式</li></ol><pre class="line-numbers language-none"><code class="language-none">// element.className<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div class="first"&gt;文本&lt;/div&gt;    &lt;script&gt;        // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用        var test = document.querySelector('div');        test.onclick = function() {            // this.style.backgroundColor = 'purple';            // 让我们当前元素的类名改为了 change            // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况            // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器            // this.className = 'change';            this.className = 'first change';        }    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-自定义属性"><a href="#4-4-自定义属性" class="headerlink" title="4.4 自定义属性"></a>4.4 自定义属性</h3><ol><li>获取属性值</li></ol><pre class="line-numbers language-none"><code class="language-none">//获取内置属性值(元素本身自带的属性)element.属性;//获取自定义的属性或内置属性值element.getAttribute('属性');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>设置属性值</li></ol><pre class="line-numbers language-none"><code class="language-none">//设置内置属性值element.属性 = '值';//设置自定义的属性或内置属性值element.setAttribute('属性');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>移除属性值</li></ol><pre class="line-numbers language-none"><code class="language-none">element.removeAttribute('属性');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>自定义属性目的：</li></ol><ul><li>保存并保存数据，有些数据可以保存到页面中而不用保存到数据库中</li><li>有些自定义属性很容易引起歧义，不容易判断到底是内置属性还是自定义的，所以H5有了规定</li></ul><ol start="5"><li>设置自定义属性</li></ol><p>H5规定自定义属性 <code>data-</code>开头作为属性名并赋值</p><pre class="line-numbers language-none"><code class="language-none">&lt;div data-index = "1"&gt;&lt;/&gt;// 或者使用JavaScript设置div.setAttribute('data-index',1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li>获取自定义属性</li></ol><ul><li>兼容性获取 <code>element.getAttribute('data-index')</code></li><li>H5新增的：<code>element.dataset.index</code> 或<code>element.dataset['index']</code> IE11才开始支持</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div getTime="20" data-index="2" data-list-name="andy"&gt;&lt;/div&gt;    &lt;script&gt;        var div = document.querySelector('div');        console.log(div.getAttribute('getTime'));        div.setAttribute('data-time', 20);        console.log(div.getAttribute('data-index'));        console.log(div.getAttribute('data-list-name'));        // h5新增的获取自定义属性的方法 它只能获取data-开头的        // dataset 是一个集合里面存放了所有以data开头的自定义属性        console.log(div.dataset);        console.log(div.dataset.index);        console.log(div.dataset['index']);        // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法        console.log(div.dataset.listName);        console.log(div.dataset['listName']);    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-节点"><a href="#5-节点" class="headerlink" title="5 节点"></a>5 节点</h2><h3 id="5-1-节点概述"><a href="#5-1-节点概述" class="headerlink" title="5.1 节点概述"></a>5.1 节点概述</h3><p>网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。</p><p>HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。</p><img src="image-20210814144234682.png" alt="image-20210814144234682" style="zoom: 80%;"><p>一般的，节点至少拥有 nodeType（节点类型）、nodeName（节点名称）和 nodeValue（节点值）这三个基本属性。</p><ul><li>元素节点：nodeType 为1</li><li>属性节点：nodeType 为2</li><li>文本节点：nodeType 为3（文本节点包括文字、空格、换行等）</li></ul><p>我们在实际开发中，节点操作主要操作的是<strong>元素节点</strong></p><p>利用 DOM 树可以把节点划分为不同的层级关系，常见的是<strong>父子兄层级关系</strong>。</p><h3 id="5-2-父节点"><a href="#5-2-父节点" class="headerlink" title="5.2 父节点"></a>5.2 父节点</h3><pre class="line-numbers language-none"><code class="language-none">node.parentNode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-3-子节点"><a href="#5-3-子节点" class="headerlink" title="5.3 子节点"></a>5.3 子节点</h3><pre class="line-numbers language-none"><code class="language-none">parentNode.childNodes //返回所有的子节点的集合parentNode.children //返回所有的子元素节点的集合，常用parentNode.firstChild //所有子节点中的第一个子结点parentNode.lastChild //所有子节点中的最后一个子结点parentNode.firstElementChild //所有子节点中的第一个子元素结点，兼容性parentNode.lastElementChild //所有子节点中的最后一个子元素结点，兼容性//由于一些兼容性问题，我们可以用以下方法返回第一个和最后一个子元素节点：parentNode.chilren[0]parentNode.chilren[parentNode.chilren.length - 1]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-4-兄弟节点"><a href="#5-4-兄弟节点" class="headerlink" title="5.4 兄弟节点"></a>5.4 兄弟节点</h3><pre class="line-numbers language-none"><code class="language-none">node.nextSibling //下一个兄弟节点node.previousSibling //上一个兄弟节点node.nextElementSibling //下一个兄弟元素节点，兼容性node.previousElementSibling //上一个兄弟节点，兼容性//可以自己封装函数解决兼容性问题function getNextElementSibling(element) {    var el = element;    while(el = el.nextSibling) {        if(el.nodeType === 1){            return el;        }    }    return null;}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-5-创建节点"><a href="#5-5-创建节点" class="headerlink" title="5.5 创建节点"></a>5.5 创建节点</h3><h4 id="5-5-1-添加节点"><a href="#5-5-1-添加节点" class="headerlink" title="5.5.1 添加节点"></a>5.5.1 添加节点</h4><pre class="line-numbers language-none"><code class="language-none">node.appendChild() 方法将一个节点添加到指定父节点的子节点列表末尾。node.insertBefore() 方法将一个节点添加到父节点的指定子节点前面<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-5-2-删除节点"><a href="#5-5-2-删除节点" class="headerlink" title="5.5.2 删除节点"></a>5.5.2 删除节点</h4><pre class="line-numbers language-none"><code class="language-none">node.removeChild(child)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-5-3-复制节点"><a href="#5-5-3-复制节点" class="headerlink" title="5.5.3 复制节点"></a>5.5.3 复制节点</h4><pre class="line-numbers language-none"><code class="language-none">node.cloneNode()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果括号参数为空或者为 false ，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点</li><li>如果括号参数为 true ，则是深度拷贝，会复制节点本身以及里面所有的子节点</li></ul><h2 id="6-DOM-核心"><a href="#6-DOM-核心" class="headerlink" title="6 DOM 核心"></a>6 DOM 核心</h2><p>对于DOM操作，我们主要针对子元素的操作，主要有：</p><h3 id="6-1-创建"><a href="#6-1-创建" class="headerlink" title="6.1 创建"></a>6.1 创建</h3><ol><li>document.write</li><li>innerHTML</li><li>createElement</li></ol><h3 id="6-2-增"><a href="#6-2-增" class="headerlink" title="6.2 增"></a>6.2 增</h3><ol><li>appendChild</li><li>insertBefore</li></ol><h3 id="6-3-删"><a href="#6-3-删" class="headerlink" title="6.3 删"></a>6.3 删</h3><ol><li>removeChild</li></ol><h3 id="6-4-改"><a href="#6-4-改" class="headerlink" title="6.4 改"></a>6.4 改</h3><ol><li>修改元素属性：src、href、title 等</li><li>修改普通元素内容：innerHTML、innerText</li><li>修改表单元素：value、type、disabled</li><li>修改元素样式：style、className</li></ol><h3 id="6-5-查"><a href="#6-5-查" class="headerlink" title="6.5 查"></a>6.5 查</h3><ol><li>DOM提供的API方法：getElementById、getElementsByTagName (方法较老，不推荐)</li><li><strong>H5提供的新方法</strong>：querySelector、querySelectorAll (推荐)</li><li><strong>利用节点操作获取元素</strong>：父（parentNode）、子（children）、兄（previousElementSibling、nextElementSibling）（推荐）</li></ol><h3 id="6-6-属性操作"><a href="#6-6-属性操作" class="headerlink" title="6.6 属性操作"></a>6.6 属性操作</h3><p>主要针对于自定义属性</p><ol><li>setAttribute：设置dom的属性值</li><li>getAttribute：得到dom的属性值</li><li>removeAttribute：移除属性</li></ol><h2 id="7-事件高级"><a href="#7-事件高级" class="headerlink" title="7 事件高级"></a>7 事件高级</h2><h3 id="7-1-注册事件（绑定事件）"><a href="#7-1-注册事件（绑定事件）" class="headerlink" title="7.1 注册事件（绑定事件）"></a>7.1 注册事件（绑定事件）</h3><p>给元素添加事件，称为注册事件或者绑定事件。</p><p>注册事件有两种方式：传统方式和方法监听注册方式。</p><p>传统方式具有注册事件的唯一性。</p><h4 id="1-addEventListener-事件监听方式"><a href="#1-addEventListener-事件监听方式" class="headerlink" title="1 addEventListener 事件监听方式"></a>1 addEventListener 事件监听方式</h4><pre class="line-numbers language-none"><code class="language-none">eventTarget.addEventListener(type,listener[,useCapture])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>type</code>:事件类型字符串，比如 click 、mouseover，注意这里不要带on</li><li><code>listener</code>：事件处理函数，事件发生时，会调用该监听函数</li><li><code>useCapture</code>：可选参数，是一个布尔值，默认是 false。</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;button&gt;传统注册事件&lt;/button&gt;    &lt;button&gt;方法监听注册事件&lt;/button&gt;    &lt;button&gt;ie9 attachEvent&lt;/button&gt;    &lt;script&gt;        var btns = document.querySelectorAll('button');        // 1. 传统方式注册事件        btns[0].onclick = function() {            alert('hi');        }        btns[0].onclick = function() {                alert('hao a u');        }                // 2. 事件监听注册事件 addEventListener         // (1) 里面的事件类型是字符串 所以加引号 而且不带on        // (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）        btns[1].addEventListener('click', function() {            alert(22);        })        btns[1].addEventListener('click', function() {                alert(33);        })                // 3. attachEvent ie9以前的版本支持        btns[2].attachEvent('onclick', function() {            alert(11);        })    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-attachEvent事件监听方式（兼容）"><a href="#2-attachEvent事件监听方式（兼容）" class="headerlink" title="2 attachEvent事件监听方式（兼容）"></a>2 attachEvent事件监听方式（兼容）</h4><pre class="line-numbers language-none"><code class="language-none">eventTarget.attachEvent(eventNameWithOn,callback)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-注册事件兼容性解决方案"><a href="#3-注册事件兼容性解决方案" class="headerlink" title="3 注册事件兼容性解决方案"></a>3 注册事件兼容性解决方案</h4><pre class="line-numbers language-none"><code class="language-none">function addEventListener(element, eventName, fn) {     // 判断当前浏览器是否支持 addEventListener 方法     if (element.addEventListener) {       element.addEventListener(eventName, fn);  // 第三个参数 默认是false     } else if (element.attachEvent) {       element.attachEvent('on' + eventName, fn);     } else {       // 相当于 element.onclick = fn;       element['on' + eventName] = fn;      }}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-2-删除事件（解绑事件）"><a href="#7-2-删除事件（解绑事件）" class="headerlink" title="7.2 删除事件（解绑事件）"></a>7.2 删除事件（解绑事件）</h3><h4 id="1-removeEventListener-删除事件方式"><a href="#1-removeEventListener-删除事件方式" class="headerlink" title="1 removeEventListener 删除事件方式"></a>1 removeEventListener 删除事件方式</h4><pre class="line-numbers language-none"><code class="language-none">eventTarget.removeEventListener(type,listener[,useCapture]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>type</code>:事件类型字符串，比如click、mouseover，注意这里不要带 on</li><li><code>listener</code>：事件处理函数，事件发生时，会调用该监听函数</li><li><code>useCapture</code>：可选参数，是一个布尔值，默认是 false。</li></ul><h4 id="2-detachEvent删除事件方式-兼容"><a href="#2-detachEvent删除事件方式-兼容" class="headerlink" title="2 detachEvent删除事件方式(兼容)"></a>2 detachEvent删除事件方式(兼容)</h4><pre class="line-numbers language-none"><code class="language-none">eventTarget.detachEvent(eventNameWithOn,callback);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-传统事件删除方式"><a href="#3-传统事件删除方式" class="headerlink" title="3 传统事件删除方式"></a>3 传统事件删除方式</h4><pre class="line-numbers language-none"><code class="language-none">eventTarget.onclick = null;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div&gt;1&lt;/div&gt;    &lt;div&gt;2&lt;/div&gt;    &lt;div&gt;3&lt;/div&gt;    &lt;script&gt;        var divs = document.querySelectorAll('div');        divs[0].onclick = function() {            alert(11);            // 1. 传统方式删除事件            divs[0].onclick = null;        }        // 2.removeEventListener 删除事件        divs[1].addEventListener('click',fn);   //里面的fn不需要调用加小括号        function fn(){            alert(22);            divs[1].removeEventListener('click',fn);        }        // 3.IE9 中的删除事件方式        divs[2].attachEvent('onclick',fn1);        function fn1() {            alert(33);            divs[2].detachEvent('onclick',fn1);        }    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-删除事件兼容性解决方案"><a href="#4-删除事件兼容性解决方案" class="headerlink" title="4 删除事件兼容性解决方案"></a>4 删除事件兼容性解决方案</h4><pre class="line-numbers language-none"><code class="language-none">function removeEventListener(element, eventName, fn) {      // 判断当前浏览器是否支持 removeEventListener 方法      if (element.removeEventListener) {        element.removeEventListener(eventName, fn);  // 第三个参数 默认是false      } else if (element.detachEvent) {        element.detachEvent('on' + eventName, fn);      } else {        element['on' + eventName] = null; } <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-3-DOM事件流"><a href="#7-3-DOM事件流" class="headerlink" title="7.3 DOM事件流"></a>7.3 DOM事件流</h3><ul><li>事件流描述的是从页面中接收事件的顺序</li><li>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流</li></ul><img src="image-20210814164549426.png" alt="image-20210814164549426" style="zoom: 67%;"><ul><li>事件冒泡： IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。</li><li>事件捕获： 网景最早提出，由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。</li></ul><h4 id="1-捕获阶段"><a href="#1-捕获阶段" class="headerlink" title="1 捕获阶段"></a>1 捕获阶段</h4><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div class="father"&gt;        &lt;div class="son"&gt;son盒子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // dom 事件流 三个阶段        // 1. JS 代码中只能执行捕获或者冒泡其中的一个阶段。        // 2. onclick 和 attachEvent（ie） 只能得到冒泡阶段。        // 3. 捕获阶段 如果addEventListener 第三个参数是 true 那么则处于捕获阶段  document -&gt; html -&gt; body -&gt; father -&gt; son        var son = document.querySelector('.son');        son.addEventListener('click', function() {             alert('son');        }, true);        var father = document.querySelector('.father');        father.addEventListener('click', function() {            alert('father');        }, true);    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="capture.gif" alt="capture" style="zoom:67%;"><h4 id="2-冒泡阶段"><a href="#2-冒泡阶段" class="headerlink" title="2 冒泡阶段"></a>2 冒泡阶段</h4><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div class="father"&gt;        &lt;div class="son"&gt;son盒子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;// 4. 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 那么则处于冒泡阶段  son -&gt; father -&gt;body -&gt; html -&gt; document        var son = document.querySelector('.son');        son.addEventListener('click', function() {            alert('son');        }, false);        var father = document.querySelector('.father');        father.addEventListener('click', function() {            alert('father');        }, false);        document.addEventListener('click', function() {            alert('document');        })    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="bubble.gif" alt="bubble" style="zoom:67%;"><h4 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h4><ul><li>JS 代码中只能执行捕获或者冒泡其中的一个阶段</li><li><code>onclick</code> 和 <code>attachEvent</code>只能得到冒泡阶段</li><li><code>addEventListener(type,listener[,useCapture])</code>第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序；如果是 false (不写默认就是false),表示在事件冒泡阶段调用事件处理程序</li><li>实际开发中我们很少使用事件捕获，我们更关注事件冒泡。</li><li>有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave</li></ul><h3 id="7-4-事件对象"><a href="#7-4-事件对象" class="headerlink" title="7.4 事件对象"></a>7.4 事件对象</h3><pre class="line-numbers language-none"><code class="language-none">eventTarget.onclick = function(event) {   // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt } eventTarget.addEventListener('click', function(event) {   // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt  })<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>官方解释：event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态</li><li>简单理解：<ul><li>事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面</li><li>这个对象就是事件对象 event，它有很多属性和方法，比如<ul><li>谁绑定了这个事件</li><li>鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置</li><li>键盘触发事件的话，会得到键盘的相关信息，如按了哪个键</li></ul></li></ul></li><li>这个 event 是个形参，系统帮我们设定为事件对象，不需要传递实参过去</li><li>当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）</li></ul><h4 id="1-事件对象的兼容性方案"><a href="#1-事件对象的兼容性方案" class="headerlink" title="1 事件对象的兼容性方案"></a>1 事件对象的兼容性方案</h4><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div&gt;123&lt;/div&gt;    &lt;script&gt;        // 事件对象        var div = document.querySelector('div');        div.onclick = function(e) {                // console.log(e);                // console.log(window.event);                // e = e || window.event;                console.log(e);            }        // 1. event 就是一个事件对象 写到我们侦听函数的 小括号里面 当形参来看        // 2. 事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数        // 3. 事件对象 是 我们事件的一系列相关数据的集合 跟事件相关的 比如鼠标点击里面就包含了鼠标的相关信息，鼠标坐标啊，如果是键盘事件里面就包含的键盘事件的信息 比如 判断用户按下了那个键        // 4. 这个事件对象我们可以自己命名 比如 event 、 evt、 e        // 5. 事件对象也有兼容性问题 ie678 通过 window.event 兼容性的写法  e = e || window.event;    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-事件对象的常见属性和方法"><a href="#2-事件对象的常见属性和方法" class="headerlink" title="2 事件对象的常见属性和方法"></a>2 事件对象的常见属性和方法</h4><table><thead><tr><th align="center">事件对象属性方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">e.target</td><td align="center">返回触发事件的对象 标准</td></tr><tr><td align="center">e.srcElement</td><td align="center">返回触发事件的对象 非标准 ie6-8使用</td></tr><tr><td align="center">e.type</td><td align="center">返回事件的类型 比如<code>click</code> <code>mouseover</code> 不带on</td></tr><tr><td align="center">e.cancelBubble</td><td align="center">该属性阻止冒泡，非标准，ie6-8使用</td></tr><tr><td align="center">e.returnValue</td><td align="center">该属性阻止默认行为 非标准，ie6-8使用</td></tr><tr><td align="center">e.preventDefault()</td><td align="center">该方法阻止默认行为 标准 比如不让链接跳转</td></tr><tr><td align="center">e.stopPropagation()</td><td align="center">阻止冒泡 标准</td></tr></tbody></table><p><code>e.target</code> 和 <code>this</code> 的区别：</p><ul><li>this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素）</li><li>e.target 是事件触发的元素</li></ul><h3 id="7-5-事件对象阻止默认行为"><a href="#7-5-事件对象阻止默认行为" class="headerlink" title="7.5 事件对象阻止默认行为"></a>7.5 事件对象阻止默认行为</h3><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div&gt;123&lt;/div&gt;    &lt;a href="http://www.baidu.com"&gt;百度&lt;/a&gt;    &lt;form action="http://www.baidu.com"&gt;        &lt;input type="submit" value="提交" name="sub"&gt;    &lt;/form&gt;    &lt;script&gt;        // 常见事件对象的属性和方法        // 1. 返回事件类型        var div = document.querySelector('div');        div.addEventListener('click', fn);        div.addEventListener('mouseover', fn);        div.addEventListener('mouseout', fn);        function fn(e) {            console.log(e.type);        }        // 2. 阻止默认行为（事件） 让链接不跳转 或者让提交按钮不提交        var a = document.querySelector('a');        a.addEventListener('click', function(e) {                e.preventDefault(); //  dom 标准写法            })            // 3. 传统的注册方式        a.onclick = function(e) {            // 普通浏览器 e.preventDefault();  方法            // e.preventDefault();            // 低版本浏览器 ie678  returnValue  属性            // e.returnValue;            // 我们可以利用return false 也能阻止默认行为 没有兼容性问题 特点： return 后面的代码不执行了， 而且只限于传统的注册方式            return false;            alert(11);        }    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-6-阻止事件冒泡"><a href="#7-6-阻止事件冒泡" class="headerlink" title="7.6 阻止事件冒泡"></a>7.6 阻止事件冒泡</h3><pre class="line-numbers language-none"><code class="language-none">//标准写法e.stopPropagation();&lt;body&gt;    &lt;div class="father"&gt;        &lt;div class="son"&gt;son儿子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // 常见事件对象的属性和方法        // 阻止冒泡  dom 推荐的标准 stopPropagation()         var son = document.querySelector('.son');        son.addEventListener('click', function(e) {            alert('son');            e.stopPropagation(); // stop 停止  Propagation 传播            e.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡        }, false);        var father = document.querySelector('.father');        father.addEventListener('click', function() {            alert('father');        }, false);        document.addEventListener('click', function() {            alert('document');        })    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-7-事件委托"><a href="#7-7-事件委托" class="headerlink" title="7.7 事件委托"></a>7.7 事件委托</h3><ul><li>事件委托也称为事件代理，在 jQuery 里面称为事件委派</li><li>事件委托的原理：不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;ul&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点        var ul = document.querySelector('ul');        ul.addEventListener('click', function(e) {            // alert('知否知否，点我应有弹框在手！');            // e.target 这个可以得到我们点击的对象            e.target.style.backgroundColor = 'pink';            // 点了谁，就让谁的style里面的backgroundColor颜色变为pink        })    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-8-常用鼠标事件"><a href="#7-8-常用鼠标事件" class="headerlink" title="7.8 常用鼠标事件"></a>7.8 常用鼠标事件</h3><table><thead><tr><th align="center">鼠标事件</th><th align="center">触发条件</th></tr></thead><tbody><tr><td align="center">onclick</td><td align="center">鼠标点击左键触发</td></tr><tr><td align="center">onmouseover</td><td align="center">鼠标经过触发</td></tr><tr><td align="center">onmouseout</td><td align="center">鼠标离开触发</td></tr><tr><td align="center">onfocus</td><td align="center">获得鼠标焦点触发</td></tr><tr><td align="center">onblur</td><td align="center">失去鼠标焦点触发</td></tr><tr><td align="center">onmousemove</td><td align="center">鼠标移动触发</td></tr><tr><td align="center">onmouseup</td><td align="center">鼠标弹起触发</td></tr><tr><td align="center">onmousedown</td><td align="center">鼠标按下触发</td></tr></tbody></table><h3 id="7-9-常用的键盘事件"><a href="#7-9-常用的键盘事件" class="headerlink" title="7.9 常用的键盘事件"></a>7.9 常用的键盘事件</h3><table><thead><tr><th align="center">键盘事件</th><th align="center">触发条件</th></tr></thead><tbody><tr><td align="center">onkeyup</td><td align="center">某个键盘按键被松开时触发</td></tr><tr><td align="center">onkeydown</td><td align="center">某个键盘按键被按下时触发</td></tr><tr><td align="center">onkeypress</td><td align="center">某个键盘按键被按下时触发，但是它不识别功能键，比如 ctrl、 shift、 箭头等</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 基础 &amp; CSS 基础 &amp; UI设计</title>
      <link href="/2021/08/14/byte1html-ji-chu-css-ji-chu-ui-she-ji/"/>
      <url>/2021/08/14/byte1html-ji-chu-css-ji-chu-ui-she-ji/</url>
      
        <content type="html"><![CDATA[<p>字节跳动</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
            <tag> UI </tag>
            
            <tag> YOUTHCAMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 基础 变量、函数、对象</title>
      <link href="/2021/08/13/js-ji-chu-yu-fa/"/>
      <url>/2021/08/13/js-ji-chu-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-基础-变量、函数、对象"><a href="#JS-基础-变量、函数、对象" class="headerlink" title="JS 基础 变量、函数、对象"></a>JS 基础 变量、函数、对象</h1><p>总结中删去了大量与 C 语言重复的内容。</p><h2 id="0-JavaScript-简介"><a href="#0-JavaScript-简介" class="headerlink" title="0 JavaScript 简介"></a>0 JavaScript 简介</h2><h3 id="0-1-JavaScript"><a href="#0-1-JavaScript" class="headerlink" title="0.1 JavaScript"></a>0.1 JavaScript</h3><ul><li>JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 即脚本）</li><li>脚本语言：不需要编译，运行过程中由 JS 解释器( JS 引擎）逐行来进行解释并执行</li><li>现在也可以基于 Node.js 技术进行服务器端编程</li></ul><h3 id="0-2-浏览器执行-JS"><a href="#0-2-浏览器执行-JS" class="headerlink" title="0.2 浏览器执行 JS"></a>0.2 浏览器执行 JS</h3><p>浏览器分成两部分：渲染引擎和 JS 引擎</p><ul><li>渲染引擎：用来解析HTML与CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit</li><li>JS 引擎：也称为 JS 解释器。 用来读取网页中的 JavaScript 代码，对其处理后运行，比如 Chrome 浏览器的 V8</li></ul><p>浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎（解释器）来执行 JS 代码。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以JavaScript 语言归为脚本语言，会逐行解释执行。</p><h3 id="0-3-JS的组成"><a href="#0-3-JS的组成" class="headerlink" title="0.3 JS的组成"></a>0.3 JS的组成</h3><p>JavaScript 包括 ECMAScript、DOM、BOM。</p><h4 id="1-ECMAScript"><a href="#1-ECMAScript" class="headerlink" title="1 ECMAScript"></a>1 ECMAScript</h4><p><strong>ECMAScript</strong> 是由ECMA 国际进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。</p><p>ECMAScript：ECMAScript 规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。</p><h4 id="2-DOM文档对象模型"><a href="#2-DOM文档对象模型" class="headerlink" title="2 DOM文档对象模型"></a>2 DOM文档对象模型</h4><p><strong>DOM</strong>是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。</p><h4 id="3-BOM浏览器对象模型"><a href="#3-BOM浏览器对象模型" class="headerlink" title="3 BOM浏览器对象模型"></a>3 BOM浏览器对象模型</h4><p><strong>BOM</strong>是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</p><h2 id="1-JS-书写格式"><a href="#1-JS-书写格式" class="headerlink" title="1 JS 书写格式"></a>1 JS 书写格式</h2><h3 id="1-1-行内式"><a href="#1-1-行内式" class="headerlink" title="1.1 行内式"></a>1.1 行内式</h3><pre class="line-numbers language-none"><code class="language-none">&lt;input type="button" value="点我试试" onclink="alert('Hello World')" /&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-内嵌式"><a href="#1-2-内嵌式" class="headerlink" title="1.2 内嵌式"></a>1.2 内嵌式</h3><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;     alert('Hello World!');&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-3-外部JS"><a href="#1-3-外部JS" class="headerlink" title="1.3 外部JS"></a>1.3 外部JS</h3><pre class="line-numbers language-none"><code class="language-none">&lt;script src="my.js"&gt;&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-JS-基本语法"><a href="#2-JS-基本语法" class="headerlink" title="2 JS 基本语法"></a>2 JS 基本语法</h2><h3 id="2-1-输入输出"><a href="#2-1-输入输出" class="headerlink" title="2.1 输入输出"></a>2.1 输入输出</h3><table><thead><tr><th align="center">方法</th><th align="center">说明</th><th align="center">归属</th></tr></thead><tbody><tr><td align="center">alert(msg);</td><td align="center">浏览器弹出警示框</td><td align="center">浏览器</td></tr><tr><td align="center">console.log(msg);</td><td align="center">浏览器控制台打印输出信息</td><td align="center">浏览器</td></tr><tr><td align="center">prompt(info);</td><td align="center">浏览看弹出输入框，用户可以输入</td><td align="center">浏览器</td></tr></tbody></table><h3 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h4><p><code>var</code> 是一个 JS 关键字，用来声明变量(variable)。使用该关键字声明变量后，计算机会自动为变量分配内存空间。</p><h4 id="2-声明变量的特殊情况"><a href="#2-声明变量的特殊情况" class="headerlink" title="2 声明变量的特殊情况"></a>2 声明变量的特殊情况</h4><table><thead><tr><th align="center">说明</th><th align="center">情况</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">只声明，不赋值</td><td align="center">var age; console.log(age);</td><td align="center">undefined</td></tr><tr><td align="center">不声明，不赋值，直接使用</td><td align="center">console.log(age)</td><td align="center">报错</td></tr><tr><td align="center">不声明，只赋值，会自动声明该变量</td><td align="center">age = 10;console.log(age);</td><td align="center">10</td></tr></tbody></table><h3 id="2-3-数据类型"><a href="#2-3-数据类型" class="headerlink" title="2.3 数据类型"></a>2.3 数据类型</h3><p><strong>JavaScript是一种弱类型或动态语言。</strong>这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。</p><p>JS 把数据类型分为两类：</p><ul><li>基本数据类型(Number, String, Boolean, Undefined, Null)</li><li>复杂数据类型(Object)</li></ul><p>基本数据类型</p><table><thead><tr><th>简单数据类型</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>number</td><td>数字型，包含整型值和浮点型值，如21，0.21</td><td>0</td></tr><tr><td>boolean</td><td>布尔值类型，如true，false ，等价于1和0</td><td>false</td></tr><tr><td>undefined</td><td>var a; 声明了变量a但是没有赋值，此时a=undefined</td><td>undefined（未定义的）</td></tr><tr><td>string</td><td>字符串类型，如“张三”</td><td>“”</td></tr><tr><td>null</td><td>var a = null;声明了变量a为空值</td><td>null</td></tr></tbody></table><p>详细信息参考：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F(string_literals)">语法和数据类型 - JavaScript | MDN (mozilla.org)</a></p><h3 id="2-4-数据类型的转换"><a href="#2-4-数据类型的转换" class="headerlink" title="2.4 数据类型的转换"></a>2.4 数据类型的转换</h3><h4 id="1-转换为字符串型"><a href="#1-转换为字符串型" class="headerlink" title="1 转换为字符串型"></a>1 转换为字符串型</h4><table><thead><tr><th align="center">方式</th><th align="center">说明</th><th align="center">案例</th></tr></thead><tbody><tr><td align="center">toString()</td><td align="center">转成字符串</td><td align="center">var num = 1; alert(num.toString());</td></tr><tr><td align="center">String()强制转换</td><td align="center">转成字符串</td><td align="center">var num = 1; alert(String(num));</td></tr><tr><td align="center"><strong>加号拼接字符串</strong></td><td align="center">和字符串拼接的结果都是字符串</td><td align="center">var num =1; alert(num+“我是字符串”);</td></tr></tbody></table><h4 id="2-转换为数字型"><a href="#2-转换为数字型" class="headerlink" title="2  转换为数字型"></a>2  转换为数字型</h4><table><thead><tr><th>方式</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td><strong>parselnt(string)函数</strong></td><td>将string类型转成整数数值型</td><td>parselnt(‘78’)</td></tr><tr><td><strong>parseFloat(string)函数</strong></td><td>将string类型转成浮点数数值型</td><td>parseFloat(‘78.21’)</td></tr><tr><td>Number()强制转换函数</td><td>将string类型转换为数值型</td><td>Number(‘12’)</td></tr><tr><td>js 隐式转换(- * /)</td><td>利用算术运算隐式转换为数值型</td><td>‘12’-0</td></tr></tbody></table><h4 id="3-转换为布尔型"><a href="#3-转换为布尔型" class="headerlink" title="3 转换为布尔型"></a>3 转换为布尔型</h4><table><thead><tr><th>方法</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td>Boolean()函数</td><td>其他类型转成布尔值</td><td>Boolean(‘true’);</td></tr></tbody></table><ul><li>代表空、否定的值会被转换为false，如 ’ ’ , 0, NaN , null , undefined</li><li>其余的值都会被被转换为true</li></ul><h3 id="2-5-运算符"><a href="#2-5-运算符" class="headerlink" title="2.5 运算符"></a>2.5 运算符</h3><p>运算符（operator）也被称为<strong>操作符</strong>，是用于实现赋值、比较和执行算数运算等功能的符号</p><p>JavaScript 中常用的运算符有：</p><ul><li>算数运算符</li><li>递增和递减运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>赋值运算符</li></ul><h3 id="2-6-流程控制"><a href="#2-6-流程控制" class="headerlink" title="2.6 流程控制"></a>2.6 流程控制</h3><ul><li>if</li><li>switch</li><li>三元表达式</li></ul><h2 id="3-断点调试"><a href="#3-断点调试" class="headerlink" title="3 断点调试"></a>3 断点调试</h2><ol><li>浏览器中按 F12 -&gt; sources -&gt;找到需要调试的文件 -&gt; 在程序的某一行设置断点</li><li>刷新浏览器</li><li>Watch: 监视，通过watch可以监视变量的值的变化</li><li>F11: 程序单步执行，观察watch中变量的值的变化</li></ol><h2 id="4-循环"><a href="#4-循环" class="headerlink" title="4 循环"></a>4 循环</h2><ul><li>for</li><li>while</li><li>do - while</li><li>continue 关键字</li><li>break 关键字</li></ul><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><h3 id="5-1-创建数组"><a href="#5-1-创建数组" class="headerlink" title="5.1 创建数组"></a>5.1 创建数组</h3><p>JavaScript 中创建数组有两种方式：</p><ul><li>利用 new 创建数组</li><li>利用数组字面量创建数组</li></ul><pre class="line-numbers language-none"><code class="language-none">// 1.利用数组字面量方式创建空的数组 var 数组名 =[];// 2.使用数组字面量方式创建带初始值的数组var 数组名 =['小白','小黑','小黄','瑞奇'];// 3.数组中可以存放任意类型的数据，例如字符串，数字，布尔值等var arrStus =['小白',12,true,28.9];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-数组中新增元素"><a href="#5-2-数组中新增元素" class="headerlink" title="5.2 数组中新增元素"></a>5.2 数组中新增元素</h3><h4 id="1-通过修改-length-长度新增数组元素"><a href="#1-通过修改-length-长度新增数组元素" class="headerlink" title="1 通过修改 length 长度新增数组元素"></a>1 通过修改 length 长度新增数组元素</h4><ul><li>可以通过修改 length 长度来实现数组扩容的目的</li><li>length 属性是可读写的</li></ul><pre class="line-numbers language-none"><code class="language-none">var arr = ['red', 'green', 'blue', 'pink'];arr.length = 7;console.log(arr);console.log(arr[4]);console.log(arr[5]);console.log(arr[6]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中索引号是 4，5，6 的空间没有给值，就是声明变量未给值，默认值就是 <strong>undefined</strong></p><h4 id="2-通过修改数组索引新增数组元素"><a href="#2-通过修改数组索引新增数组元素" class="headerlink" title="2 通过修改数组索引新增数组元素"></a>2 通过修改数组索引新增数组元素</h4><ul><li>可以通过修改数组索引的方式追加数组元素</li><li>不能直接给数组名赋值，否则会覆盖掉以前的数据</li><li>这种方式也是我们最常用的一种方式</li></ul><pre class="line-numbers language-none"><code class="language-none">var arr = ['red', 'green', 'blue', 'pink'];arr[4] = 'hotpink';console.log(arr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="6-1-函数的参数"><a href="#6-1-函数的参数" class="headerlink" title="6.1 函数的参数"></a>6.1 函数的参数</h3><h4 id="形参和实参个数不匹配"><a href="#形参和实参个数不匹配" class="headerlink" title="形参和实参个数不匹配"></a>形参和实参个数不匹配</h4><table><thead><tr><th align="center">参数个数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">实参个数等于形参个数</td><td align="center">输出正确结果</td></tr><tr><td align="center">实参个数多于形参个数</td><td align="center">只取到形参的个数</td></tr><tr><td align="center">实参个数小于形参个数</td><td align="center">多的形参定义为undefined</td></tr></tbody></table><h3 id="6-2-arguments-的使用"><a href="#6-2-arguments-的使用" class="headerlink" title="6.2 arguments 的使用"></a>6.2 arguments 的使用</h3><p>当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。</p><ul><li><strong>arguments</strong>存放的是传递过来的实参</li><li><strong>arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</strong><ol><li>具有 length 属性</li><li>按索引方式储存数据</li><li>不具有数组的 push , pop 等方法</li></ol></li></ul><h3 id="6-3-函数的两种声明方式"><a href="#6-3-函数的两种声明方式" class="headerlink" title="6.3 函数的两种声明方式"></a>6.3 函数的两种声明方式</h3><h4 id="1-自定义函数方式-命名函数"><a href="#1-自定义函数方式-命名函数" class="headerlink" title="1 自定义函数方式(命名函数)"></a>1 自定义函数方式(命名函数)</h4><p>利用函数关键字 function 自定义函数方式。</p><pre class="line-numbers language-none"><code class="language-none">// 声明定义方式function fn() {...}// 调用  fn(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</strong></p><h4 id="2-函数表达式方式-匿名函数"><a href="#2-函数表达式方式-匿名函数" class="headerlink" title="2 函数表达式方式(匿名函数)"></a>2 函数表达式方式(匿名函数)</h4><pre class="line-numbers language-none"><code class="language-none">// 这是函数表达式写法，匿名函数后面跟分号结束var fn = function(){...};// 调用的方式，函数调用必须写到函数体下面fn();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>因为函数没有名字，所以也称为<strong>匿名函数</strong></li><li>这个 fn 里面存储的是一个函数</li><li><strong>函数调用的代码必须写到函数体后面</strong></li></ol><h2 id="7-作用域"><a href="#7-作用域" class="headerlink" title="7 作用域"></a>7 作用域</h2><h3 id="7-1-全局作用域"><a href="#7-1-全局作用域" class="headerlink" title="7.1 全局作用域"></a>7.1 全局作用域</h3><h3 id="7-2-局部（函数）作用域"><a href="#7-2-局部（函数）作用域" class="headerlink" title="7.2 局部（函数）作用域"></a>7.2 局部（函数）作用域</h3><h3 id="7-3-块级作用域"><a href="#7-3-块级作用域" class="headerlink" title="7.3 块级作用域"></a>7.3 块级作用域</h3><p><code>var</code> 声明的变量没有块级作用域， <code>let</code> 和 <code>const</code> 声明的变量有块级作用域。我们常用 <code>let</code> 和 <code>const</code> 声明变量。</p><h2 id="8-预解析"><a href="#8-预解析" class="headerlink" title="8 预解析"></a>8 预解析</h2><p>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：<strong>预解析和代码执行。</strong></p><ul><li><strong>预解析</strong>：js引擎会把js里面所有的 <strong>var</strong> 还有 <strong>function</strong> 提升到当前作用域的最前面</li><li><strong>代码执行</strong>：从上到下执行JS语句</li></ul><h3 id="8-1-变量预解析（变量提升）"><a href="#8-1-变量预解析（变量提升）" class="headerlink" title="8.1 变量预解析（变量提升）"></a>8.1 变量预解析（变量提升）</h3><p>变量提升: 变量的声明会被提升到<strong>当前作用域</strong>的最上面，变量的赋值不会提升</p><pre class="line-numbers language-none"><code class="language-none">console.log(num);  // undefinedvar num = 10;   //相当于执行了以下代码var num;// 变量声明提升到当前作用域最上面console.log(num);num = 10;// 变量的赋值不会提升<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>8.2 函数预解析（函数提升）</p><p>函数提升： 函数的声明会被提升到<strong>当前作用域</strong>的最上面，但是不会调用函数。</p><pre class="line-numbers language-none"><code class="language-none">fn();//hellofunction fn() {    console.log('hello');}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-对象"><a href="#9-对象" class="headerlink" title="9 对象"></a>9 对象</h2><p>对象是由属性和方法组成的。</p><h3 id="9-1-创建对象"><a href="#9-1-创建对象" class="headerlink" title="9.1 创建对象"></a>9.1 创建对象</h3><p>在 JavaScript 中，现阶段我们可以采用三种方式创建对象（object）：</p><ul><li>利用字面量创建对象</li><li>利用 new Object创建对象</li><li>利用构造函数创建对象</li></ul><h4 id="1-利用字面量创建对象"><a href="#1-利用字面量创建对象" class="headerlink" title="1 利用字面量创建对象"></a>1 利用字面量创建对象</h4><p>对象字面量：就是花括号 <code>{ }</code> 里面包含了表达这个具体事物（对象）的属性和方法</p><p><code>{ }</code> 里面采取键值对的形式表示</p><ul><li>键：相当于属性名</li><li>值：相当于属性值，可以是任意类型的值</li></ul><pre class="line-numbers language-none"><code class="language-none">var star = {    name : 'pink',    age : 18,    sex : '男',    sayHi : function(){        alert('大家好啊~');    }};// 多个属性或者方法中间用逗号隔开// 方法冒号后面跟的是一个匿名函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-利用-new-Object-创建对象"><a href="#2-利用-new-Object-创建对象" class="headerlink" title="2  利用 new Object 创建对象"></a>2  利用 <code>new Object</code> 创建对象</h4><p>跟之前的 <code>new Array()</code> 原理一致：<code>var 对象名 = new Object();</code></p><p>使用的格式：对象.属性 = 值</p><pre class="line-numbers language-none"><code class="language-none">var obj = new Object(); //创建了一个空的对象obj.name = '张三丰';obj.age = 18;obj.sex = '男';obj.sayHi = function() {    console.log('hi~');}//1.我们是利用等号赋值的方法添加对象//2.每个属性和方法之间用分号结束console.log(obj.uname);console.log(obj['sex']);obj.sayHi();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-利用构造函数创建对象"><a href="#3-利用构造函数创建对象" class="headerlink" title="3 利用构造函数创建对象"></a>3 利用构造函数创建对象</h4><p><strong>构造函数</strong> ：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p><p>在 js 中，使用构造函数要时要注意以下两点：</p><ul><li>构造函数用于创建某一类对象，其首字母要大写</li><li>构造函数要和 new 一起使用才有意义</li></ul><pre class="line-numbers language-none"><code class="language-none">//构造函数的语法格式function 构造函数名() {    this.属性 = 值;    this.方法 = function() {}}new 构造函数名();//示例function People(uname, age, sex) {    this.name = uname;    this.age = age;    this.sex = sex;    this.sing = function(sang){        console.log(sang);    }}var xm = new People('小明', 18, '男');console.log(typeof xm) // object对象，调用函数返回的是对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>构造函数名字首字母要大写</li><li>函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。</li><li>构造函数中不需要 return 返回结果。</li><li>当我们创建对象的时候，必须用 new 来调用构造函数。</li></ul><h4 id="4-对象的调用"><a href="#4-对象的调用" class="headerlink" title="4 对象的调用"></a>4 对象的调用</h4><ul><li>对象里面的属性调用 : <code>对象.属性名</code> 或者 <code>对象['属性名']</code></li><li>对象里面的方法调用：对象.方法名() </li></ul><h4 id="5-变量、函数、属性、方法总结"><a href="#5-变量、函数、属性、方法总结" class="headerlink" title="5 变量、函数、属性、方法总结"></a>5 变量、函数、属性、方法总结</h4><ul><li>变量：单独声明赋值，单独存在</li><li>函数：单独存在的，通过<code>函数名()</code>的方式就可以调用</li><li>属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征</li><li>方法：对象里面的函数称为方法，不需要声明，使用<code>对象.方法名()</code>的方式就可以调用，方法用来描述该对象的行为和功能</li></ul><h3 id="9-2-遍历对象的属性"><a href="#9-2-遍历对象的属性" class="headerlink" title="9.2 遍历对象的属性"></a>9.2 遍历对象的属性</h3><p><code>for...in</code> 语句用于对数组或者对象的属性进行循环操作</p><pre class="line-numbers language-none"><code class="language-none">for(变量 in 对象名字){    // 在此执行代码}for(var k in obj) {    console.log(k);//这里的 k 是属性名    console.log(obj[k]);//这里的 obj[k] 是属性值}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-内置对象"><a href="#10-内置对象" class="headerlink" title="10 内置对象"></a>10 内置对象</h2><ul><li>JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象</li><li>内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能</li><li>JavaScript 提供了多个内置对象：Math、 Date 、Array、String等</li></ul><h3 id="10-1-Math"><a href="#10-1-Math" class="headerlink" title="10.1 Math"></a>10.1 Math</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math">Math - JavaScript | MDN (mozilla.org)</a></p><h3 id="10-2-Date"><a href="#10-2-Date" class="headerlink" title="10.2  Date"></a>10.2  Date</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date">Date - JavaScript | MDN (mozilla.org)</a></p><h3 id="10-3-Array"><a href="#10-3-Array" class="headerlink" title="10.3  Array"></a>10.3  Array</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">Array - JavaScript | MDN (mozilla.org)</a></p><h3 id="10-4-String"><a href="#10-4-String" class="headerlink" title="10.4 String"></a>10.4 String</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String">String - JavaScript | MDN (mozilla.org)</a></p><h2 id="11-简单类型与复杂类型"><a href="#11-简单类型与复杂类型" class="headerlink" title="11 简单类型与复杂类型"></a>11 简单类型与复杂类型</h2><p>简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。</p><ul><li>值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型：string ，number，boolean，undefined，null</li><li>引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型：通过 <code>new</code> 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等</li></ul><h3 id="11-1-堆和栈"><a href="#11-1-堆和栈" class="headerlink" title="11.1 堆和栈"></a>11.1 堆和栈</h3><ol><li>栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。简单数据类型存放到栈里面；</li><li>堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型存放到堆里面。</li></ol><p>注意：JavaScript中没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式，便于将来学习其他语言。</p><h3 id="11-2-简单类型的内存分配"><a href="#11-2-简单类型的内存分配" class="headerlink" title="11.2 简单类型的内存分配"></a>11.2 简单类型的内存分配</h3><ul><li>值类型变量的数据直接存放在变量（栈空间）中</li><li>引用类型（复杂数据类型）：通过 new 关键字创建的对象（系统对象、自定义对象），引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</li></ul><img src="image-20210814022505364.png" alt="image-20210814022505364" style="zoom: 67%;"><p>复杂类型传参可以理解为传的是复杂类型的地址。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 和 CSS3 提高</title>
      <link href="/2021/07/31/html5css3-ti-gao/"/>
      <url>/2021/07/31/html5css3-ti-gao/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5-和-CSS3-提高"><a href="#HTML5-和-CSS3-提高" class="headerlink" title="HTML5 和 CSS3 提高"></a>HTML5 和 CSS3 提高</h1><h2 id="1-HTML5-的新特性"><a href="#1-HTML5-的新特性" class="headerlink" title="1 HTML5 的新特性"></a>1 HTML5 的新特性</h2><img src="image-20210731041634217.png" alt="image-20210731041634217" style="zoom:67%;"><h3 id="1-1-HTML5-新增的语义化标签"><a href="#1-1-HTML5-新增的语义化标签" class="headerlink" title="1.1 HTML5 新增的语义化标签"></a>1.1 HTML5 新增的语义化标签</h3><p>以前布局，我们基本用 div 来做。div 对于搜索引擎来说，是没有语义的。</p><pre class="line-numbers language-none"><code class="language-none">&lt;div class=“header”&gt; &lt;/div&gt;&lt;div class=“nav”&gt; &lt;/div&gt;&lt;div class=“content”&gt; &lt;/div&gt;&lt;div class=“footer”&gt; &lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20210731041705440.png" alt="image-20210731041705440"></p><h3 id="1-2-HTML5-新增的多媒体标签"><a href="#1-2-HTML5-新增的多媒体标签" class="headerlink" title="1.2 HTML5 新增的多媒体标签"></a>1.2 HTML5 新增的多媒体标签</h3><img src="image-20210731041726954.png" alt="image-20210731041726954" style="zoom:67%;"><p>HTML5 在不使用插件的情况下，也可以原生的支持视频格式文件的播放，当然，支持的格式是有限的。</p><h4 id="1-2-1-视频-lt-video-gt"><a href="#1-2-1-视频-lt-video-gt" class="headerlink" title="1.2.1 视频 <video>"></a>1.2.1 视频 <code>&lt;video&gt;</code></h4><img src="image-20210731041820911.png" alt="image-20210731041820911" style="zoom:67%;"><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;video src="文件地址" controls="controls"&gt;&lt;/video&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;video controls="controls" width="300"&gt;&lt;source src="move.ogg" type="video/ogg" &gt;&lt;source src="move.mp4" type="video/mp4" &gt;您的浏览器暂不支持 &lt;video&gt; 标签播放视频&lt;/ video &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>常见属性：</strong></p><img src="image-20210731041938663.png" alt="image-20210731041938663" style="zoom:67%;"><h4 id="1-2-2-音频-lt-audio-gt"><a href="#1-2-2-音频-lt-audio-gt" class="headerlink" title="1.2.2 音频 <audio>"></a>1.2.2 音频 <code>&lt;audio&gt;</code></h4><p>当前 <code>&lt;audio&gt;</code> 元素支持三种音频格式：</p><img src="image-20210731042055915.png" alt="image-20210731042055915" style="zoom:67%;"><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;audio src="文件地址" controls="controls"&gt;&lt;/audio&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt; audio controls="controls" &gt;&lt;source src="happy.mp3" type="audio/mpeg" &gt;&lt;source src="happy.ogg" type="audio/ogg" &gt;您的浏览器暂不支持 &lt;audio&gt; 标签。&lt;/ audio&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>常见属性：</strong></p><img src="image-20210731042149080.png" alt="image-20210731042149080" style="zoom:67%;"><p>谷歌浏览器把音频和视频自动播放禁止了。</p><h4 id="1-2-3-多媒体标签总结"><a href="#1-2-3-多媒体标签总结" class="headerlink" title="1.2.3 多媒体标签总结"></a>1.2.3 多媒体标签总结</h4><img src="image-20210731042338376.png" alt="image-20210731042338376" style="zoom:67%;"><h3 id="1-3-HTML5-新增的-input-类型"><a href="#1-3-HTML5-新增的-input-类型" class="headerlink" title="1.3 HTML5 新增的 input 类型"></a>1.3 HTML5 新增的 input 类型</h3><img src="image-20210731042357462.png" alt="image-20210731042357462" style="zoom:67%;"><p>重点记住： number tel search 这三个。</p><h3 id="1-4-HTML5-新增的表单属性"><a href="#1-4-HTML5-新增的表单属性" class="headerlink" title="1.4 HTML5 新增的表单属性"></a>1.4 HTML5 新增的表单属性</h3><img src="image-20210731042419720.png" alt="image-20210731042419720" style="zoom:67%;"><p>可以通过以下设置方式修改placeholder里面的字体颜色：</p><pre class="line-numbers language-none"><code class="language-none">input::placeholder { color: pink;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2-CSS3-的新特性"><a href="#2-CSS3-的新特性" class="headerlink" title="2 CSS3 的新特性"></a>2 CSS3 的新特性</h2><h3 id="2-1-CSS3-的现状"><a href="#2-1-CSS3-的现状" class="headerlink" title="2.1 CSS3 的现状"></a>2.1 CSS3 的现状</h3><img src="image-20210731042506578.png" alt="image-20210731042506578" style="zoom:67%;"><img src="image-20210731042521374.png" alt="image-20210731042521374" style="zoom:67%;"><h3 id="2-2-属性选择器"><a href="#2-2-属性选择器" class="headerlink" title="2.2 属性选择器"></a>2.2 属性选择器</h3><p>属性选择器可以根据元素特定属性的来选择元素。 这样就可以不用借助于类或者id选择器。</p><img src="image-20210731042535868.png" alt="image-20210731042535868" style="zoom:67%;"><p>注意：类选择器、属性选择器、伪类选择器，权重为 10。</p><h3 id="2-3-结构伪类选择器"><a href="#2-3-结构伪类选择器" class="headerlink" title="2.3 结构伪类选择器"></a>2.3 结构伪类选择器</h3><p>结构伪类选择器主要根据<strong>文档结构</strong>来选择器元素， 常用于根据父级选择器里面的子元素。</p><img src="image-20210731042624202.png" alt="image-20210731042624202" style="zoom:67%;"><p>注意：类选择器、属性选择器、伪类选择器，权重为 10。</p><img src="image-20210731042641306.png" alt="image-20210731042641306" style="zoom:67%;"><p>区别： </p><ol><li>nth-child 对父元素里面所有孩子排序选择（序号是固定的） 先找到第n个孩子，然后看看是否和E匹配 </li><li>nth-of-type 对父元素里面指定子元素进行排序选择。 先去匹配E ，然后再根据E 找第n个孩子</li></ol><img src="image-20210731042711743.png" alt="image-20210731042711743" style="zoom:67%;"><h3 id="2-4-伪元素选择器（重点）"><a href="#2-4-伪元素选择器（重点）" class="headerlink" title="2.4 伪元素选择器（重点）"></a>2.4 伪元素选择器（重点）</h3><img src="image-20210731042727210.png" alt="image-20210731042727210" style="zoom:67%;"><h4 id="2-4-1-伪元素选择器使用场景1：伪元素字体图标"><a href="#2-4-1-伪元素选择器使用场景1：伪元素字体图标" class="headerlink" title="2.4.1 伪元素选择器使用场景1：伪元素字体图标"></a>2.4.1 伪元素选择器使用场景1：伪元素字体图标</h4><img src="image-20210731042830398.png" alt="image-20210731042830398" style="zoom:67%;"><pre class="line-numbers language-none"><code class="language-none">p::before {position: absolute;right: 20px;top: 10px;content: '\e91e';font-size: 20px;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-2-伪元素选择器使用场景2：仿土豆效果"><a href="#2-4-2-伪元素选择器使用场景2：仿土豆效果" class="headerlink" title="2.4.2 伪元素选择器使用场景2：仿土豆效果"></a>2.4.2 伪元素选择器使用场景2：仿土豆效果</h4><pre class="line-numbers language-none"><code class="language-none">/* 当我们鼠标经过了 土豆这个盒子，就让里面before遮罩层显示出来 */.tudou:hover::before { /* 而是显示元素 */ display: block;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-3-伪元素选择器使用场景3：伪元素清除浮动"><a href="#2-4-3-伪元素选择器使用场景3：伪元素清除浮动" class="headerlink" title="2.4.3 伪元素选择器使用场景3：伪元素清除浮动"></a>2.4.3 伪元素选择器使用场景3：伪元素清除浮动</h4><img src="image-20210731042920949.png" alt="image-20210731042920949" style="zoom:67%;"><img src="image-20210731042930714.png" alt="image-20210731042930714" style="zoom:67%;"><img src="image-20210731042938165.png" alt="image-20210731042938165" style="zoom:67%;"><img src="image-20210731042953142.png" alt="image-20210731042953142" style="zoom:67%;"><h3 id="2-5-CSS3-盒子模型"><a href="#2-5-CSS3-盒子模型" class="headerlink" title="2.5 CSS3 盒子模型"></a>2.5 CSS3 盒子模型</h3><img src="image-20210731043035312.png" alt="image-20210731043035312" style="zoom:67%;"><h3 id="2-6-CSS3-其他特性（了解）"><a href="#2-6-CSS3-其他特性（了解）" class="headerlink" title="2.6 CSS3 其他特性（了解）"></a>2.6 CSS3 其他特性（了解）</h3><img src="image-20210731043114296.png" alt="image-20210731043114296" style="zoom:67%;"><img src="image-20210731043126496.png" style="zoom:67%;"><h3 id="2-7-CSS3-过渡（重点）"><a href="#2-7-CSS3-过渡（重点）" class="headerlink" title="2.7 CSS3 过渡（重点）"></a>2.7 CSS3 过渡（重点）</h3><img src="image-20210731043151085.png" alt="image-20210731043151085" style="zoom:67%;"><img src="image-20210731043158942.png" alt="image-20210731043158942" style="zoom:67%;"><h2 id="狭义的HTML5-CSS3"><a href="#狭义的HTML5-CSS3" class="headerlink" title="狭义的HTML5 CSS3"></a>狭义的HTML5 CSS3</h2><img src="image-20210731043256872.png" alt="image-20210731043256872" style="zoom:67%;"><h2 id="广义的HTML5"><a href="#广义的HTML5" class="headerlink" title="广义的HTML5"></a>广义的HTML5</h2><img src="image-20210731043304433.png" alt="image-20210731043304433" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础总结 7/7</title>
      <link href="/2021/07/31/css-7-7/"/>
      <url>/2021/07/31/css-7-7/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础总结-7-7"><a href="#CSS-基础总结-7-7" class="headerlink" title="CSS 基础总结 7/7"></a>CSS 基础总结 7/7</h1><h2 id="1-精灵图"><a href="#1-精灵图" class="headerlink" title="1 精灵图"></a>1 精灵图</h2><h3 id="1-1-为什么需要精灵图"><a href="#1-1-为什么需要精灵图" class="headerlink" title="1.1 为什么需要精灵图"></a>1.1 为什么需要精灵图</h3><img src="image-20210731033446339.png" alt="image-20210731033446339" style="zoom:67%;"><img src="image-20210731033508435.png" alt="image-20210731033508435" style="zoom:67%;"><h3 id="1-2-精灵图（sprites）的使用"><a href="#1-2-精灵图（sprites）的使用" class="headerlink" title="1.2 精灵图（sprites）的使用"></a>1.2 精灵图（sprites）的使用</h3><img src="image-20210731033527478.png" alt="image-20210731033527478" style="zoom:67%;"><h2 id="2-字体图标"><a href="#2-字体图标" class="headerlink" title="2 字体图标"></a>2 字体图标</h2><h3 id="2-1-字体图标的产生"><a href="#2-1-字体图标的产生" class="headerlink" title="2.1 字体图标的产生"></a>2.1 字体图标的产生</h3><img src="image-20210731033623041.png" alt="image-20210731033623041" style="zoom:67%;"><h3 id="2-2-字体图标的优点"><a href="#2-2-字体图标的优点" class="headerlink" title="2.2 字体图标的优点"></a>2.2 字体图标的优点</h3><img src="image-20210731033641913.png" alt="image-20210731033641913" style="zoom:67%;"><img src="image-20210731033653183.png" alt="image-20210731033653183" style="zoom:67%;"><h3 id="2-3-字体图标的下载"><a href="#2-3-字体图标的下载" class="headerlink" title="2.3 字体图标的下载"></a>2.3 字体图标的下载</h3><img src="image-20210731033713669.png" alt="image-20210731033713669" style="zoom:67%;"><h3 id="2-4-字体图标的引入"><a href="#2-4-字体图标的引入" class="headerlink" title="2.4 字体图标的引入"></a>2.4 字体图标的引入</h3><img src="image-20210731033735008.png" alt="image-20210731033735008" style="zoom:67%;"><h4 id="2-4-1-字体文件格式"><a href="#2-4-1-字体文件格式" class="headerlink" title="2.4.1 字体文件格式"></a>2.4.1 字体文件格式</h4><img src="image-20210731033755060.png" alt="image-20210731033755060" style="zoom:67%;"><h4 id="2-4-2-字体的声明"><a href="#2-4-2-字体的声明" class="headerlink" title="2.4.2 字体的声明"></a>2.4.2 字体的声明</h4><p>.在 CSS 样式中全局声明字体： 简单理解把这些字体文件通过css引入到我们页面中。</p><p>一定注意字体文件路径的问题。</p><pre class="line-numbers language-none"><code class="language-none">@font-face { font-family: 'icomoon'; src: url('fonts/icomoon.eot?7kkyc2'); src: url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype'), url('fonts/icomoon.ttf?7kkyc2') format('truetype'), url('fonts/icomoon.woff?7kkyc2') format('woff'), url('fonts/icomoon.svg?7kkyc2#icomoon') format('svg'); font-weight: normal; font-style: normal;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（在下载的 style.css 文件中复制）</p><h4 id="2-4-3-HTML-标签内添加小图标"><a href="#2-4-3-HTML-标签内添加小图标" class="headerlink" title="2.4.3 HTML 标签内添加小图标"></a>2.4.3 HTML 标签内添加小图标</h4><img src="image-20210731034022920.png" alt="image-20210731034022920" style="zoom:67%;"><h4 id="2-4-4-给标签定义字体"><a href="#2-4-4-给标签定义字体" class="headerlink" title="2.4.4 给标签定义字体"></a>2.4.4 给标签定义字体</h4><img src="image-20210731034102244.png" alt="image-20210731034102244" style="zoom:67%;"><h3 id="2-5-字体图标的追加"><a href="#2-5-字体图标的追加" class="headerlink" title="2.5 字体图标的追加"></a>2.5 字体图标的追加</h3><img src="image-20210731034121415.png" alt="image-20210731034121415" style="zoom:67%;"><img src="image-20210731034127524.png" alt="image-20210731034127524" style="zoom:67%;"><h2 id="3-CSS-三角"><a href="#3-CSS-三角" class="headerlink" title="3 CSS 三角"></a>3 CSS 三角</h2><img src="image-20210731034152733.png" alt="image-20210731034152733" style="zoom:67%;"><pre class="line-numbers language-none"><code class="language-none">div { width: 0; height: 0; line-height: 0; font-size: 0; border: 50px solid transparent; border-left-color: pink;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-CSS-用户界面样式"><a href="#4-CSS-用户界面样式" class="headerlink" title="4 CSS 用户界面样式"></a>4 CSS 用户界面样式</h2><h3 id="4-0-什么是界面样式"><a href="#4-0-什么是界面样式" class="headerlink" title="4.0 什么是界面样式"></a>4.0 什么是界面样式</h3><img src="image-20210731034228067.png" alt="image-20210731034228067" style="zoom:67%;"><h3 id="4-1-鼠标样式-cursor"><a href="#4-1-鼠标样式-cursor" class="headerlink" title="4.1 鼠标样式 cursor"></a>4.1 鼠标样式 cursor</h3><pre class="line-numbers language-none"><code class="language-none">li {cursor: pointer; }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="image-20210731034300808.png" alt="image-20210731034300808" style="zoom:67%;"><h3 id="4-2-轮廓线-outline"><a href="#4-2-轮廓线-outline" class="headerlink" title="4.2 轮廓线 outline"></a>4.2 轮廓线 outline</h3><p>给表单添加 outline: 0; 或者 outline: none; 样式之后，就可以去掉默认的蓝色边框。</p><pre class="line-numbers language-none"><code class="language-none">input {outline: none; }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-3-防止拖拽文本域-resize"><a href="#4-3-防止拖拽文本域-resize" class="headerlink" title="4.3 防止拖拽文本域 resize"></a>4.3 防止拖拽文本域 resize</h3><p>实际开发中，我们文本域右下角是不可以拖拽的。</p><pre class="line-numbers language-none"><code class="language-none">textarea{ resize: none;}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-vertical-align-属性应用"><a href="#5-vertical-align-属性应用" class="headerlink" title="5 vertical-align 属性应用"></a>5 vertical-align 属性应用</h2><h3 id="5-0-vertical-align-属性"><a href="#5-0-vertical-align-属性" class="headerlink" title="5.0  vertical-align 属性"></a>5.0  vertical-align 属性</h3><p>CSS 的 <strong>vertical-align</strong> 属性使用场景： 经常用于设置图片或者表单(行内块元素）和文字垂直对齐。 </p><p>官方解释： 用于设置一个元素的<strong>垂直对齐方式</strong>，但是它只针对于行内元素或者行内块元素有效。</p><pre class="line-numbers language-none"><code class="language-none">vertical-align : baseline | top | middle | bottom <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="image-20210731034547011.png" alt="image-20210731034547011" style="zoom:67%;"><img src="image-20210731034553446.png" alt="image-20210731034553446" style="zoom:67%;"><h3 id="5-1-图片、表单和文字对齐"><a href="#5-1-图片、表单和文字对齐" class="headerlink" title="5.1 图片、表单和文字对齐"></a>5.1 图片、表单和文字对齐</h3><img src="image-20210731034633745.png" alt="image-20210731034633745" style="zoom:67%;"><h3 id="5-2-解决图片底部默认空白缝隙问题"><a href="#5-2-解决图片底部默认空白缝隙问题" class="headerlink" title="5.2 解决图片底部默认空白缝隙问题"></a>5.2 解决图片底部默认空白缝隙问题</h3><img src="C:/Users/tzy/Desktop/article/css/css7of7/image-20210731034649015.png" alt="image-20210731034649015" style="zoom:67%;"><h2 id="6-溢出的文字省略号显示"><a href="#6-溢出的文字省略号显示" class="headerlink" title="6 溢出的文字省略号显示"></a>6 溢出的文字省略号显示</h2><img src="image-20210731040225932.png" alt="image-20210731040225932" style="zoom:67%;"><h3 id="6-1-单行文本溢出显示省略号"><a href="#6-1-单行文本溢出显示省略号" class="headerlink" title="6.1  单行文本溢出显示省略号"></a>6.1  单行文本溢出显示省略号</h3><p>必须满足三个条件</p><pre class="line-numbers language-none"><code class="language-none">/*1. 先强制一行内显示文本*/white-space: nowrap; （ 默认 normal 自动换行）/*2. 超出的部分隐藏*/overflow: hidden;/*3. 文字用省略号替代超出的部分*/text-overflow: ellipsis;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-多行文本溢出显示省略号"><a href="#6-2-多行文本溢出显示省略号" class="headerlink" title="6.2 多行文本溢出显示省略号"></a>6.2 多行文本溢出显示省略号</h3><p>多行文本溢出显示省略号，有较大兼容性问题， 适合于webKit浏览器或移动端（移动端大部分是webkit内 核）</p><pre class="line-numbers language-none"><code class="language-none">overflow: hidden;text-overflow: ellipsis;/* 弹性伸缩盒子模型显示 */display: -webkit-box;/* 限制在一个块元素显示的文本的行数 */-webkit-line-clamp: 2;/* 设置或检索伸缩盒对象的子元素的排列方式 */-webkit-box-orient: vertical;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更推荐让后台人员来做这个效果，因为后台人员可以设置显示多少个字，操作更简单。</p><h2 id="7-常见布局技巧"><a href="#7-常见布局技巧" class="headerlink" title="7 常见布局技巧"></a>7 常见布局技巧</h2><h3 id="7-1-margin负值运用"><a href="#7-1-margin负值运用" class="headerlink" title="7.1 margin负值运用"></a>7.1 margin负值运用</h3><img src="image-20210731035005055.png" alt="image-20210731035005055" style="zoom:67%;"><h3 id="7-2-文字围绕浮动元素"><a href="#7-2-文字围绕浮动元素" class="headerlink" title="7.2 文字围绕浮动元素"></a>7.2 文字围绕浮动元素</h3><img src="image-20210731035044206.png" alt="image-20210731035044206" style="zoom:67%;"><h3 id="7-3-行内块巧妙运用"><a href="#7-3-行内块巧妙运用" class="headerlink" title="7.3 行内块巧妙运用"></a>7.3 行内块巧妙运用</h3><img src="image-20210731035118099.png" alt="image-20210731035118099" style="zoom:67%;"><h3 id="7-4-CSS-三角强化"><a href="#7-4-CSS-三角强化" class="headerlink" title="7.4 CSS 三角强化"></a>7.4 CSS 三角强化</h3><img src="image-20210731035146874.png" alt="image-20210731035146874" style="zoom:67%;"><pre class="line-numbers language-none"><code class="language-none">width: 0;height: 0;border-color: transparent red transparent transparent;border-style: solid;border-width: 22px 8px 0 0;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8-CSS-初始化"><a href="#8-CSS-初始化" class="headerlink" title="8 CSS 初始化"></a>8 CSS 初始化</h2><img src="image-20210731035230440.png" alt="image-20210731035230440" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础总结 6/7</title>
      <link href="/2021/07/29/css-6-7/"/>
      <url>/2021/07/29/css-6-7/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础总结-6-7"><a href="#CSS-基础总结-6-7" class="headerlink" title="CSS 基础总结 6/7"></a>CSS 基础总结 6/7</h1><h2 id="1-定位"><a href="#1-定位" class="headerlink" title="1 定位"></a>1 定位</h2><h3 id="1-1-为什么需要定位"><a href="#1-1-为什么需要定位" class="headerlink" title="1.1 为什么需要定位"></a>1.1 为什么需要定位</h3><p>提问： 以下情况使用标准流或者浮动能实现吗？ </p><ol><li>某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子。</li><li>当我们滚动窗口的时候，盒子是固定屏幕某个位置的。</li></ol><p>以上效果，标准流或浮动都无法快速实现，此时需要定位来实现。 </p><p>所以： </p><ol><li>浮动可以让多个块级盒子一行没有缝隙排列显示， 经常用于横向排列盒子。 </li><li>定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。</li></ol><h3 id="1-2-定位组成"><a href="#1-2-定位组成" class="headerlink" title="1.2 定位组成"></a>1.2 定位组成</h3><img src="image-20210729233532811.png" alt="image-20210729233532811" style="zoom:67%;"><img src="image-20210729233601687.png" alt="image-20210729233601687" style="zoom: 67%;"><h3 id="1-3-静态定位-static（了解）"><a href="#1-3-静态定位-static（了解）" class="headerlink" title="1.3 静态定位 static（了解）"></a>1.3 静态定位 static（了解）</h3><img src="image-20210729233622998.png" alt="image-20210729233622998" style="zoom:67%;"><h3 id="1-4-相对定位-relative（重要）"><a href="#1-4-相对定位-relative（重要）" class="headerlink" title="1.4 相对定位 relative（重要）"></a>1.4 相对定位 relative（重要）</h3><img src="image-20210729233637499.png" alt="image-20210729233637499" style="zoom:67%;"><h3 id="1-5-绝对定位-absolute（重要）"><a href="#1-5-绝对定位-absolute（重要）" class="headerlink" title="1.5 绝对定位 absolute（重要）"></a>1.5 绝对定位 absolute（重要）</h3><img src="image-20210729233703677.png" alt="image-20210729233703677" style="zoom:67%;"><h3 id="1-6-子绝父相的由来"><a href="#1-6-子绝父相的由来" class="headerlink" title="1.6 子绝父相的由来"></a>1.6 子绝父相的由来</h3><img src="image-20210729233736427.png" alt="image-20210729233736427" style="zoom:67%;"><h3 id="1-7-固定定位-fixed-（重要）"><a href="#1-7-固定定位-fixed-（重要）" class="headerlink" title="1.7 固定定位 fixed （重要）"></a>1.7 固定定位 fixed （重要）</h3><img src="image-20210729233801202.png" alt="image-20210729233801202" style="zoom:67%;"><img src="image-20210729233811218.png" alt="image-20210729233811218" style="zoom:67%;"><h3 id="1-8-粘性定位-sticky（了解）"><a href="#1-8-粘性定位-sticky（了解）" class="headerlink" title="1.8 粘性定位 sticky（了解）"></a>1.8 粘性定位 sticky（了解）</h3><img src="image-20210729233822508.png" alt="image-20210729233822508" style="zoom:67%;"><h3 id="1-9-定位的总结"><a href="#1-9-定位的总结" class="headerlink" title="1.9 定位的总结"></a>1.9 定位的总结</h3><img src="image-20210729233846329.png" alt="image-20210729233846329" style="zoom:67%;"><h3 id="1-10-定位叠放次序-z-index"><a href="#1-10-定位叠放次序-z-index" class="headerlink" title="1.10 定位叠放次序 z-index"></a>1.10 定位叠放次序 z-index</h3><img src="image-20210729233924197.png" alt="image-20210729233924197" style="zoom: 67%;"><h3 id="1-11-定位的拓展"><a href="#1-11-定位的拓展" class="headerlink" title="1.11 定位的拓展"></a>1.11 定位的拓展</h3><img src="image-20210729233955233.png" alt="image-20210729233955233" style="zoom:67%;"><img src="image-20210729234007050.png" alt="image-20210729234007050" style="zoom:67%;"><img src="image-20210729234029204.png" alt="image-20210729234029204" style="zoom: 67%;"><img src="image-20210729234213271.png" alt="image-20210729234213271" style="zoom:67%;"><h2 id="2-网页布局总结"><a href="#2-网页布局总结" class="headerlink" title="2 网页布局总结"></a>2 网页布局总结</h2><img src="image-20210729234240106.png" alt="image-20210729234240106" style="zoom:67%;"><h2 id="3-元素的显示与隐藏"><a href="#3-元素的显示与隐藏" class="headerlink" title="3 元素的显示与隐藏"></a>3 元素的显示与隐藏</h2><img src="image-20210729234321556.png" alt="image-20210729234321556" style="zoom:67%;"><h3 id="3-1-display-属性"><a href="#3-1-display-属性" class="headerlink" title="3.1 display 属性"></a>3.1 display 属性</h3><img src="image-20210729234350926.png" alt="image-20210729234350926" style="zoom:67%;"><h3 id="3-2-visibility-可见性"><a href="#3-2-visibility-可见性" class="headerlink" title="3.2 visibility 可见性"></a>3.2 visibility 可见性</h3><img src="image-20210729234408680.png" alt="image-20210729234408680" style="zoom:67%;"><h3 id="3-3-overflow-溢出"><a href="#3-3-overflow-溢出" class="headerlink" title="3.3 overflow 溢出"></a>3.3 overflow 溢出</h3><img src="image-20210729234427342.png" alt="image-20210729234427342" style="zoom:67%;"><h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><img src="image-20210729234504721.png" alt="image-20210729234504721" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奖牌榜微信小程序</title>
      <link href="/2021/07/28/jiang-pai-bang-wei-xin-xiao-cheng-xu/"/>
      <url>/2021/07/28/jiang-pai-bang-wei-xin-xiao-cheng-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="奖牌榜微信小程序"><a href="#奖牌榜微信小程序" class="headerlink" title="奖牌榜微信小程序"></a>奖牌榜微信小程序</h1><p>该小程序实现奥运会奖牌榜的动态显示和其他页面的静态显示。奥运会期间累计超1400人数和4700人次访问。</p><img src="gh_fb62dfa5e95e_258.jpg" style="zoom: 67%;"><img src="demo.gif" alt="demo.gif" style="zoom: 25%;">]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础总结 5/7</title>
      <link href="/2021/07/23/css-5-7/"/>
      <url>/2021/07/23/css-5-7/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础总结-5-7"><a href="#CSS-基础总结-5-7" class="headerlink" title="CSS 基础总结 5/7"></a>CSS 基础总结 5/7</h1><h2 id="1-学成在线案例"><a href="#1-学成在线案例" class="headerlink" title="1 学成在线案例"></a>1 学成在线案例</h2><h3 id="1-0-结果展示"><a href="#1-0-结果展示" class="headerlink" title="1.0 结果展示"></a>1.0 结果展示</h3><p><img src="image-20210723181305580.png"></p><h3 id="1-1-准备素材和工具"><a href="#1-1-准备素材和工具" class="headerlink" title="1.1 准备素材和工具"></a>1.1 准备素材和工具</h3><ol><li>学成在线 PSD 源文件。 </li><li>开发工具 = PS（切图）/ cutterman 插件 + vscode（代码） + chrome（测试）。</li></ol><h3 id="1-2-案例准备工作"><a href="#1-2-案例准备工作" class="headerlink" title="1.2 案例准备工作"></a>1.2 案例准备工作</h3><p>我们本次采取结构与样式相分离思想：</p><ol><li>创建 study 目录文件夹 (用于存放我们这个页面的相关内容)。 </li><li>用vscode打开study目录文件夹</li><li>study 目录内新建 images 文件夹，用于保存图片。</li><li>新建首页文件 index.html（以后我们的网站首页统一规定为 index.html )。</li><li>新建 style.css 样式文件。我们本次采用外链样式表。</li><li>将样式引入到我们的 HTML 页面文件中。</li><li>样式表写入清除内外边距的样式，来检测样式表是否引入成功。</li></ol><h3 id="1-3-CSS-属性书写顺序-重点"><a href="#1-3-CSS-属性书写顺序-重点" class="headerlink" title="1.3 CSS 属性书写顺序(重点)"></a>1.3 CSS 属性书写顺序(重点)</h3><p>建议遵循以下顺序：</p><ol><li><strong>布局定位属性</strong>：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）</li><li><strong>自身属性</strong>：width / height / margin / padding / border / background </li><li><strong>文本属性</strong>：color / font / text-decoration / text-align / vertical-align / white- space / break-word </li><li><strong>其他属性（CSS3）</strong>：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …</li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-none"><code class="language-none">.jdc { display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif; color: #333; background: rgba(0,0,0,.5); border-radius: 10px;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-页面布局整体思路"><a href="#1-4-页面布局整体思路" class="headerlink" title="1.4 页面布局整体思路"></a>1.4 页面布局整体思路</h3><p>为了提高网页制作的效率，布局时通常有以下的整体思路： </p><ol><li>必须确定页面的版心（可视区），我们测量可得知。 </li><li>分析页面中的行模块，以及每个行模块中的列模块。即页面布局第一准则。</li><li>一行中的列模块经常浮动布局，先确定每个列的大小，之后确定列的位置。即页面布局第二准则。 </li><li>制作 HTML 结构。我们还是遵循，先有结构，后有样式的原则。结构永远最重要。</li></ol><h3 id="1-5-确定版心"><a href="#1-5-确定版心" class="headerlink" title="1.5 确定版心"></a>1.5 确定版心</h3><p>这个页面的版心是 1200 像素，每个版心都要水平居中对齐，可以定义版心为公共类：</p><pre class="line-numbers language-none"><code class="language-none">.w { width: 1200px; margin: auto;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-6-头部制作"><a href="#1-6-头部制作" class="headerlink" title="1.6 头部制作"></a>1.6 头部制作</h3><p><img src="image-20210723180516664.png" alt="image-20210723180516664"></p><ul><li>1 号是版心盒子 header 1200 * 42 的盒子水平居中对齐，上下给一个 margin 值就可以</li><li>版心盒子里面包含 2 号盒子 logo </li><li>版心盒子里面包含 3 号盒子 nav 导航栏 </li><li>版心盒子里面包含 4 号盒子 search 搜索框</li><li>版心盒子里面包含 5 号盒子 user 个人信息 </li><li>注意：要求里面的 4 个盒子必须都是浮动</li></ul><p>导航栏注意点：</p><p>实际开发中，我们不会直接用链接a 而是用 li 包含链接(li+a)的做法。 </p><ol><li>li+a 语义更清晰，一看这就是有条理的列表型内容。 </li><li>如果直接用a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎有降权的风险）， 从而影响网站排名 </li></ol><p>注意:  </p><ol><li>让导航栏一行显示, 给 li 加浮动, 因为 li 是块级元素, 需要一行显示.</li><li>这个nav导航栏可以不给宽度,将来可以继续添加其余文字 </li><li>因为导航栏里面文字不一样多,所以最好给链接 a 左右padding 撑开盒子,而不是指定宽度</li></ol><img src="image-20210723180650653.png" alt="image-20210723180650653" style="zoom: 67%;"><h3 id="1-7-banner-制作"><a href="#1-7-banner-制作" class="headerlink" title="1.7 banner 制作"></a>1.7 banner 制作</h3><img src="image-20210723180719138.png" alt="image-20210723180719138" style="zoom: 67%;"><ul><li>1 号盒子是通栏的大盒子 banner，不给宽度，给高度，给一个蓝色背景 </li><li>2 号盒子是版心，要水平居中对齐 </li><li>3 号盒子版心内，左对齐 subnav 侧导航栏 </li><li>4 号盒子版心内，右对齐 course 课程</li></ul><h3 id="1-8-精品推荐小模块"><a href="#1-8-精品推荐小模块" class="headerlink" title="1.8 精品推荐小模块"></a>1.8 精品推荐小模块</h3><img src="image-20210723181001430.png" alt="image-20210723181001430" style="zoom:67%;"><h3 id="1-9-精品推荐大模块"><a href="#1-9-精品推荐大模块" class="headerlink" title="1.9 精品推荐大模块"></a>1.9 精品推荐大模块</h3><img src="image-20210723180853694.png" alt="image-20210723180853694" style="zoom:67%;"><img src="image-20210723180903393.png" alt="image-20210723180903393" style="zoom:67%;"><h3 id="1-10-底部模块"><a href="#1-10-底部模块" class="headerlink" title="1.10 底部模块"></a>1.10 底部模块</h3><img src="image-20210723180914636.png" alt="image-20210723180914636" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础总结 4/7</title>
      <link href="/2021/07/22/css-4-7/"/>
      <url>/2021/07/22/css-4-7/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础总结-4-7"><a href="#CSS-基础总结-4-7" class="headerlink" title="CSS 基础总结 4/7"></a>CSS 基础总结 4/7</h1><h2 id="1-浮动"><a href="#1-浮动" class="headerlink" title="1 浮动"></a>1 浮动</h2><h3 id="1-1-传统网页布局的三种方式"><a href="#1-1-传统网页布局的三种方式" class="headerlink" title="1.1 传统网页布局的三种方式"></a>1.1 传统网页布局的三种方式</h3><p>CSS 提供了三种传统布局方式（简单说，就是盒子如何进行排列顺序）：</p><ul><li>普通流（标准流）</li><li>浮动 </li><li>定位</li></ul><h3 id="1-2-标准流（普通流-文档流）"><a href="#1-2-标准流（普通流-文档流）" class="headerlink" title="1.2 标准流（普通流/文档流）"></a>1.2 标准流（普通流/文档流）</h3><p>所谓的标准流: 就是标签按照规定好默认方式排列。</p><ol><li><p>块级元素会独占一行，从上向下顺序排列。</p><p>常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table</p></li><li><p>行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。 </p><p>常用元素：span、a、i、em 等 </p></li></ol><p>以上都是标准流布局，标准流是最基本的布局方式。 </p><p>这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了。</p><p>注意：实际开发中，一个页面基本都包含了这三种布局方式（后面移动端学习新的布局方式） 。</p><h3 id="1-3-为什么需要浮动？"><a href="#1-3-为什么需要浮动？" class="headerlink" title="1.3 为什么需要浮动？"></a>1.3 为什么需要浮动？</h3><p>有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。 因为浮动可以改变元素标签默认的排列方式。</p><p>浮动最典型的应用：可以让多个块级元素一行内排列显示。</p><p>网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。</p><h3 id="1-4-什么是浮动？"><a href="#1-4-什么是浮动？" class="headerlink" title="1.4 什么是浮动？"></a>1.4 什么是浮动？</h3><p>float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。 </p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">选择器 { float: 属性值; }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20210722161806165.png" alt="image-20210722161806165"></p><h3 id="1-5-浮动特性（重难点）"><a href="#1-5-浮动特性（重难点）" class="headerlink" title="1.5 浮动特性（重难点）"></a>1.5 浮动特性（重难点）</h3><ol><li>浮动元素会脱离标准流(脱标) </li><li>浮动的元素会一行内显示并且元素顶部对齐，不再保留原先的位置</li></ol><img src="image-20210722162037219.png" alt="image-20210722162037219" style="zoom: 80%;"><p><strong>注意：</strong> 浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子， 多出的盒子 会另起一行对齐。</p><ol start="3"><li>浮动的元素会具有行内块元素的特性</li></ol><p>任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有行内块元素相似的特性。 </p><ol><li>如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定 </li><li>浮动的盒子中间是没有缝隙的，是紧挨着一起的 </li><li>行内元素同理</li></ol><h3 id="1-6-浮动元素经常和标准流父级搭配使用"><a href="#1-6-浮动元素经常和标准流父级搭配使用" class="headerlink" title="1.6 浮动元素经常和标准流父级搭配使用"></a>1.6 浮动元素经常和标准流父级搭配使用</h3><p>为了约束浮动元素位置, 我们网页布局一般采取的策略是: </p><p><strong>先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置. 符合网页布局第一准侧。</strong></p><img src="image-20210722162441275.png" alt="image-20210722162441275" style="zoom: 50%;"><h2 id="2-常见网页布局"><a href="#2-常见网页布局" class="headerlink" title="2 常见网页布局"></a>2 常见网页布局</h2><h3 id="2-1-常见网页布局"><a href="#2-1-常见网页布局" class="headerlink" title="2.1 常见网页布局"></a>2.1 常见网页布局</h3><img src="image-20210722162619700.png" alt="image-20210722162619700" style="zoom: 67%;"><img src="image-20210722162642358.png" alt="image-20210722162642358" style="zoom:67%;"><h3 id="2-2-浮动布局注意点"><a href="#2-2-浮动布局注意点" class="headerlink" title="2.2 浮动布局注意点"></a>2.2 浮动布局注意点</h3><ol><li><p>浮动和标准流的父盒子搭配</p><p>先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置</p></li><li><p>一个元素浮动了，理论上其余的兄弟元素也要浮动</p><p>一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动，以防止引起问题。 </p><p>浮动的盒子只会影响浮动盒子后面的标准流,不会影响前面的标准流。</p></li></ol><h2 id="3-清除浮动"><a href="#3-清除浮动" class="headerlink" title="3 清除浮动"></a>3 清除浮动</h2><h3 id="3-1-为什么需要清除浮动？"><a href="#3-1-为什么需要清除浮动？" class="headerlink" title="3.1 为什么需要清除浮动？"></a>3.1 为什么需要清除浮动？</h3><p>由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子。</p><img src="image-20210722163018664.png" alt="image-20210722163018664" style="zoom: 67%;"><p>由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响。</p><h3 id="3-2-清除浮动本质"><a href="#3-2-清除浮动本质" class="headerlink" title="3.2 清除浮动本质"></a>3.2 清除浮动本质</h3><ul><li>清除浮动的本质是清除浮动元素造成的影响 </li><li>如果父盒子本身有高度，则不需要清除浮动 </li><li><strong>清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</strong></li></ul><h3 id="3-3-清除浮动的方法"><a href="#3-3-清除浮动的方法" class="headerlink" title="3.3 清除浮动的方法"></a>3.3 清除浮动的方法</h3><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">选择器{clear:属性值;} <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20210722163237967.png" alt="image-20210722163237967"></p><p>我们实际工作中， 几乎只用 <strong>clear: both</strong>; </p><p><strong>清除浮动的策略是：闭合浮动</strong>，只让浮动在父盒子内部影响,不影响父盒子外面的其他盒子。</p><p><strong>清楚浮动的方法：</strong></p><ol><li>额外标签法，也称为隔墙法，是 W3C 推荐的做法</li><li>父级添加 overflow 属性 </li><li>父级添加after伪元素 </li><li>父级添加双伪元素</li></ol><h4 id="3-3-1-额外标签法"><a href="#3-3-1-额外标签法" class="headerlink" title="3.3.1 额外标签法"></a>3.3.1 额外标签法</h4><p>额外标签法也称为隔墙法，是 W3C 推荐的做法。 </p><p>额外标签法会在浮动元素末尾添加一个空的标签。例如 <code>&lt;div style=" clear:both”&gt;&lt;/div&gt;</code> ，或者其他标签 （如 <code>&lt;br/&gt;</code> 等）。 </p><ul><li>优点： 通俗易懂，书写方便 </li><li>缺点： 添加许多无意义的标签，结构化较差 </li></ul><p>注意： 要求这个新的空标签必须是块级元素。</p><p>该方法不常用。</p><h4 id="3-3-2-父级添加-overflow"><a href="#3-3-2-父级添加-overflow" class="headerlink" title="3.3.2 父级添加 overflow"></a>3.3.2 父级添加 overflow</h4><p>可以给<strong>父级</strong>添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll 。 </p><ul><li>优点：代码简洁 </li><li>缺点：无法显示溢出的部分</li></ul><h4 id="3-3-3-after-伪元素法"><a href="#3-3-3-after-伪元素法" class="headerlink" title="3.3.3 :after 伪元素法"></a>3.3.3 :after 伪元素法</h4><p>:after 方式是额外标签法的升级版。也是给父元素添加：</p><pre class="line-numbers language-none"><code class="language-none">.clearfix:after {  content: "";  display: block;  height: 0;  clear: both;  visibility: hidden; } .clearfix { /* IE6、7 专有 */  *zoom: 1;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>优点：没有增加标签，结构更简单 </li><li>缺点：要去照顾低版本浏览器 </li><li>代表网站： 百度、淘宝网、网易等</li></ul><h4 id="3-3-4-双伪元素清除浮动"><a href="#3-3-4-双伪元素清除浮动" class="headerlink" title="3.3.4 双伪元素清除浮动"></a>3.3.4 双伪元素清除浮动</h4><p>也是给父元素添加：</p><pre class="line-numbers language-none"><code class="language-none">.clearfix:before,.clearfix:after { content:""; display:table; }.clearfix:after { clear:both;}.clearfix { *zoom:1;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>优点：代码更简洁 </li><li>缺点：要去照顾低版本浏览器 </li><li>代表网站：小米、腾讯等</li></ul><h3 id="3-4-清除浮动总结"><a href="#3-4-清除浮动总结" class="headerlink" title="3.4 清除浮动总结"></a>3.4 清除浮动总结</h3><p>为什么需要清除浮动？</p><ol><li>父级没高度。 </li><li>子盒子浮动了。 </li><li>影响下面布局了。</li></ol><p><img src="image-20210722164105476.png" alt="image-20210722164105476"></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础归纳</title>
      <link href="/2021/07/21/suan-fa-ji-chu-gui-na/"/>
      <url>/2021/07/21/suan-fa-ji-chu-gui-na/</url>
      
        <content type="html"><![CDATA[<h1 id="算法设计与分析基础"><a href="#算法设计与分析基础" class="headerlink" title="算法设计与分析基础"></a>算法设计与分析基础</h1><h2 id="1-算法基础"><a href="#1-算法基础" class="headerlink" title="1. 算法基础"></a>1. 算法基础</h2><h3 id="1-1-渐进复杂度分析"><a href="#1-1-渐进复杂度分析" class="headerlink" title="1.1 渐进复杂度分析"></a>1.1 渐进复杂度分析</h3><h4 id="1-1-1-概述"><a href="#1-1-1-概述" class="headerlink" title="1.1.1 概述"></a>1.1.1 概述</h4><p>时间复杂度，空间复杂度  只考虑最高阶</p><h4 id="1-1-2-渐进复杂度分析"><a href="#1-1-2-渐进复杂度分析" class="headerlink" title="1.1.2 渐进复杂度分析"></a>1.1.2 渐进复杂度分析</h4><ol><li><p>大O，渐进上界记号，上界越低越准确，越有意义</p><p>如果存在两个正的常数c和n0，对于任意n≥n0，都有f(n)≤c×g(n)，则记为f(n)=O(g(n)),即g(n)为f(n)的上界。</p></li><li><p>大Ω，渐进下界记号</p></li><li><p>大Θ，渐进紧界记号</p></li></ol><p>重要结论：</p><ol><li><p>如果T1(n)=O(f(n))，T2(n)=O(g(n)),那么</p><ol><li><p>T1(n)+T2(n)= O(f(n)+g(n)) </p></li><li><p>T1(n)*T2(n)= O(f(n)*g(n)) </p></li></ol></li><li><p>对任意常数k，(logn)^k ≤ O(n)。</p></li></ol><p>(说明n的增长要快于log2n的任意次幂)</p><p>O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n2)&lt;O(n3)O(2^n)&lt;O(n!)&lt;O(n^n)</p><h4 id="1-1-3-算法的最好、最坏和平均情况"><a href="#1-1-3-算法的最好、最坏和平均情况" class="headerlink" title="1.1.3 算法的最好、最坏和平均情况"></a>1.1.3 算法的最好、最坏和平均情况</h4><p>通常算最坏情况，因为一般平均情况就是最坏情况</p><h4 id="1-1-4-时间复杂度分析的一般步骤"><a href="#1-1-4-时间复杂度分析的一般步骤" class="headerlink" title="1.1.4 时间复杂度分析的一般步骤"></a>1.1.4 时间复杂度分析的一般步骤</h4><h4 id="1-1-5-渐进空间复杂度分析"><a href="#1-1-5-渐进空间复杂度分析" class="headerlink" title="1.1.5 渐进空间复杂度分析"></a>1.1.5 渐进空间复杂度分析</h4><p>只考察临时变量所占空间，S(n)=O(g(n))、Ω(g(n))或Θ(g(n))</p><p>不考虑形参的空间，因为调用该算法的时候计算过一次</p><h3 id="1-2-递归方程及其求解方法"><a href="#1-2-递归方程及其求解方法" class="headerlink" title="1.2 递归方程及其求解方法"></a>1.2 递归方程及其求解方法</h3><ol><li><p>递归算法复杂度分析<br> 建立方程、求解方程、用渐进符号表示函数的阶</p></li><li><p>建立递归方程</p></li><li><p>求解递归方程</p><ol><li><p>代入法</p></li><li><p>递归树法</p></li><li><p>迭代法</p><p>从初始递归方程开始，反复用递归方程右边的等式代入左边的函数，直到得到初值。</p></li><li><p>主方法</p><p>T(n)=aT(n/b)+f(n)</p><img src="image-20210721063927567.png" alt="image-20210721063927567" style="zoom: 50%;"><p>不相等时，f(n)比n^log(b⁡)a大或小n^ε倍，否则主方法不成立，例如：logn&lt;n^ε</p></li></ol></li></ol><h2 id="2-分治法"><a href="#2-分治法" class="headerlink" title="2 分治法"></a>2 分治法</h2><h3 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h3><h4 id="2-1-1条件"><a href="#2-1-1条件" class="headerlink" title="2.1.1条件"></a>2.1.1条件</h4><ol><li><p>原问题与子问题形式相</p></li><li><p>不含公共子问题</p></li><li><p>子问题足够小的时候很容易求解</p></li></ol><h4 id="2-1-2步骤"><a href="#2-1-2步骤" class="headerlink" title="2.1.2步骤"></a>2.1.2步骤</h4><ol><li><p>划分：较小，相互独立的子问题</p></li><li><p>求解：容易求解则求解，不容易则递归</p></li><li><p>合并：子问题的解合并为原问题的解<br>k个子问题   k=1,减治法    k=2,二分法</p></li></ol><h4 id="2-1-3-求O-n"><a href="#2-1-3-求O-n" class="headerlink" title="2.1.3 求O(n)"></a>2.1.3 求O(n)</h4><p>主方法</p><h3 id="2-2-排序问题"><a href="#2-2-排序问题" class="headerlink" title="2.2 排序问题"></a>2.2 排序问题</h3><h4 id="2-2-1-快速排序-二分法"><a href="#2-2-1-快速排序-二分法" class="headerlink" title="2.2.1 快速排序  二分法"></a>2.2.1 快速排序  二分法</h4><p>平均(最好)时间复杂度: T(n) = O(nlogn)</p><p>最坏时间复杂度: T(n) = O(n2)</p><p>平均(最好)空间复杂度：O(logn)</p><p>最坏情况下空间复杂度：O(n)</p><h4 id="2-2-2-归并排序-二分法"><a href="#2-2-2-归并排序-二分法" class="headerlink" title="2.2.2 归并排序  二分法"></a>2.2.2 归并排序  二分法</h4><p>自底向上    T(n)=O(nlogn)</p><p>自顶向下    T(n)=O(nlogn)   S(n)=O(n)</p><h3 id="2-3-查找问题"><a href="#2-3-查找问题" class="headerlink" title="2.3 查找问题"></a>2.3 查找问题</h3><h4 id="2-3-1-折半查找-减治法"><a href="#2-3-1-折半查找-减治法" class="headerlink" title="2.3.1 折半查找   减治法"></a>2.3.1 折半查找   减治法</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/*给定有序数组R[low,high],输出值为k的元素的下表*/#include&lt;iostream&gt;using namespace std;int binSearch(int *R,int low,int high,int k){    int mid=(low+high)/2;    if(high&lt;low)    return -1;    if(k==R[mid])   return mid;    else if(k&lt;R[mid])   return binSearch(R,low,mid-1,k);    else return binSearch(R,mid+1,high,k);}int main(){    int R[7]={0,1,2,5,7,8,9};//第0位空出    int n=6,k=5;    int result=binSearch(R,1,n,k);    cout&lt;&lt;result;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-2-查找第k小元素-减治法"><a href="#2-3-2-查找第k小元素-减治法" class="headerlink" title="2.3.2 查找第k小元素     减治法"></a>2.3.2 查找第k小元素     减治法</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/*设无序序列 T =(r1, r2, …, rn)，T 的第k（1≤k≤n）小元素定义为T按升序排列后在第k个位置上的元素。给定一个序列T和一个整数k，寻找 T 的第k小元素的问题称为选择问题。算法——选择问题输入：无序序列{R1, R2, …, Rn}，位置k输出：返回第k小的元素值1.设置初始查找区间：i=1，j=n;2.以Ri为轴值对序列Ri~Rj进行一次划分，得到轴值的位置s;3.将轴值位置s与k比较  3.1 如果k=s，则将Rs作为结果返回；  3.2 如果k&lt;s，则j=s-1，转步骤2；  3.3 如果k&gt;s, 则i=s+1，转步骤2。*/#include&lt;iostream&gt;using namespace std;int partition(int *R,int s,int t){    R[0]=R[s];    int i=s,j=t;    while(i!=j){        while(j&gt;i&amp;&amp;R[j]&gt;=R[0])   j--;        R[i]=R[j];        while(i&lt;j&amp;&amp;R[i]&lt;=R[0])   i++;        R[j]=R[i];    }    R[i]=R[0];    return i;}int quickSelect(int *R,int s,int t,int k){    int i;    if(s&lt;t){        i=partition(R,s,t);        if(i==k)    return R[i];        else if(i&lt;k)    return quickSelect(R,i+1,t,k);        else if(i&gt;k)    return quickSelect(R,s,i-1,k);    }    else if(s==t&amp;&amp;s==k)    return R[s];}int main(){    int R[13]={0,5,3,8,1,10,6,9,12,17,4,15,22};    int k=6;//答案为8    int ans=quickSelect(R,1,12,k);    cout&lt;&lt;ans;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个问题虽然说是将原问题分解成了两个子问题，但是每次递归只选择了其中的一个子问题求解，不涉及问题的合并，所以是减治法。</p><h3 id="2-4-组合问题"><a href="#2-4-组合问题" class="headerlink" title="2.4 组合问题"></a>2.4 组合问题</h3><h4 id="2-4-1-最大子段问题"><a href="#2-4-1-最大子段问题" class="headerlink" title="2.4.1 最大子段问题"></a>2.4.1 最大子段问题</h4><ol><li><p>二分法</p><p>分为左边、右边、中间一共三段，左右两边分别递归，中间部分求mid左边的最大和s1以及右边的最大和s2,再相加得s1+s2</p><p>T(n)=O(nlogn)</p></li><li><p>在线处理法  有代码</p><p>仅扫描一次，T(n)=O(n)</p></li></ol><h4 id="2-4-2-棋盘覆盖问题-几何问题-分治法-四分"><a href="#2-4-2-棋盘覆盖问题-几何问题-分治法-四分" class="headerlink" title="2.4.2 棋盘覆盖问题  几何问题 分治法(四分)"></a>2.4.2 棋盘覆盖问题  几何问题 分治法(四分)</h4><h2 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3 动态规划"></a>3 动态规划</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>解决多阶段决策问题，用一个表来记录已解决的子问题</p><h4 id="3-1-1-条件"><a href="#3-1-1-条件" class="headerlink" title="3.1.1 条件"></a>3.1.1 条件</h4><ol><li><p>最优子结构，最优解包含的子问题的解也是最优的(反证法证明)</p></li><li><p>有重叠子问题</p></li><li><p>无后效性，某一状态一旦确定，不受以后决策的影响</p></li></ol><h4 id="3-1-2-步骤"><a href="#3-1-2-步骤" class="headerlink" title="3.1.2 步骤"></a>3.1.2 步骤</h4><ol><li><p>划分子问题</p></li><li><p>确定动态规划函数</p></li><li><p>填表，自底向上的计算最优解dp并保存，同时记录path信息</p></li><li><p>构造最优解，通过path信息回溯到得到最优解的过程</p></li></ol><h4 id="3-1-3-求O-n"><a href="#3-1-3-求O-n" class="headerlink" title="3.1.3 求O(n)"></a>3.1.3 求O(n)</h4><p>一般是看算法程序里有几层循环，有t层的话T(n)=O(n^t)</p><p>备忘录法的时间复杂度与一般动态规划相等，因为备忘录的最坏情况相当于一般动态规划</p><h3 id="3-2-求解树塔问题（三角形最长路径）"><a href="#3-2-求解树塔问题（三角形最长路径）" class="headerlink" title="3.2 求解树塔问题（三角形最长路径）"></a>3.2 求解树塔问题（三角形最长路径）</h3><ol><li><p>递归法 重复计算效率低</p></li><li><p>备忘录方法（自顶向下）</p><p>求解出的结果放在 dp 中，相同问题只计算一次，是一般动态规划方法的变形</p><p>代码就是在一般的递归法中加入一个查表的动作，查到以后直接输出结果，不需要重复计算；当需要计算的时候，要将结果返回之前保存到dp数组中</p></li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int a[6][6] = {0, 0, 0, 0, 0, 0,               0, 8, 0, 0, 0, 0,               0, 12, 15, 0, 0, 0,               0, 3, 9, 6, 0, 0,               0, 8, 10, 5, 12, 0,               0, 16, 4, 18, 10, 9};int m[6][6];int n = 5;int maxSum(int i, int j){    if (m[i][j] != -1)        return m[i][j];    if (i == n)        m[i][j] = a[i][j];    else    {        int x = maxSum(i + 1, j);        int y = maxSum(i + 1, j + 1);        m[i][j] = max(x, y) + a[i][j];    }    return m[i][j];}int main(){    memset(m, -1, sizeof(m));    cout &lt;&lt; maxSum(1, 1) &lt;&lt; endl;} //answer=60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>动态规划（自底向上）</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int a[6][6] = {0, 0, 0, 0, 0, 0,               0, 8, 0, 0, 0, 0,               0, 12, 15, 0, 0, 0,               0, 3, 9, 6, 0, 0,               0, 8, 10, 5, 12, 0,               0, 16, 4, 18, 10, 9};int n = 5;int maxSum(){    int i, j;    for (i = n - 1; i &gt;= 1; i--)    {        for (j = 1; j &lt;= i; j++)        {            a[i][j] = max(a[i + 1][j], a[i + 1][j + 1]) + a[i][j];        }    }    return a[1][1];}int main(){    cout &lt;&lt; maxSum() &lt;&lt; endl;} //answer=60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-最长递增子序列问题"><a href="#3-3-最长递增子序列问题" class="headerlink" title="3.3 最长递增子序列问题"></a>3.3 最长递增子序列问题</h3><p>动态规划</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define MAX 30//问题表示int a[] = {-1, 2, 1, 5, 3, 6, 4, 8, 9, 7}; //第0位空出int n = sizeof(a) / sizeof(a[0]);//求解结果表示int dp[MAX];void solve(){    dp[1] = 1;    for (int i = 2; i &lt;= n; i++)    {        dp[1] = 1;        for (int k = 1; k &lt; i; k++)        {            if (a[k] &lt; a[i] &amp;&amp; dp[i] &lt; dp[k] + 1)            {                dp[i] = dp[k] + 1;            }        }    }}int main(){    solve();    cout &lt;&lt; dp[n] &lt;&lt; endl;    return 0;} //answer=4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-最长公共子序列问题"><a href="#3-4-最长公共子序列问题" class="headerlink" title="3.4 最长公共子序列问题"></a>3.4 最长公共子序列问题</h3><p>动态规划</p><ol><li>通过 dp 求最优解 </li><li>通过 vector 回溯求最优解</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//类似0-1背包问题#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;//可以用vector向量回溯路径，本方法没有用到#include &lt;cstring&gt;using namespace std;#define MAX 51 //序列中最多的字符个数//问题表示string x = "abcbdb", y = "acbbabdbb"; //两个待求解序列int dp[MAX][MAX];                     //动态规划数组vector&lt;char&gt; subs;                    //存放LCSint trace[MAX];void LCSlength(){    //边界条件在初始化中已完成    for (int i = 1; i &lt;= x.length(); i++)    {        for (int j = 1; j &lt;= y.length(); j++)        {            //最后一个字符相等            if (x[i - 1] == y[j - 1])                dp[i][j] = dp[i - 1][j - 1] + 1;            //最后一个字符不相等            else                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);        }    }}void traceBack(){    int i = x.length(), j = y.length();    while (i != 0 &amp;&amp; j != 0)    {        //最后一个字符相等只有一种情况，        //就是dp[i-1][j-1]=dp[i][j]且dp[i][j]!=dp[i][j-1]且dp[i][j]!=dp[i-1][j]        if (dp[i][j] == dp[i][j - 1])        {            j = j - 1;            trace[i] = 0;        }        //这里要注意，因为先往左边找，再往上边找，所求的相同字符就在x字符串中        //如果先往上面找，则结论相反        else if (dp[i][j] == dp[i - 1][j])        {            i = i - 1;            trace[i] = 0;        }        else        {            trace[i] = 1;            i = i - 1;            j = j - 1;        }    }    for(int i=1;i&lt;=x.length();i++){        if (trace[i] != 0)        {            cout &lt;&lt; x[i-1] &lt;&lt; " ";        }    }}int main(){    memset(dp, 0, sizeof(dp));    memset(trace, 0, sizeof(trace));    LCSlength();    cout &lt;&lt; dp[x.length()][y.length()]&lt;&lt;endl;    traceBack();    } //answer=5,abbdb或acbdb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-0-1背包问题"><a href="#3-5-0-1背包问题" class="headerlink" title="3.5 0/1背包问题"></a>3.5 0/1背包问题</h3><p>动态规划</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 30//问题表示int n = 5, C = 10;                //5种物品,限制重量不超过10int w[MAXN] = {0, 2, 2, 6, 5, 4}; //下标0不用int v[MAXN] = {0, 6, 3, 5, 4, 6}; //下标0不用//求解结果表示int dp[MAXN][MAXN]; //i,rint x[MAXN];        //存放最优解int maxv;           //存放最优解的总价值void knapSack(){    //边界条件已在初始化中完成    for (int i = 1; i &lt;= n; i++)    { //第i件        for (int j = 1; j &lt;= C; j++)        { //剩余价值            //放不下            if (j &lt; w[i])            {                dp[i][j] = dp[i - 1][j];            }            //放得下的情况下，放还是不放？            else            {                dp[i][j] = max(dp[i - 1][j - w[i]] + v[i], dp[i - 1][j]);            }        }    }}void traceBack() //回推找到最优解{    int i = n, j = C; //从最后一个开始找    while (i != 0)    {        //前一个没放入        if (dp[i][j] == dp[i - 1][j])        {            x[i] = 0;        }        //放入了        else        {            x[i] = 1;            j = j - w[i];        }        i--; //回到上一层    }}int main(){    memset(dp, 0, sizeof(dp));    memset(x,0,sizeof(x));    knapSack();    maxv = dp[n][C];    cout &lt;&lt; maxv &lt;&lt; endl;    traceBack();    for(int i=1;i&lt;=n;i++){        if(x[i]==1){            cout&lt;&lt;i&lt;&lt;" ";        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-最优连乘矩阵问题"><a href="#3-6-最优连乘矩阵问题" class="headerlink" title="3.6 最优连乘矩阵问题"></a>3.6 最优连乘矩阵问题</h3><ol><li><p>动态规划</p></li><li><p>备忘录</p></li></ol><h3 id="3-7-TSP问题（旅行商问题）"><a href="#3-7-TSP问题（旅行商问题）" class="headerlink" title="3.7 TSP问题（旅行商问题）"></a>3.7 TSP问题（旅行商问题）</h3><p>动态规划</p><h2 id="4-贪心算法"><a href="#4-贪心算法" class="headerlink" title="4 贪心算法"></a>4 贪心算法</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>通常获得近似最优解</p><h4 id="4-1-1-条件"><a href="#4-1-1-条件" class="headerlink" title="4.1.1 条件"></a>4.1.1 条件</h4><ol><li><p>最优子结构</p></li><li><p>贪心选择性质：全局最优解可以通过一系列局部最优解得到</p><p>证明：数学归纳法</p><ol><li><p>问题的最优解可以修改为以贪心选择开始</p></li><li><p>贪心选择之后，原问题简化为一个更小的类似子问题</p></li><li><p>数学归纳法证明：通过每一步贪心选择，最终可获得以一个整体最优解</p></li></ol></li></ol><h4 id="4-1-2-步骤"><a href="#4-1-2-步骤" class="headerlink" title="4.1.2 步骤"></a>4.1.2 步骤</h4><p>1.分解</p><p>分解为若干个决策阶段，得到若干个决策子问题</p><p>2.决策</p><p>得到每个阶段的局部最优解，并缩小待求解问题的规模</p><p>3.合并</p><p>将各个阶段的局部最优解合并为全局最优解</p><p>0.有关概念</p><p>候选集和</p><p>解集合</p><p>选择函数：运用贪心策略指出哪个对象最有希望构成最优解</p><p>可行函数：判断加入新对象时是否可行</p><p>解决函数：判断是否构成完整解</p><h4 id="4-1-3（重点）与动态规划法比较"><a href="#4-1-3（重点）与动态规划法比较" class="headerlink" title="4.1.3（重点）与动态规划法比较"></a>4.1.3（重点）与动态规划法比较</h4><ol><li><p>相同点：都具有最优子结构性质</p></li><li><p>不同点：</p><ol><li><p>求解思路</p><p>动态规划：自底向上求解，求解过程依赖于子问题的解，在求出子问题之后再做出选择</p><p>贪心算法：自顶向下求解，求解过程不依赖于子问题的解，仅在当前状态下做出最好的选择，即局部最优选择</p></li><li><p>适用问题</p><p>动态规划：重叠子问题</p><p>贪心算法：贪心选择性质</p></li></ol></li></ol><h3 id="4-2-图着色问题"><a href="#4-2-图着色问题" class="headerlink" title="4.2 图着色问题"></a>4.2 图着色问题</h3><h3 id="4-3-TSP问题"><a href="#4-3-TSP问题" class="headerlink" title="4.3 TSP问题"></a>4.3 TSP问题</h3><h3 id="4-4-部分背包问题"><a href="#4-4-部分背包问题" class="headerlink" title="4.4 部分背包问题"></a>4.4 部分背包问题</h3><p>贪心算法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 6//问题表示int n = 5;double C = 100; //限重struct NodeType{    double w;    double v;    double p; //p=v/w    bool operator&lt;(const NodeType &amp;s) const    {        return p &gt; s.p; //按p递减排序    }};NodeType P[] = {{0}, {10, 20}, {20, 30}, {30, 66}, {40, 40}, {50, 60}}; //下标0不用//求解结果表示double V; //最大价值double x[MAXN];void Knap() //求解背包问题并返回总价值{    V = 0;                   //V初始化为0    double r = C;            //背包中能装入的余下重量    memset(x, 0, sizeof(x)); //初始化x向量    int i = 1;    while (P[i].w &lt; r) //物品i能够全部装入时循环    {        x[i] = 1;    //装入物品i        r -= P[i].w; //减少背包中能装入的余下重量        V += P[i].v; //累计总价值        i++;         //继续循环    }    if (r &gt; 0) //当余下重量大于0    {        x[i] = r / P[i].w;  //将物品i的一部分装入        V += x[i] * P[i].v; //累计总价值    }}int main(){    for (int i = 1; i &lt;= n; i++) //求v/w        P[i].p = P[i].v / P[i].w;    sort(P + 1, P + n + 1); //A[1..n]排序    Knap();    for (int j = 1; j &lt;= n; j++)        printf("%.2f, ", x[j]);    printf("Total Value=%.2f\n", V);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-5-活动安排问题"><a href="#4-5-活动安排问题" class="headerlink" title="4.5 活动安排问题"></a>4.5 活动安排问题</h3><p>贪心算法</p><p>贪心策略：剩余时间最大化，即按最早结束时间选择</p><p>证明：</p><ol><li><p>贪心选择性质：若1不是第一个选中的活动，而k是，可以证明e1≤ek的，所以一定存在一个以1开始的最优解</p></li><li><p>最优子结构：反证法，当一个问题的子解X-{1}=X’不是子问题的最优解，而Y’是最优解，则可以证明{1}+Y’是问题的最优解，这与前提相矛盾</p></li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;//问题表示struct Action //活动的类型声明{    int i;                                //活动标号    int b;                                //活动起始时间    int e;                                //活动结束时间    bool operator&lt;(const Action &amp;s) const //重载&lt;关系函数    {        return e &lt;= s.e; //用于按活动结束时间递增排序    }};int n = 11; //活动数int totalTime = 15;int order[12];Action a[] = {{0}, {1, 3, 5}, {2, 5, 7}, {3, 3, 8}, {4, 1, 4}, {5, 5, 9}, {6, 2, 13}, {7, 12, 15}, {8, 6, 10}, {9, 8, 11}, {10, 8, 12}, {11, 0, 6}};int greedy(){    int selected = 1; //选择第一个活动A[1]    int ans = 1;    order[1] = 1;    for (int i = 2; i &lt;= n; i++)     //扫描所有活动        if (a[i].b &gt;= a[selected].e) //找到一个相容活动        {            order[i] = 1;            selected = i; //选择A[i]活动            ans++;        }    return ans;}int main(){    memset(order, 0, sizeof(order));    sort(a + 1, a + n + 1);    cout &lt;&lt; "Max activity number:" &lt;&lt; greedy() &lt;&lt; endl;    for (int i = 1; i &lt;= n; i++)    {        if (order[i] == 1)        {            cout &lt;&lt; a[i].i &lt;&lt; " ";        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4 / 5 问题的解法都按照以下步骤：</p><ol><li><p>预处理：按照单位价值递减/最早结束时间递增排序</p></li><li><p>选择第一个活动</p></li><li><p>贪心选择后续活动，若不可行则结束选择</p></li></ol><h3 id="4-6-huffman编码问题"><a href="#4-6-huffman编码问题" class="headerlink" title="4.6 huffman编码问题"></a>4.6 huffman编码问题</h3><h3 id="4-7-dijkstra算法"><a href="#4-7-dijkstra算法" class="headerlink" title="4.7 dijkstra算法"></a>4.7 dijkstra算法</h3><h3 id="4-8-最小生成树问题"><a href="#4-8-最小生成树问题" class="headerlink" title="4.8 最小生成树问题"></a>4.8 最小生成树问题</h3><h2 id="5-回溯法"><a href="#5-回溯法" class="headerlink" title="5 回溯法"></a>5 回溯法</h2><h3 id="5-0-搜索算法的概述"><a href="#5-0-搜索算法的概述" class="headerlink" title="5.0 搜索算法的概述"></a>5.0 搜索算法的概述</h3><h4 id="5-0-1-问题的解"><a href="#5-0-1-问题的解" class="headerlink" title="5.0.1 问题的解"></a>5.0.1 问题的解</h4><p>可能解、可行解、最优解</p><h4 id="5-0-2-问题求解与搜索算法"><a href="#5-0-2-问题求解与搜索算法" class="headerlink" title="5.0.2 问题求解与搜索算法"></a>5.0.2 问题求解与搜索算法</h4><p>问题的表示：枚举对象、解的表示</p><p>求解的方法：递归、动态规划</p><p>搜索算法是一个通用的解法，设计树再遍历</p><p>还要进行优化，如剪枝用来避免无效搜索、启发式信息用来加速</p><h4 id="5-0-3-问题的解空间树"><a href="#5-0-3-问题的解空间树" class="headerlink" title="5.0.3 问题的解空间树"></a>5.0.3 问题的解空间树</h4><ol><li><p>概念</p></li><li><p>解空间树</p></li><li><p>解空间树可以形式化地定义为一个四元组（S，A，G，F）</p><p>S表示问题的初始状态，它是搜索的起点。</p><p>A是采取的操作符集合，初始状态和操作符隐含地定义了问题的解空间。</p><p>G表示目标测试，它判断给定的状态是否为目标状态。它可以是表示目标状态的一个状态集合，也可以是一个判定函数。</p><p>F代表路径耗散函数，它的定义需要具体问题具体分析。</p></li><li><p>搜索</p><p>就是在解空间树中从初始状态出发，执行特定的操作，试探地寻找目标状态的过程。</p></li><li><p>搜索的方法</p><p>枚举：DFS、BFS</p><p>枚举+优化：</p><ol><li><p>回溯算法：DFS+剪枝</p></li><li><p>分支限界算法：BFS+剪枝</p></li></ol><p>启发式搜索：基于规则的优化搜索算法</p><ol><li><p>DFS   stack</p></li><li><p>BFS   queue</p></li></ol></li></ol><h3 id="5-1-回溯法的概述"><a href="#5-1-回溯法的概述" class="headerlink" title="5.1 回溯法的概述"></a>5.1 回溯法的概述</h3><h4 id="5-1-1-设计思想"><a href="#5-1-1-设计思想" class="headerlink" title="5.1.1 设计思想"></a>5.1.1 设计思想</h4><ol><li><p>回溯=DFS+剪枝</p></li><li><p>剪枝策略</p><ol><li><p>约束函数剪枝(不可行解)</p><p>找到不合法的状态结点S，S的子树一定没有可行解</p></li><li><p>限界函数剪枝(非最优解)</p><p>最优化问题，访问的状态为S，存在一个判定函数，以S为根的子树不可能包含最优解</p></li><li><p>步骤</p><ol><li><p>针对所给问题，定义问题的状态表示，确定结点的扩展搜索规则，确定问题的解空间树；</p></li><li><p>以深度优先方式搜索解空间树，并在搜索过程中采用剪枝函数来避免无效搜索。</p></li></ol></li></ol></li></ol><h4 id="5-1-2-算法框架"><a href="#5-1-2-算法框架" class="headerlink" title="5.1.2 算法框架"></a>5.1.2 算法框架</h4><ol><li><p>递归回溯</p><ol><li><p>子集树</p></li><li><p>排列树</p></li></ol></li><li><p>迭代回溯</p></li><li><p>时空性能</p><ol><li><p>时间性能分析</p><p>最坏为指数阶：解空间树是子集树时对应算法的时间复杂度为O(2^n)(有或者没有)，排列树为O(n!)(全排列)。</p><p>一般情况下：加上剪枝策略后，回溯法的效率一般高于蛮力法。</p></li><li><p>空间性能分析</p><p>假设解空间树中从根结点到叶结点的最长路径的长度为h(n)，则回溯法所需的计算空间通常为O(h(n))。</p><p>显式地存储整个解空间则需要O(2^h(n))或O(h(n)!)内存空间。</p></li></ol></li></ol><h3 id="5-2-m着色问题"><a href="#5-2-m着色问题" class="headerlink" title="5.2 m着色问题"></a>5.2 m着色问题</h3><p>约束条件：相邻两点是否着色相同</p><p>T(n)=O(m^n)</p><h3 id="5-3-n皇后问题"><a href="#5-3-n皇后问题" class="headerlink" title="5.3 n皇后问题"></a>5.3 n皇后问题</h3><p>约束条件：每行或每列不存在两个元素，对角线上不存在两个元素</p><p>T(n)=O(n^n)</p><p>利用显式约束排除两个皇后在同一行或同一列的方法，可能解是（1,2，……,n）的一个排列，因此对应的解空间树中有n!个叶子节点，所以算法的时间复杂度可以降为O(n!) </p><h3 id="5-4-0-1背包问题"><a href="#5-4-0-1背包问题" class="headerlink" title="5.4 0-1背包问题"></a>5.4 0-1背包问题</h3><p>约束条件：剪除不可能获得可行解的子树</p><p>限界条件：剪除不可能获得最优解的子树</p><p>最坏复杂度即不考虑剪枝时的复杂度，T(n)=O(2^n)</p><h2 id="6-分支限界法"><a href="#6-分支限界法" class="headerlink" title="6 分支限界法"></a>6 分支限界法</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><h4 id="6-1-1-分支限界法"><a href="#6-1-1-分支限界法" class="headerlink" title="6.1.1 分支限界法"></a>6.1.1 分支限界法</h4><p>BFS+剪枝(限界)，找最优解</p><h4 id="6-1-2-设计思想"><a href="#6-1-2-设计思想" class="headerlink" title="6.1.2 设计思想"></a>6.1.2 设计思想</h4><ol><li><p>确定限界函数</p><ol><li>目标函数是求最大值：则设计上界限界函数ub，若si是sj的双亲结点，则满足ub(si)≥ub(sj)。当找到一个可行解ub(sk)后，将所有小于ub(sk)的结点剪枝。</li><li>目标函数是求最小值：则设计下界限界函数lb，若si是sj的双亲结点，则满足lb(si)≤lb(sj)。当找到一个可行解lb(sk)后，将所有大于lb(sk)的结点剪枝。</li></ol></li></ol><ol start="2"><li><p>组织待处理的活结点表</p><ol><li><p>队列式 queue</p></li><li><p>优先队列式 priority_queue</p><ol><li><p>计算起始结点（根结点）的优先级并加入优先队列（与特定问题相关的信息的函数值决定优先级）。</p></li><li><p>从优先队列中取出优先级最高的结点作为当前扩展结点，使搜索朝着解空间树上可能有最优解的分支推进，以便尽快地找出一个最优解。</p></li><li><p>对当前扩展结点，先从左到右地产生它的所有孩子结点，然后用约束条件检查，对所有满足约束条件的孩子结点计算优先级并加入优先队列。</p></li><li><p>重复步骤2和3，直到找到一个解或优先队列为空为止。</p></li></ol></li></ol></li><li><p>确定向量的各个分量</p><ol><li><p>对每个扩展结点保存从根结点到该结点的路径。         </p><p>每个结点带有一个可能的解向量。这种做法比较浪费空间，但实现起来简单，后面的示例均采用这种方式。</p></li><li><p>在搜索过程中构建搜索经过的树结构。</p><p>每个结点带有一个双亲结点指针，当找到最优解时，通过双亲指针找到对应的最优解向量。这种做法需保存搜索经过的树结构，每个结点增加一个指向双亲结点的指针。</p></li></ol></li><li><p>时间性能分析</p><p>在最坏情况下，时间复杂性是指数阶。</p></li></ol><h3 id="6-2-0-1背包问题"><a href="#6-2-0-1背包问题" class="headerlink" title="6.2 0-1背包问题"></a>6.2 0-1背包问题</h3><ol><li>队列式</li></ol><p>上界界限函数(贪心算法)</p><ol start="2"><li>优先队列式</li></ol><p>必须设计限界函数，因为优先级是以限界函数值为基础的</p><p>两种方法T(n)=O(2^n)</p><h3 id="6-3-TSP问题"><a href="#6-3-TSP问题" class="headerlink" title="6.3 TSP问题"></a>6.3 TSP问题</h3><ol><li><p>确定目标函数的下界lb。</p></li><li><p>确定目标函数值的计算方法（限界函数）。</p></li><li><p>基于下界，利用优先队列式分支限界法，搜索最优值和最优解。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础总结 3/7</title>
      <link href="/2021/07/20/css-3-7/"/>
      <url>/2021/07/20/css-3-7/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础总结-3-7"><a href="#CSS-基础总结-3-7" class="headerlink" title="CSS 基础总结 3/7"></a>CSS 基础总结 3/7</h1><h2 id="1-盒子模型"><a href="#1-盒子模型" class="headerlink" title="1 盒子模型"></a>1 盒子模型</h2><p>页面布局要学习三大核心：盒子模型，浮动和定位。学习好盒子模型能非常好的帮助我们布局页面。</p><h3 id="1-1-看透网页布局的本质"><a href="#1-1-看透网页布局的本质" class="headerlink" title="1.1 看透网页布局的本质"></a>1.1 看透网页布局的本质</h3><p>网页布局过程： </p><ol><li>先准备好相关的网页元素，网页元素基本都是盒子 Box 。 </li><li>利用 CSS 设置好盒子样式，然后摆放到相应位置。  </li><li>往盒子里面装内容。</li></ol><p>网页布局的核心本质： 就是利用 CSS 摆盒子。</p><h3 id="1-2-盒子模型（Box-Model）组成"><a href="#1-2-盒子模型（Box-Model）组成" class="headerlink" title="1.2 盒子模型（Box Model）组成"></a>1.2 盒子模型（Box Model）组成</h3><p><strong>盒子模型</strong>就是把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。</p><p>CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边框、外边距、内边距、和实际内容。</p><img src="image-20210720012136432.png" alt="image-20210720012136432"><h3 id="1-3-边框（border）"><a href="#1-3-边框（border）" class="headerlink" title="1.3 边框（border）"></a>1.3 边框（border）</h3><p>border可以设置元素的边框。边框有三部分组成：边框宽度(粗细)、边框样式、边框颜色。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">border : border-width border-style border-color<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20210720012238951.png" alt="image-20210720012238951"></p><p>边框样式 border-style 可以设置如下值：</p><ol><li>none：没有边框即忽略所有边框的宽度（默认值） </li><li>solid：边框为单实线(最为常用的) </li><li>dashed：边框为虚线  </li><li>dotted：边框为点线</li></ol><p>CSS 边框属性允许你指定一个元素边框的样式和颜色。</p><p>边框简写：</p><pre class="line-numbers language-none"><code class="language-none">border: 1px solid red; 没有顺序 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>边框分开写法：</p><pre class="line-numbers language-none"><code class="language-none">border-top: 1px solid red; /* 只设定上边框， 其余同理 */ <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-4-边框合并（border-collapse）"><a href="#1-4-边框合并（border-collapse）" class="headerlink" title="1.4 边框合并（border-collapse）"></a>1.4 边框合并（border-collapse）</h3><p>border-collapse 属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">border-collapse:collapse;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>border-collapse: collapse; 表示相邻边框合并在一起</li></ul><h3 id="1-5-边框会影响盒子实际大小"><a href="#1-5-边框会影响盒子实际大小" class="headerlink" title="1.5 边框会影响盒子实际大小"></a>1.5 边框会影响盒子实际大小</h3><p>边框会额外增加盒子的实际大小。</p><p>因此我们有两种方案解决: </p><ol><li>测量盒子大小的时候,不量边框</li><li>如果测量的时候包含了边框,则需要 width/height 减去边框宽度</li></ol><h3 id="1-6-内边距（padding）"><a href="#1-6-内边距（padding）" class="headerlink" title="1.6 内边距（padding）"></a>1.6 内边距（padding）</h3><p>padding 属性用于设置内边距，即边框与内容之间的距离。</p><p><img src="image-20210720171247931.png" alt="image-20210720171247931"></p><p>padding 属性可以有一到四个值。</p><p><img src="image-20210720171332665.png" alt="image-20210720171332665"></p><p>当我们给盒子指定 padding 值之后，发生了 2 件事情：</p><ol><li>内容和边框有了距离，添加了内边距。</li><li>padding影响了盒子实际大小。</li></ol><p>也就是说，如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子。</p><p><strong>解决方案：</strong> </p><p>如果保证盒子跟效果图大小保持一致，则让 width/height 减去多出来的内边距大小即可。</p><img src="image-20210720171713332.png" alt="image-20210720171713332" style="zoom: 80%;"><p>如何盒子本身没有指定width/height属性, 则此时padding不会撑开盒子大小。</p><h3 id="1-7-外边距（margin）"><a href="#1-7-外边距（margin）" class="headerlink" title="1.7 外边距（margin）"></a>1.7 外边距（margin）</h3><p>margin 属性用于设置外边距，即控制盒子和盒子之间的距离。</p><p><img src="image-20210720171801506.png" alt="image-20210720171801506"></p><p>margin 简写方式代表的意义跟 padding 完全一致。</p><p>外边距可以让块级盒子<strong>水平居中</strong>，但是必须满足两个条件：</p><ol><li>盒子必须指定了宽度（width）。 </li><li>盒子左右的外边距都设置为 auto 。</li></ol><pre class="line-numbers language-none"><code class="language-none">.header{ width:960px; margin:0 auto;}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常见的写法，以下三种都可以：</p><ul><li>margin-left: auto; margin-right: auto; </li><li>margin: auto; </li><li>margin: 0 auto;</li></ul><p>注意：以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 text-align:center 即可。</p><h3 id="1-8-外边距合并"><a href="#1-8-外边距合并" class="headerlink" title="1.8 外边距合并"></a>1.8 外边距合并</h3><p>使用 <strong>margin</strong> 定义块元素的<strong>垂直外边距</strong>时，可能会出现外边距的合并。</p><p>主要有两种情况: </p><ol><li><strong>相邻块元素垂直外边距的合并</strong></li></ol><p>当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。<strong>取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并。</strong></p><img src="image-20210720184210375.png" alt="image-20210720184210375" style="zoom: 80%;"><p><strong>解决方法：</strong></p><p>尽量只给一个盒子添加 margin 值。</p><ol start="2"><li><strong>嵌套块元素垂直外边距的塌陷</strong></li></ol><p>对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。</p><img src="image-20210720184357537.png" alt="image-20210720184357537" style="zoom: 80%;"><p><strong>解决方法：</strong> </p><ol><li>可以为父元素定义上边框。 </li><li>可以为父元素定义上内边距。 </li><li>可以为父元素添加 overflow:hidden。</li></ol><h3 id="1-9-清除内外边距"><a href="#1-9-清除内外边距" class="headerlink" title="1.9 清除内外边距"></a>1.9 清除内外边距</h3><p>网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。</p><pre class="line-numbers language-none"><code class="language-none">* { padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */ }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。但是转换为块级和行内块元素就可以。</p><h2 id="2-圆角边框-（border-radius）"><a href="#2-圆角边框-（border-radius）" class="headerlink" title="2 圆角边框 （border-radius）"></a>2 圆角边框 （border-radius）</h2><p>在 CSS3 中，新增了圆角边框样式，这样我们的盒子就可以变圆角了。</p><p><strong>border-radius</strong> 属性用于设置元素的外边框圆角。</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">border-radius:length;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>参数值可以为数值或百分比的形式 </li><li>如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为 50% </li><li>该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角 </li><li>分开可写为：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和 border-bottom-left-radius</li><li>兼容性 IE9+ 浏览器支持, 但是不会影响页面布局,可以放心使用.</li></ul><h2 id="3-盒子阴影-（box-shadow）"><a href="#3-盒子阴影-（box-shadow）" class="headerlink" title="3 盒子阴影 （box-shadow）"></a>3 盒子阴影 （box-shadow）</h2><p>CSS3 中新增了盒子阴影，我们可以使用 <strong>box-shadow</strong> 属性为盒子添加阴影。</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">box-shadow: h-shadow v-shadow blur spread color inset; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20210720184913803.png" alt="image-20210720184913803"></p><p><strong>注意：</strong> </p><ol><li>默认的是外阴影（outset），但是不可以写这个单词，否则造成阴影无效 </li><li>盒子阴影不占用空间，不会影响其他盒子排列</li></ol><h2 id="4-文字阴影-（text-shadow）"><a href="#4-文字阴影-（text-shadow）" class="headerlink" title="4 文字阴影 （text-shadow）"></a>4 文字阴影 （text-shadow）</h2><p>在 CSS3 中，我们可以使用 <strong>text-shadow</strong> 属性将阴影应用于文本。</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">text-shadow: h-shadow v-shadow blur color;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20210720185059871.png" alt="image-20210720185059871"></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础总结 2/7</title>
      <link href="/2021/07/20/css-2-7/"/>
      <url>/2021/07/20/css-2-7/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础总结-2-7"><a href="#CSS-基础总结-2-7" class="headerlink" title="CSS 基础总结 2/7"></a>CSS 基础总结 2/7</h1><h2 id="0-Emmet-语法"><a href="#0-Emmet-语法" class="headerlink" title="0 Emmet 语法"></a>0 Emmet 语法</h2><h3 id="0-1-什么是-Emmet-语法"><a href="#0-1-什么是-Emmet-语法" class="headerlink" title="0.1 什么是 Emmet 语法"></a>0.1 什么是 Emmet 语法</h3><p>Emmet 语法的前身是 Zen coding ,它使用缩写来提高 HTML / CSS 的编写速度, VSCode内部已经集成该语法。</p><h3 id="0-2-快速生成HTML结构语法"><a href="#0-2-快速生成HTML结构语法" class="headerlink" title="0.2 快速生成HTML结构语法"></a>0.2 快速生成HTML结构语法</h3><table><thead><tr><th align="center">序号</th><th align="center">目的</th><th align="center">写法</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">多个相同标签</td><td align="center">标签 * 数字</td><td align="center">div*3</td></tr><tr><td align="center">2</td><td align="center">父子级关系的标签</td><td align="center">父标签 &gt; 子标签</td><td align="center">ul &gt; li</td></tr><tr><td align="center">3</td><td align="center">兄弟关系的标签</td><td align="center">兄弟标签 + 兄弟标签</td><td align="center">div+p</td></tr><tr><td align="center">4</td><td align="center">成带有类名或者id名字</td><td align="center">.类名 或 #id</td><td align="center">.demo 或 #two</td></tr><tr><td align="center">5</td><td align="center">类名是有顺序的</td><td align="center">自增符号 $</td><td align="center">div$*3</td></tr><tr><td align="center">6</td><td align="center">在生成的标签内部写内容</td><td align="center">用 { } 表示</td><td align="center">div{内容}</td></tr></tbody></table><h3 id="0-3-快速生成CSS样式语法"><a href="#0-3-快速生成CSS样式语法" class="headerlink" title="0.3 快速生成CSS样式语法"></a>0.3 快速生成CSS样式语法</h3><p>CSS 基本采取单词首字母简写形式即可。</p><p>比如 lh26px 可以生成 line-height: 26px。</p><h2 id="1-CSS-的三大特性"><a href="#1-CSS-的三大特性" class="headerlink" title="1 CSS 的三大特性"></a>1 CSS 的三大特性</h2><p>CSS 有三个非常重要的三个特性：层叠性、继承性、优先级。</p><h3 id="1-1-层叠性"><a href="#1-1-层叠性" class="headerlink" title="1.1 层叠性"></a>1.1 层叠性</h3><p><strong>相同选择器</strong>给设置相同的样式，此时一个样式就会<strong>覆盖（层叠）</strong>另一个冲突的样式。层叠性主要解决样式冲突的问题。</p><p> 层叠性原则： </p><ul><li>样式冲突，遵循的原则是<strong>就近原则</strong>，哪个样式离结构近，就执行哪个样式</li><li>样式不冲突，不会层叠</li></ul><img src="image-20210720002056617.png" alt="image-20210720002056617" style="zoom: 67%;"><h3 id="1-2-继承性"><a href="#1-2-继承性" class="headerlink" title="1.2 继承性"></a>1.2 继承性</h3><p>CSS中的继承: 子标签会继承父标签的某些样式，如文本颜色和字号。</p><img src="image-20210720002108649.png" alt="image-20210720002108649" style="zoom: 80%;"><ul><li>恰当地使用继承可以简化代码，降低 CSS 样式的复杂性</li><li>子元素可以继承父元素的样式（text-，font-，line-这些元素开头的可以继承，以及color属性）</li></ul><p><strong>行高的继承性</strong></p><pre class="line-numbers language-none"><code class="language-none">body { font:12px/1.5 Microsoft YaHei；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>行高可以跟单位也可以不跟单位 </li><li>如果子元素没有设置行高，则会继承父元素的行高为 1.5 </li><li>此时子元素的行高是：当前子元素的文字大小 * 1.5  </li><li>body 行高 1.5 这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高</li></ul><h3 id="1-3-优先级"><a href="#1-3-优先级" class="headerlink" title="1.3 优先级"></a>1.3 优先级</h3><p>当同一个元素指定多个选择器，就会有优先级的产生。 </p><ul><li>选择器相同，则执行层叠性 </li><li>选择器不同，则根据<strong>选择器权重</strong>执行</li></ul><p>选择器权重如下表所示</p><p><img src="image-20210720002624121.png" alt="image-20210720002624121"></p><p><strong>优先级注意点：</strong></p><ol><li>权重是有4组数字组成，但是不会有进位。 </li><li>可以理解为类选择器永远大于元素选择器，id选择器永远大于类选择器，以此类推……</li><li>等级判断从左向右，如果某一位数值相同，则判断下一位数值。 </li><li><strong>继承的权重是0</strong>， 如果该元素没有<strong>直接选中</strong>，不管父元素权重多高，子元素得到的权重都是 0。</li></ol><p><strong>权重叠加：</strong>如果是复合选择器，则会有权重叠加，需要计算权重。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础总结 1/7</title>
      <link href="/2021/07/19/css-1-7/"/>
      <url>/2021/07/19/css-1-7/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础总结-1-7"><a href="#CSS-基础总结-1-7" class="headerlink" title="CSS 基础总结 1/7"></a>CSS 基础总结 1/7</h1><h2 id="1-CSS-简介"><a href="#1-CSS-简介" class="headerlink" title="1 CSS 简介"></a>1 CSS 简介</h2><h3 id="1-1-CSS-的作用"><a href="#1-1-CSS-的作用" class="headerlink" title="1.1 CSS 的作用"></a>1.1 CSS 的作用</h3><ol><li>HTML 主要做结构，显示元素内容。</li><li>CSS 用于美化 HTML，布局网页。</li><li>CSS 最大价值: 由 HTML 专注去做结构呈现，样式交给 CSS，即结构（HTML）与样式（CSS）相分离。</li></ol><h3 id="1-2-CSS-语法规范"><a href="#1-2-CSS-语法规范" class="headerlink" title="1.2 CSS 语法规范"></a>1.2 CSS 语法规范</h3><p>CSS 规则由两个主要的部分构成：选择器以及一条或多条声明。</p><p><img src="image-20210719184810221.png" alt="image-20210719184810221"></p><ul><li>选择器是用于指定 CSS 样式的 HTML 标签，花括号内是对该对象设置的具体样式。</li><li>属性和属性值以“键值对”的形式出现。</li><li>属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。</li><li>属性和属性值之间用英文“:”分开。</li><li>多个“键值对”之间用英文“;”进行区分。</li></ul><p>所有的样式，都包含在 <code>&lt;style&gt;</code>  标签内，表示是样式表。 <code>&lt;style&gt;</code>  一般写到 <code>&lt;/head&gt;</code> 上方。 </p><pre class="line-numbers language-none"><code class="language-none">&lt;head&gt;&lt;style&gt;h4 {color: blue;font-size: 100px;}&lt;/style&gt;&lt;/head&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-CSS-推荐代码风格"><a href="#1-3-CSS-推荐代码风格" class="headerlink" title="1.3 CSS 推荐代码风格"></a>1.3 CSS 推荐代码风格</h3><ol><li>展开格式</li></ol><pre class="line-numbers language-none"><code class="language-none">h3 { color: pink; font-size: 20px; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>全部小写</li></ol><p>样式选择器，属性名，属性值关键字全部使用小写字母。</p><ol start="3"><li><p>空格规范</p><ol><li>属性值前面，冒号后面，保留一个空格；</li><li>选择器（标签）和大括号中间保留空格。</li></ol></li></ol><h2 id="2-CSS-基础选择器"><a href="#2-CSS-基础选择器" class="headerlink" title="2 CSS 基础选择器"></a>2 CSS 基础选择器</h2><p><strong>参考文档：<a href="https://www.w3school.com.cn/cssref/css_selectors.asp">CSS 选择器参考手册 (w3school.com.cn)</a></strong></p><h3 id="2-1-选择器的作用"><a href="#2-1-选择器的作用" class="headerlink" title="2.1 选择器的作用"></a>2.1 选择器的作用</h3><p>选对指定的标签，设置正确的标签样式。</p><h3 id="2-2-选择器分类"><a href="#2-2-选择器分类" class="headerlink" title="2.2 选择器分类"></a>2.2 选择器分类</h3><p>分为<strong>基础选择器</strong>和<strong>复合选择器</strong>两个大类。</p><p>基础选择器：</p><ul><li><p>基础选择器是由单个选择器组成的</p></li><li><p>基础选择器又包括：标签选择器、类选择器、id 选择器和通配符选择器</p></li></ul><h3 id="2-3-标签选择器"><a href="#2-3-标签选择器" class="headerlink" title="2.3 标签选择器"></a>2.3 标签选择器</h3><p>   标签选择器（元素选择器）是指用 HTML 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式。</p><ul><li>语法：</li></ul><pre class="line-numbers language-none"><code class="language-none">标签名{   属性1: 属性值1;    属性2: 属性值2;    属性3: 属性值3;    ...} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>作用：标签选择器可以把某一类标签全部选择出来，比如所有的 <code>&lt;div&gt;</code> 标签和所有的 <code>&lt;span&gt;</code> 标签。</p></li><li><p>优点：能快速为页面中同类型的标签统一设置样式。</p></li><li><p>缺点：不能设计差异化样式，只能选择全部的当前标签。</p></li></ul><h3 id="2-4-类选择器"><a href="#2-4-类选择器" class="headerlink" title="2.4 类选择器"></a>2.4 类选择器</h3><p>   如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器。</p><p>   类选择器在 HTML 中以 class 属性表示，在 CSS 中，类选择器以一个点“.”号显示。</p><ul><li>语法：</li></ul><pre class="line-numbers language-none"><code class="language-none">.类名 { 属性1: 属性值1;  ...} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  例如，将所有拥有 red 类的 HTML 元素均为红色。 </p><pre class="line-numbers language-none"><code class="language-none">.red { color: red; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  构需要用<strong>class属性</strong>来调用 class 类的意思:</p><pre class="line-numbers language-none"><code class="language-none">&lt;div class=‘red’&gt; 变红色 &lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>注意<ol><li>类选择器使用“.”（英文点号）进行标识，后面紧跟类名（自定义，我们自己命名的）。 </li><li>可以理解为给这个标签起了一个名字，来表示。</li><li>长名称或词组可以使用中横线来为选择器命名。</li></ol></li></ul><p><strong>多类名</strong></p><p>我们可以给一个标签指定多个类名，从而达到更多的选择目的。 这些类名都可以选出这个标签。 简单理解就是一个标签有多个名字。</p><pre class="line-numbers language-none"><code class="language-none">&lt;div class="red font20"&gt;亚瑟&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p>多类名使用方式</p><ol><li>在标签 class 属性中写多个类名 </li><li>多个类名中间必须用空格分开</li><li>这个标签就可以分别具有这些类名的样式</li></ol></li><li><p>多类名开发中使用场景</p><ol><li>可以把一些标签元素相同的样式（共同的部分）放到一个类里面。</li><li>这些标签都可以调用这个公共的类和自己独有的类。</li><li>从而节省CSS代码，方便统一修改。</li></ol></li></ol><h3 id="2-5-id-选择器"><a href="#2-5-id-选择器" class="headerlink" title="2.5 id 选择器"></a>2.5 id 选择器</h3><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。 HTML 元素以 id 属性来设置 id 选择器，CSS 中 id 选择器以“#” 来定义。</p><ul><li>语法</li></ul><pre class="line-numbers language-none"><code class="language-none">#id名 { 属性1: 属性值1;  ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>例如，将 id 为 nav 元素中的内容设置为红色。</p><pre class="line-numbers language-none"><code class="language-none">#nav { color:red;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>id 属性只能在每个 HTML 文档中出现一次。</p><p><strong>id 选择器和类选择器的区别</strong></p><ol><li>类选择器（class）好比人的名字，一个人可以有多个名字，同时一个名字也可以被多个人使用。</li><li>id 选择器好比人的身份证号码，是唯一的，不得重复。 </li><li>id 选择器和类选择器最大的不同在于使用次数上。 </li><li>类选择器在修改样式中用的最多，id 选择器一般用于页面唯一性的元素上，经常和 JavaScript 搭配使用。</li></ol><h3 id="2-6-通配符选择器"><a href="#2-6-通配符选择器" class="headerlink" title="2.6 通配符选择器"></a>2.6 通配符选择器</h3><p>在 CSS 中，通配符选择器使用“*”定义，它表示选取页面中所有元素（标签）。</p><ul><li>语法</li></ul><pre class="line-numbers language-none"><code class="language-none">* { 属性1: 属性值1;  ...} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通配符选择器不需要调用， 自动就给所有的元素使用样式。在特殊情况下才使用。</p><pre class="line-numbers language-none"><code class="language-none">* { margin: 0; padding: 0;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7-基础选择器总结"><a href="#2-7-基础选择器总结" class="headerlink" title="2.7 基础选择器总结"></a>2.7 基础选择器总结</h3><p><img src="image-20210719192838584.png" alt="image-20210719192838584"></p><p> 如果是修改样式， 类选择器是使用最多的。</p><h2 id="3-CSS-字体属性"><a href="#3-CSS-字体属性" class="headerlink" title="3 CSS 字体属性"></a>3 CSS 字体属性</h2><p>CSS Fonts (字体)属性用于定义字体系列、大小、粗细、和文字样式（如斜体）。</p><h3 id="3-1-字体系列-font-family"><a href="#3-1-字体系列-font-family" class="headerlink" title="3.1 字体系列 font-family"></a>3.1 字体系列 font-family</h3><pre class="line-numbers language-none"><code class="language-none">p { font-family:"微软雅黑";} div {font-family: Arial,"Microsoft Yahei", "微软雅黑";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>各种字体之间必须使用英文状态下的逗号隔开</li><li>一般情况下，如果有空格隔开的多个单词组成的字体，加引号</li><li>尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示</li><li>最常见的几个字体：body {font-family: ‘Microsoft YaHei’,tahoma,arial,’Hiragino Sans GB’; }</li></ul><h3 id="3-2-字体大小-font-size"><a href="#3-2-字体大小-font-size" class="headerlink" title="3.2 字体大小 font-size"></a>3.2 字体大小 font-size</h3><pre class="line-numbers language-none"><code class="language-none">p {  font-size: 20px; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-3-字体粗细-font-weight"><a href="#3-3-字体粗细-font-weight" class="headerlink" title="3.3 字体粗细 font-weight"></a>3.3 字体粗细 font-weight</h3><pre class="line-numbers language-none"><code class="language-none">p {  font-weight: bold;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20210719193250229.png" alt="image-20210719193250229"></p><h3 id="3-4-文字样式-font-style"><a href="#3-4-文字样式-font-style" class="headerlink" title="3.4 文字样式  font-style"></a>3.4 文字样式  font-style</h3><pre class="line-numbers language-none"><code class="language-none">p {  font-style: normal;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20210719193345332.png" alt="image-20210719193345332"></p><h3 id="3-5-字体复合属性"><a href="#3-5-字体复合属性" class="headerlink" title="3.5 字体复合属性"></a>3.5 字体复合属性</h3><pre class="line-numbers language-none"><code class="language-none">body {  font: font-style font-weight font-size/line-height font-family;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>使用 font 属性时，必须按上面语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开</li><li>不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用</li></ul><h3 id="3-6-字体属性总结"><a href="#3-6-字体属性总结" class="headerlink" title="3.6 字体属性总结"></a>3.6 字体属性总结</h3><p><img src="image-20210719193627743.png" alt="image-20210719193627743"></p><h2 id="4-CSS-文本属性"><a href="#4-CSS-文本属性" class="headerlink" title="4 CSS 文本属性"></a>4 CSS 文本属性</h2><p>CSS Text（文本）属性可定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。</p><h3 id="4-1-文本颜色-color"><a href="#4-1-文本颜色-color" class="headerlink" title="4.1 文本颜色 color"></a>4.1 文本颜色 color</h3><pre class="line-numbers language-none"><code class="language-none">div {  color: red;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20210719193920785.png" alt="image-20210719193920785"></p><p>开发中最常用的是十六进制</p><h3 id="4-2-对齐文本-text-align"><a href="#4-2-对齐文本-text-align" class="headerlink" title="4.2 对齐文本 text-align"></a>4.2 对齐文本 text-align</h3><pre class="line-numbers language-none"><code class="language-none">div {  text-align: center;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20210719194011034.png" alt="image-20210719194011034"></p><h3 id="4-3-装饰文本-text-decoration"><a href="#4-3-装饰文本-text-decoration" class="headerlink" title="4.3 装饰文本 text-decoration"></a>4.3 装饰文本 text-decoration</h3><pre class="line-numbers language-none"><code class="language-none">div {  text-decoration：underline；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20210719194101748.png" alt="image-20210719194101748"></p><h3 id="4-4-文本缩进-text-indent"><a href="#4-4-文本缩进-text-indent" class="headerlink" title="4.4 文本缩进 text-indent"></a>4.4 文本缩进 text-indent</h3><p>text-indent 属性用来指定文本的第一行的缩进，通常是将段落的首行缩进。</p><pre class="line-numbers language-none"><code class="language-none">div {  /* text-indent: 10px; */ text-indent: 2em;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过设置该属性，所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值。</p><p>em 是一个相对单位，就是当前元素（font-size) 1 个文字的大小, 如果当前元素没有设置大小，则会按照父元 素的 1 个文字大小。</p><h3 id="4-5-行间距-line-height"><a href="#4-5-行间距-line-height" class="headerlink" title="4.5 行间距 line-height"></a>4.5 行间距 line-height</h3><p>line-height 属性用于设置行间的距离（行高）。可以控制文字行与行之间的距离。</p><pre class="line-numbers language-none"><code class="language-none">p {  line-height: 26px;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="image-20210719194423651.png" alt="image-20210719194423651" style="zoom: 67%;"><h3 id="4-6-文本属性总结"><a href="#4-6-文本属性总结" class="headerlink" title="4.6 文本属性总结"></a>4.6 文本属性总结</h3><p><img src="image-20210719194459302.png" alt="image-20210719194459302"></p><h2 id="5-CSS-的引入方式"><a href="#5-CSS-的引入方式" class="headerlink" title="5 CSS 的引入方式"></a>5 CSS 的引入方式</h2><h3 id="5-1-CSS-的三种样式表"><a href="#5-1-CSS-的三种样式表" class="headerlink" title="5.1 CSS 的三种样式表"></a>5.1 CSS 的三种样式表</h3><p>按照 CSS 样式书写的位置（或者引入的方式），CSS 样式表可以分为三大类： </p><ol><li>行内样式表（行内式） </li><li>内部样式表（嵌入式） </li><li>外部样式表（链接式）</li></ol><h3 id="5-2-内部样式表"><a href="#5-2-内部样式表" class="headerlink" title="5.2 内部样式表"></a>5.2 内部样式表</h3><p>内部样式表（内嵌样式表）是写到 HTML 页面内部. 是将所有的 CSS 代码抽取出来，单独放到一个 <code>&lt;style&gt;</code> 标签中。</p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt; div { color: red; font-size: 12px; }&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><code>&lt;style&gt;</code> 标签理论上可以放在 HTML 文档的任何地方，但一般会放在文档的 <code>&lt;head&gt;</code> 标签中</li><li>通过此种方式，可以方便控制当前整个页面中的元素样式设置</li><li>代码结构清晰，但是并没有实现结构与样式完全分离</li><li>使用内部样式表设定 CSS，通常也被称为嵌入式引入，这种方式是我们练习时常用的方式</li></ol><h3 id="5-3-行内样式表"><a href="#5-3-行内样式表" class="headerlink" title="5.3 行内样式表"></a>5.3 行内样式表</h3><p>行内样式表（内联样式表）是在元素标签内部的 style 属性中设定 CSS 样式。适合于修改简单样式。</p><pre class="line-numbers language-none"><code class="language-none">&lt;div style="color: red; font-size: 12px;"&gt;内容&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>style 其实就是标签的属性，在双引号中间，写法要符合 CSS 规范 </li><li>可以控制当前的标签设置样式 </li><li>由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简 单样式的时候，可以考虑使用 </li><li>使用行内样式表设定 CSS，通常也被称为行内式引入</li></ul><h3 id="5-4-外部样式表"><a href="#5-4-外部样式表" class="headerlink" title="5.4 外部样式表"></a>5.4 外部样式表</h3><p>实际开发都是外部样式表. 适合于样式比较多的情况. 核心是:样式单独写到CSS 文件中，之后把CSS文件引入 到 HTML 页面中使用。</p><p>引入外部样式表分为两步：</p><ol><li>新建一个后缀名为 .css 的样式文件，把所有 CSS 代码都放入此文件中。 </li><li>在 HTML 页面中，使用 标签引入这个文件。</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;link rel="stylesheet" href="css文件路径"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20210719195028696.png" alt="image-20210719195028696"></p><p>使用外部样式表设定 CSS，通常也被称为外链式或链接式引入，这种方式是开发中常用的方式</p><h3 id="5-5-CSS-引入方式总结"><a href="#5-5-CSS-引入方式总结" class="headerlink" title="5.5 CSS 引入方式总结"></a>5.5 CSS 引入方式总结</h3><p><img src="image-20210719195121023.png" alt="image-20210719195121023"></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 的基本用法</title>
      <link href="/2021/07/19/git-de-ji-ben-yong-fa/"/>
      <url>/2021/07/19/git-de-ji-ben-yong-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Git使用的基本技巧"><a href="#Git使用的基本技巧" class="headerlink" title="Git使用的基本技巧"></a>Git使用的基本技巧</h1><h2 id="1-什么是-Git"><a href="#1-什么是-Git" class="headerlink" title="1 什么是 Git"></a>1 什么是 Git</h2><p>Git 是用于Linux内核开发的版本控制工具。与 CVS、 Subversion 一类的集中式版本控制工具不同，它采用了分布式版本库的作法，不需要服务器端软件，就可以运作版本控制，使得源代码的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux 内核这样的大项目来说自然很重要。 Git 最为出色的是它的合并追踪（merge tracing）能力。</p><h2 id="2-Git-的安装"><a href="#2-Git-的安装" class="headerlink" title="2 Git 的安装"></a>2 Git 的安装</h2><h3 id="2-1-安装-Git"><a href="#2-1-安装-Git" class="headerlink" title="2.1 安装 Git"></a>2.1 安装 Git</h3><p>从官网上下载 Git 安装即可。在任一文件夹中右键出现<code>Git Bash Here</code>，点击该选项能打开命令窗口，即表示安装成功。</p><p>首先需要设置全局参数：名字和邮箱地址。</p><pre class="line-numbers language-none"><code class="language-none">$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入git config –global –list命令可以显示设置过的全局变量，如下：</p><pre class="line-numbers language-none"><code class="language-none">$ git config --global --listcore.editor="D:\Microsoft VS Code\Code.exe" --waituser.name=tzhiyuser.email=2570986081@qq.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-创建版本库"><a href="#2-2-创建版本库" class="headerlink" title="2.2 创建版本库"></a>2.2 创建版本库</h3><p><strong>版本库</strong>又名仓库，英文名 repository ，你可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录。</p><p>第二步，通过<code>git init</code>命令把这个目录变成 Git 可以管理的仓库。</p><pre class="line-numbers language-none"><code class="language-none">$ cd /e/githubup$ mkdir demo$ cd /e/githubup/demo$ pwd/e/githubup/demo$ git initInitialized empty Git repository in E:/GitHubUp/demo/.git/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，在文件夹内新增了一个以 .git 命名的隐藏文件。到这里，一个真正的仓库就创建好了!</p><h2 id="3-Git-的目录结构"><a href="#3-Git-的目录结构" class="headerlink" title="3 Git 的目录结构"></a>3 Git 的目录结构</h2><p>在使用 Git 之前，我们要了解 Git 的主要结构是什么。</p><p>git中加入了暂存区的概念，分为工作区，版本库中的暂存区，分支等概念。git版本库的模型如下图所示：</p><p><img src="GitConstruction.png"></p><p>上图描述了 git 对象的在不同的生命周期中不同的存储位置，通过不同的 git 命令改变 git 对象的存储生命周期。</p><ol><li><p>工作区(workspace)</p><p> 就是我们当前工作空间，也就是我们当前能在本地文件夹下面看到的文件结构。初始化工作空间或者工作空间 clean 的时候，文件内容和 index 暂存区是一致的，随着修改，工作区文件在没有 add 到暂存区时候，工作区将和暂存区是不一致的。</p></li><li><p>暂存区 (index)</p><p> 老版本概念也叫 Cache 区，就是文件暂时存放的地方，所有暂时存放在暂存区中的文件将随着一个 commit 一起提交到 local repository 此时 local repository 里面文件将完全被暂存区所取代。暂存区是 git 架构设计中非常重要和难理解的一部分。</p></li><li><p>本地仓库 (local repository)</p><p> git 是分布式版本控制系统，和其他版本控制系统不同的是他可以完全去中心化工作，你可以不用和中央服务器 (remote server) 进行通信，在本地即可进行全部离线操作，包括 log，history，commit，diff 等等。完成离线操作最核心是因为 git 有一个几乎和远程一样的本地仓库，所有本地离线操作都可以在本地完成，等需要的时候再和远程服务进行交互。</p></li><li><p>远程仓库 (remote repository)</p><p> 中心化仓库，所有人共享，本地仓库会需要和远程仓库进行交互，也就能将其他所有人内容更新到本地仓库把自己内容上传分享给其他人。结构大体和本地仓库一样。</p></li></ol><p>使用 Git 命令后文件的变化</p><p><img src="GitCommand.png"></p><p>Git管理的是修改，当使用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>所以在每次使用git commit之前，所有修改过的文件都必须重新进行git add，将工作区(workspace)中的修改提交到暂存区(index)中，否则即使进行了git commit本地仓库中也将不会出现修改。</p><h2 id="4-版本管理"><a href="#4-版本管理" class="headerlink" title="4 版本管理"></a>4 版本管理</h2><h3 id="4-1-添加文件到版本库"><a href="#4-1-添加文件到版本库" class="headerlink" title="4.1 添加文件到版本库"></a>4.1 添加文件到版本库</h3><h4 id="4-1-1-在刚创建的-Git-仓库下创建一个-readme-txt-文件"><a href="#4-1-1-在刚创建的-Git-仓库下创建一个-readme-txt-文件" class="headerlink" title="4.1.1 在刚创建的 Git 仓库下创建一个 readme.txt 文件:"></a>4.1.1 在刚创建的 Git 仓库下创建一个 <code>readme.txt</code> 文件:</h4><pre class="line-numbers language-none"><code class="language-none">this is readme.txthello git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-1-2-使用-git-add-命令将文件提交到暂存区。"><a href="#4-1-2-使用-git-add-命令将文件提交到暂存区。" class="headerlink" title="4.1.2 使用 git add 命令将文件提交到暂存区。"></a>4.1.2 使用 <code>git add</code> 命令将文件提交到暂存区。</h4><pre class="line-numbers language-none"><code class="language-none">$ git add readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用 <code>git add .</code>来一次性提交所有的改动。</p><h4 id="4-1-3-使用-git-commit-命令将文件提交到本地仓库。"><a href="#4-1-3-使用-git-commit-命令将文件提交到本地仓库。" class="headerlink" title="4.1.3 使用 git commit 命令将文件提交到本地仓库。"></a>4.1.3 使用 <code>git commit</code> 命令将文件提交到本地仓库。</h4><pre class="line-numbers language-none"><code class="language-none">$ git commit -m "new readme file"[master (root-commit) ea52515] new readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>-m</code> 后面输入的是本次提交的说明。</p><h3 id="4-2-状态管理"><a href="#4-2-状态管理" class="headerlink" title="4.2 状态管理"></a>4.2 状态管理</h3><h4 id="4-2-1-修改-readme-txt-文件为如下"><a href="#4-2-1-修改-readme-txt-文件为如下" class="headerlink" title="4.2.1 修改 readme.txt 文件为如下"></a>4.2.1 修改 readme.txt 文件为如下</h4><pre class="line-numbers language-none"><code class="language-none">this is a file named readme.txthello git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-2-2-使用-git-status-查看当前状态"><a href="#4-2-2-使用-git-status-查看当前状态" class="headerlink" title="4.2.2 使用 git status 查看当前状态"></a>4.2.2 使用 <code>git status</code> 查看当前状态</h4><pre class="line-numbers language-none"><code class="language-none">$ git statusOn branch masterChanges not staged for commit:  (use "git add &lt;file&gt;..." to update what will be committed)  (use "git restore &lt;file&gt;..." to discard changes in working directory)        modified:   readme.txtno changes added to commit (use "git add" and/or "git commit -a")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git status</code> 命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt 被修改过了，但还没有准备提交的修改。</p><h4 id="4-2-3-使用-git-diff-查看修改的内容"><a href="#4-2-3-使用-git-diff-查看修改的内容" class="headerlink" title="4.2.3 使用 git diff 查看修改的内容"></a>4.2.3 使用 <code>git diff</code> 查看修改的内容</h4><pre class="line-numbers language-none"><code class="language-none">$ git diffdiff --git a/readme.txt b/readme.txtindex 4ead6b0..2d611cb 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-this is readme.txt+this is a file named readme.txt hello git\ No newline at end of file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到文件的被修改的状况。</p><h4 id="4-2-4-使用-git-status-查看-add-之后的状态"><a href="#4-2-4-使用-git-status-查看-add-之后的状态" class="headerlink" title="4.2.4 使用 git status 查看 add 之后的状态"></a>4.2.4 使用 <code>git status</code> 查看 add 之后的状态</h4><p>首先提交修改到暂存区。</p><pre class="line-numbers language-none"><code class="language-none">$ git add .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 <code>git status</code> 查看当前状态。</p><pre class="line-numbers language-none"><code class="language-none">$ git statusOn branch masterChanges to be committed:  (use "git restore --staged &lt;file&gt;..." to unstage)        modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git 告诉我们将要被提交的修改包括 readme.txt。</p><p>提交到本地仓库。</p><pre class="line-numbers language-none"><code class="language-none">$ git commit -m "readme.txt version2"[master 6daed76] readme.txt version2 1 file changed, 1 insertion(+), 1 deletion(-)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再次使用 <code>git status</code> 查看当前状态。</p><pre class="line-numbers language-none"><code class="language-none">$ git statusOn branch masternothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Git 告诉我们当前没有需要提交的修改，工作目录是干净（working tree clean）的。</p><h3 id="4-3-版本回退"><a href="#4-3-版本回退" class="headerlink" title="4.3 版本回退"></a>4.3 版本回退</h3><p>在 Git 中，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在 Git 中被称为 commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个 commit 恢复，然后继续工作，而不是把几个月的工作成果全部丢失。下面对这个功能进行演示。</p><h4 id="4-3-1-再次修改-readme-txt，并提交到本地仓库"><a href="#4-3-1-再次修改-readme-txt，并提交到本地仓库" class="headerlink" title="4.3.1 再次修改 readme.txt，并提交到本地仓库"></a>4.3.1 再次修改 readme.txt，并提交到本地仓库</h4><p>修改后的 readme.txt：</p><pre class="line-numbers language-none"><code class="language-none">this is a file named readme.txthello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提交到本地仓库：</p><pre class="line-numbers language-none"><code class="language-none">$ git add .$ git commit -m "readme.txt version3"[master 4a6cf89] readme.txt version3 1 file changed, 1 insertion(+), 1 deletion(-)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-2-使用-git-log-命令查看版本库状态"><a href="#4-3-2-使用-git-log-命令查看版本库状态" class="headerlink" title="4.3.2 使用 git log 命令查看版本库状态"></a>4.3.2 使用 <code>git log</code> 命令查看版本库状态</h4><pre class="line-numbers language-none"><code class="language-none">$ git logcommit 4a6cf892a3b737a8e95934acac251bb60d118068 (HEAD -&gt; master)Author: tzhiy &lt;2570986081@qq.com&gt;Date:   Sun Jul 18 15:37:04 2021 +0800    readme.txt version3commit 6daed765e7b45a03c96fcb658f5e61b6a170b438Author: tzhiy &lt;2570986081@qq.com&gt;Date:   Sun Jul 18 15:19:22 2021 +0800    readme.txt version2commit ea5251506b165792227d36ad8f874e403760d5baAuthor: tzhiy &lt;2570986081@qq.com&gt;Date:   Sun Jul 18 15:04:44 2021 +0800    new readme file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git log</code> 命令显示从最近到最远的提交日志。commit id 就是版本号。HEAD 表示当前的版本，上一个版本用 HEAD^ 表示，上上一个用 HEAD^^ 表示，上 100 个版本用 HEAD~100 表示。</p><h4 id="4-3-3-使用-git-reset-命令回退到以前的版本"><a href="#4-3-3-使用-git-reset-命令回退到以前的版本" class="headerlink" title="4.3.3 使用 git reset 命令回退到以前的版本"></a>4.3.3 使用 <code>git reset</code> 命令回退到以前的版本</h4><pre class="line-numbers language-none"><code class="language-none">$ git reset --hard HEAD^HEAD is now at 6daed76 readme.txt version2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到readme.txt 的内容回退到version2：</p><pre class="line-numbers language-none"><code class="language-none">this is a file named readme.txthello git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再次使用 <code>git log</code> 查看版本库状态：</p><pre class="line-numbers language-none"><code class="language-none">$ git logcommit 6daed765e7b45a03c96fcb658f5e61b6a170b438 (HEAD -&gt; master)Author: tzhiy &lt;2570986081@qq.com&gt;Date:   Sun Jul 18 15:19:22 2021 +0800    readme.txt version2commit ea5251506b165792227d36ad8f874e403760d5baAuthor: tzhiy &lt;2570986081@qq.com&gt;Date:   Sun Jul 18 15:04:44 2021 +0800    new readme file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 version3 版本不见了，那怎么通过刚刚的方法回到 version3 版本呢？我们还可以用 commit id 跳转到其它的版本，可以通过之前的版本库状态查到 version3 的 commit id 是 4a6cf89…：</p><pre class="line-numbers language-none"><code class="language-none">$ git reset --hard 4a6cfHEAD is now at 4a6cf89 readme.txt version3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>又回到 version3 了！</p><p>Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的 HEAD 指针，当你回退版本的时候， Git 仅仅是把 HEAD 从指向 version3。</p><h4 id="4-3-4-使用-git-reflog-命令查看每一次改动"><a href="#4-3-4-使用-git-reflog-命令查看每一次改动" class="headerlink" title="4.3.4 使用 git reflog 命令查看每一次改动"></a>4.3.4 使用 <code>git reflog</code> 命令查看每一次改动</h4><p>你回退到了某个版本，关掉了电脑之后想恢复到新版本怎么办？找不到新版本的commit id怎么办？Git提供了一个命令 <code>git reflog</code> 用来记录你的每一次命令：</p><pre class="line-numbers language-none"><code class="language-none">$ git reflog4a6cf89 (HEAD -&gt; master) HEAD@{0}: reset: moving to 4a6cf6daed76 HEAD@{1}: reset: moving to HEAD^4a6cf89 (HEAD -&gt; master) HEAD@{2}: commit: readme.txt version36daed76 HEAD@{3}: commit: readme.txt version2ea52515 HEAD@{4}: commit (initial): new readme file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们就可以知道每次执行命令所对应的 commit id 了。</p><h3 id="4-4-撤销修改"><a href="#4-4-撤销修改" class="headerlink" title="4.4 撤销修改"></a>4.4 撤销修改</h3><h4 id="4-4-1-丢弃工作区的修改"><a href="#4-4-1-丢弃工作区的修改" class="headerlink" title="4.4.1 丢弃工作区的修改"></a>4.4.1 丢弃工作区的修改</h4><p>场景 1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 <code>git checkout -- file</code>。</p><p>命令 <code>git checkout -- readme.txt</code> 意思就是，把 readme.txt 文件在工作区的修改全部撤销，这里有两种情况：</p><ol><li><p>readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p></li><li><p>readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p></li></ol><p>总之，就是让这个文件回到最近一次 <code>git commit</code> 或 <code>git add</code> 时的状态。</p><p>例如，将 readme.txt 的内容作修改:</p><pre class="line-numbers language-none"><code class="language-none">this is a file named readme.txthello worldbalabala<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">$ git checkout -- readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>撤销后的 readme.txt:</p><pre class="line-numbers language-none"><code class="language-none">this is a file named readme.txthello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-4-2-丢弃暂存区的修改"><a href="#4-4-2-丢弃暂存区的修改" class="headerlink" title="4.4.2 丢弃暂存区的修改"></a>4.4.2 丢弃暂存区的修改</h4><p>场景 2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 <code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景 1 操作。</p><p>用命令 <code>git reset HEAD &lt;file&gt;</code> 可以把暂存区的修改撤销掉（unstage），重新放回工作区。</p><pre class="line-numbers language-none"><code class="language-none">$ git reset HEAD readme.txtUnstaged changes after reset:Mreadme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>git reset</code> 命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用 HEAD 时，表示最新的版本。</p><h4 id="4-4-3-丢弃本地仓库的修改"><a href="#4-4-3-丢弃本地仓库的修改" class="headerlink" title="4.4.3 丢弃本地仓库的修改"></a>4.4.3 丢弃本地仓库的修改</h4><p>场景 3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p><h2 id="5-远程仓库"><a href="#5-远程仓库" class="headerlink" title="5 远程仓库"></a>5 远程仓库</h2><h2 id="6-分支管理"><a href="#6-分支管理" class="headerlink" title="6 分支管理"></a>6 分支管理</h2><p>参考：</p><ol><li>Git - 维基百科</li><li>廖雪峰的官方网站</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 基础总结</title>
      <link href="/2021/07/17/chu-shi-html/"/>
      <url>/2021/07/17/chu-shi-html/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-基础总结"><a href="#HTML-基础总结" class="headerlink" title="HTML 基础总结"></a>HTML 基础总结</h1><h2 id="HTML-简介"><a href="#HTML-简介" class="headerlink" title="HTML 简介"></a>HTML 简介</h2><h3 id="1-网页"><a href="#1-网页" class="headerlink" title="1 网页"></a>1 网页</h3><h4 id="1-1-什么是网页"><a href="#1-1-什么是网页" class="headerlink" title="1.1 什么是网页"></a>1.1 什么是网页</h4><p><strong>网站</strong>是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。  </p><p><strong>网页</strong>是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，常见以 .htm 或 .html 后缀结尾的文件，因此将其俗称为 HTML 文件。  </p><h4 id="1-2-什么是-HTML"><a href="#1-2-什么是-HTML" class="headerlink" title="1.2 什么是 HTML"></a>1.2 什么是 HTML</h4><p><strong>HTML</strong> 指的是<strong>超文本标记语言 (Hyper Text Markup Language)</strong> ，它是用来描述网页的一种语言，由标签组成。  </p><p>超文本：超越文本限制，超级链接文本。  </p><h4 id="1-3-网页的形成"><a href="#1-3-网页的形成" class="headerlink" title="1.3 网页的形成"></a>1.3 网页的形成</h4><p>网页是由网页元素组成的，这些元素是利用 HTML 标签描述出来，然后通过浏览器解析来显示给用户的。  </p><p>前端人员开发代码 —-&gt; 浏览器显示代码（解析、渲染） —-&gt; 生成最后的 Web 页面  </p><h3 id="2-常用浏览器"><a href="#2-常用浏览器" class="headerlink" title="2 常用浏览器"></a>2 常用浏览器</h3><h3 id="3-Web-标准"><a href="#3-Web-标准" class="headerlink" title="3 Web 标准"></a>3 Web 标准</h3><p><strong>Web 标准</strong>是由 W3C 组织和其他标准化组织制定的<strong>一系列标准的集合</strong>。W3C（万维网联盟）是国际最著名的标准化组织。  </p><h4 id="3-1-为什么要学习-Web-标准"><a href="#3-1-为什么要学习-Web-标准" class="headerlink" title="3.1 为什么要学习 Web 标准"></a>3.1 为什么要学习 Web 标准</h4><p>遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有很多优点。  </p><h4 id="3-2-Web-标准的构成"><a href="#3-2-Web-标准的构成" class="headerlink" title="3.2 Web 标准的构成"></a>3.2 Web 标准的构成</h4><p>主要包括<strong>结构（Structure）</strong> 、<strong>表现（Presentation）</strong>和<strong>行为（Behavior）</strong>三个方面。  </p><table><thead><tr><th>标准</th><th>说明</th></tr></thead><tbody><tr><td>结构</td><td>用于对<strong>网页元素</strong>进行整理和分类，如HTML</td></tr><tr><td>表现</td><td>用于设置网页版式、颜色、大小等<strong>外观样式</strong>，如CSS</td></tr><tr><td>行为</td><td>指网页模型的定义以及<strong>交互</strong>的编写，如JavaScript</td></tr></tbody></table><p>Web 标准提出的最佳体验方案：结构、样式、行为相分离。  </p><h2 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h2><h3 id="1-HTML语法规范"><a href="#1-HTML语法规范" class="headerlink" title="1 HTML语法规范"></a>1 HTML语法规范</h3><h4 id="1-1-基本语法概述"><a href="#1-1-基本语法概述" class="headerlink" title="1.1 基本语法概述"></a>1.1 基本语法概述</h4><p>由尖括号包围，分为单标签和双标签。  </p><h4 id="1-2-标签关系"><a href="#1-2-标签关系" class="headerlink" title="1.2 标签关系"></a>1.2 标签关系</h4><p><strong>包含关系</strong>和<strong>并列关系</strong>。  </p><h3 id="2-HTML-基本结构标签"><a href="#2-HTML-基本结构标签" class="headerlink" title="2 HTML 基本结构标签"></a>2 HTML 基本结构标签</h3><p>每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写。   </p><p><code>&lt;html&gt;、&lt;head&gt;、&lt;title&gt;、&lt;body&gt;</code>  </p><h3 id="3-网页开发工具"><a href="#3-网页开发工具" class="headerlink" title="3 网页开发工具"></a>3 网页开发工具</h3><h3 id="4-HTML-常用标签"><a href="#4-HTML-常用标签" class="headerlink" title="4 HTML 常用标签"></a>4 HTML 常用标签</h3><table><thead><tr><th>语义</th><th>格式</th><th>属性</th></tr></thead><tbody><tr><td>标题标签</td><td><code>&lt;h1&gt;~&lt;h6&gt;</code></td><td></td></tr><tr><td>段落和换行</td><td><code>&lt;p&gt;</code> <code>&lt;br&gt;</code></td><td></td></tr><tr><td>加粗和倾斜</td><td><code>&lt;strong&gt;</code> <code>&lt;em&gt;</code></td><td></td></tr><tr><td>盒子</td><td><code>&lt;div&gt;</code> <code> &lt;span&gt;</code></td><td></td></tr><tr><td>图像</td><td><code>&lt;img  src="图像URL"&gt;</code></td><td>src / alt / title / width / height</td></tr><tr><td>超链接</td><td><code>&lt;a&gt;</code></td><td>herf / target(打开方式)</td></tr></tbody></table><p>超链接分类：内部链接、外部链接、空链接、下载链接、锚点链接、网页元素链接  </p><h3 id="5-HTML-中的注释和特殊字符"><a href="#5-HTML-中的注释和特殊字符" class="headerlink" title="5 HTML 中的注释和特殊字符"></a>5 HTML 中的注释和特殊字符</h3><h4 id="5-1-注释"><a href="#5-1-注释" class="headerlink" title="5.1 注释"></a>5.1 注释</h4><p><code>&lt;!--  --&gt;</code> 快捷键：<code>ctrl</code>+<code>/</code>  </p><h4 id="5-2-特殊字符"><a href="#5-2-特殊字符" class="headerlink" title="5.2 特殊字符"></a>5.2 特殊字符</h4><table><thead><tr><th align="center">特殊字符</th><th align="center">代码</th></tr></thead><tbody><tr><td align="center">（空格）</td><td align="center">&amp;nbsp</td></tr><tr><td align="center"><code>&lt;</code></td><td align="center">&amp;lt</td></tr><tr><td align="center"><code>&gt;</code></td><td align="center">&amp;gt</td></tr></tbody></table><h3 id="6-表格标签-lt-table-gt"><a href="#6-表格标签-lt-table-gt" class="headerlink" title="6 表格标签 <table>"></a>6 表格标签 <code>&lt;table&gt;</code></h3><h4 id="6-1-基本语法"><a href="#6-1-基本语法" class="headerlink" title="6.1 基本语法"></a>6.1 基本语法</h4><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td><code>&lt;table&gt;</code></td><td>用于定义表格的标签</td></tr><tr><td><code>&lt;tr&gt;</code></td><td>表格中的行，必须嵌套在 <code>&lt;table&gt; &lt;/table&gt;</code>标签中</td></tr><tr><td><code>&lt;td&gt;</code></td><td>表格中的单元格，必须嵌套在<code>&lt;tr&gt;&lt;/tr&gt;</code>标签中</td></tr><tr><td><code>&lt;th&gt;</code></td><td>表格中的表头，必须嵌套在<code>&lt;tr&gt;&lt;/tr&gt;</code>标签中</td></tr></tbody></table><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td><code>&lt;thead&gt;</code></td><td>表格的头部区域</td></tr><tr><td><code>&lt;tbody&gt;</code></td><td>表格的主体</td></tr></tbody></table><p>用于分清表格结构</p><h4 id="6-2-合并单元格"><a href="#6-2-合并单元格" class="headerlink" title="6.2 合并单元格"></a>6.2 合并单元格</h4><table><thead><tr><th align="center">合并方式</th><th align="center">属性描述</th></tr></thead><tbody><tr><td align="center">跨行合并</td><td align="center">rowspan=”合并单元格的个数”</td></tr><tr><td align="center">跨列合并</td><td align="center">colspan=”合并单元格的个数”</td></tr></tbody></table><p><strong>步骤：</strong></p><ol><li>先确定是跨行还是跨列合并。</li><li>找到目标单元格. 写上合并方式 = 合并的单元格数量。比如：<code>&lt;td colspan="2"&gt;&lt;/td&gt;</code>。</li><li>删除多余的单元格。   </li></ol><h3 id="7-列表标签"><a href="#7-列表标签" class="headerlink" title="7 列表标签"></a>7 列表标签</h3><table><thead><tr><th align="center">标签</th><th align="center">名称</th></tr></thead><tbody><tr><td align="center"><code>&lt;ul&gt;</code></td><td align="center">无序列表</td></tr><tr><td align="center"><code>&lt;li&gt;</code></td><td align="center">列表项</td></tr><tr><td align="center"><code>&lt;ol&gt;</code></td><td align="center">有序列表</td></tr><tr><td align="center"><code>&lt;dl&gt;</code></td><td align="center">自定义列表</td></tr><tr><td align="center"><code>&lt;dt&gt;</code></td><td align="center">定义项目</td></tr><tr><td align="center"><code>&lt;dd&gt;</code></td><td align="center">描述项目</td></tr></tbody></table><h4 id="7-1-无序列表"><a href="#7-1-无序列表" class="headerlink" title="7.1 无序列表"></a>7.1 无序列表</h4><pre class="line-numbers language-none"><code class="language-none">&lt;ul&gt;    &lt;li&gt;列表项1&lt;/li&gt;    &lt;li&gt;列表项2&lt;/li&gt;    ...&lt;/ul&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-2-有序列表"><a href="#7-2-有序列表" class="headerlink" title="7.2 有序列表"></a>7.2 有序列表</h4><pre class="line-numbers language-none"><code class="language-none">&lt;ol&gt;    &lt;li&gt;列表项1&lt;/li&gt;    &lt;li&gt;列表项2&lt;/li&gt;    ...&lt;/ol&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-3-自定义列表"><a href="#7-3-自定义列表" class="headerlink" title="7.3 自定义列表"></a>7.3 自定义列表</h4><pre class="line-numbers language-none"><code class="language-none">&lt;dl&gt;    &lt;dt&gt;名词1&lt;/dt&gt;    &lt;dd&gt;名词1解释1&lt;/dd&gt;    &lt;dd&gt;名词1解释2&lt;/dd&gt;    &lt;dt&gt;名词2&lt;/dt&gt;    ...&lt;/dl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-表单标签"><a href="#8-表单标签" class="headerlink" title="8 表单标签"></a>8 表单标签</h3><h4 id="8-1-表单的作用"><a href="#8-1-表单的作用" class="headerlink" title="8.1 表单的作用"></a>8.1 表单的作用</h4><p>收集用户信息。  </p><h4 id="8-2-表单的组成"><a href="#8-2-表单的组成" class="headerlink" title="8.2 表单的组成"></a>8.2 表单的组成</h4><p>表单域、表单控件（也称为表单元素）和提示信息。   </p><h4 id="8-3-表单域"><a href="#8-3-表单域" class="headerlink" title="8.3 表单域"></a>8.3 表单域</h4><p>表单域是一个包含表单元素的区域。    </p><p>在 HTML 标签中，<code>&lt;form&gt;</code> 标签用于定义表单域，以实现用户信息的收集和传递。  </p><p><code>&lt;form&gt;</code> 会把它范围内的表单元素信息提交给服务器。</p><table><thead><tr><th>属性</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td>URL地址</td><td>指定接受并处理表单数据的URL地址</td></tr><tr><td>method</td><td>get / post</td><td>设置表单提交方式</td></tr><tr><td>name</td><td>名称</td><td>指定表单名称</td></tr></tbody></table><h4 id="8-4-表单控件"><a href="#8-4-表单控件" class="headerlink" title="8.4 表单控件"></a>8.4 表单控件</h4><h5 id="8-4-1-lt-input-gt-表单元素"><a href="#8-4-1-lt-input-gt-表单元素" class="headerlink" title="8.4.1 <input>表单元素"></a>8.4.1 <code>&lt;input&gt;</code>表单元素</h5><p>在英文单词中，input 是输入的意思，而在表单元素中 <code>&lt;input&gt;</code> 标签用于收集用户信息。  </p><p>type属性用于指定不同的控件类型。</p><table><thead><tr><th>属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td>button</td><td align="center">普通按钮</td></tr><tr><td>checkbox</td><td align="center">多选按钮</td></tr><tr><td>file</td><td align="center">文件上传</td></tr><tr><td>password</td><td align="center">密码字段</td></tr><tr><td>radio</td><td align="center">单选按钮</td></tr><tr><td>submit</td><td align="center">提交按钮</td></tr><tr><td>text</td><td align="center">单行输入字段</td></tr></tbody></table><p>随用随查。  </p><p>除了type属性之外，<code>&lt;input&gt;</code>还有其他属性，常用的如下：  </p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>规定input元素名称</td></tr><tr><td>value</td><td>规定input元素值</td></tr><tr><td>checked</td><td>规定首次加载时应当被选中</td></tr><tr><td>maxlength</td><td>规定输入字符串最大长度</td></tr></tbody></table><h5 id="8-4-2-lt-label-gt-标签"><a href="#8-4-2-lt-label-gt-标签" class="headerlink" title="8.4.2 <label>标签"></a>8.4.2 <code>&lt;label&gt;</code>标签</h5><p><code>&lt;label&gt;</code> 标签为 input 元素定义标注（标签）。  </p><p><code>&lt;label&gt;</code> 标签用于绑定一个表单元素, 当点击<code>&lt;label&gt;</code> 标签内的文本时，浏览器就会自动将焦点(光标)转到或者</p><p>选择对应的表单元素上，用来增加用户体验。  </p><h5 id="8-4-3-lt-select-gt-表单元素"><a href="#8-4-3-lt-select-gt-表单元素" class="headerlink" title="8.4.3 <select>表单元素"></a>8.4.3 <code>&lt;select&gt;</code>表单元素</h5><p>定义下拉列表。</p><pre class="line-numbers language-none"><code class="language-none">&lt;select&gt;    &lt;option&gt;选项1&lt;/option&gt;    &lt;option&gt;选项2&lt;/option&gt;    &lt;option&gt;选项3&lt;/option&gt;&lt;/select&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p><code>&lt;select&gt;</code> 中至少包含一对<code>&lt;option&gt;</code> 。  </p></li><li><p>在<code>&lt;option&gt;</code> 中定义 selected = “selected” 时，当前项即为默认选中项。  </p></li></ol><h5 id="8-4-4-lt-textarea-gt-标签"><a href="#8-4-4-lt-textarea-gt-标签" class="headerlink" title="8.4.4 <textarea>标签"></a>8.4.4 <code>&lt;textarea&gt;</code>标签</h5><p>在表单元素中，<code>&lt;textarea&gt;</code> 标签是用于定义多行文本输入的控件。</p><pre class="line-numbers language-none"><code class="language-none">&lt;textarea rows="3" cols="20"&gt;    文本内容&lt;/textarea&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 使用方法</title>
      <link href="/2021/06/18/markdown/"/>
      <url>/2021/06/18/markdown/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-使用方法"><a href="#Markdown-使用方法" class="headerlink" title="Markdown 使用方法"></a>Markdown 使用方法</h1><h2 id="1-什么是-Markdown"><a href="#1-什么是-Markdown" class="headerlink" title="1 什么是 Markdown"></a>1 什么是 Markdown</h2><p>Markdown语言的目的是希望大家使用易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的XHTML（或是HTML）。  </p><p>简单地说，Markdown与HTML语言一样，使用一些符号代替样式。但是它比HTML语言更加简单。  </p><h3 id="Markdown文件的工作原理"><a href="#Markdown文件的工作原理" class="headerlink" title="Markdown文件的工作原理"></a>Markdown文件的工作原理</h3><p>Markdown文件在显示时先被处理器转化为HTML文件，再通过web浏览器显示出来。</p><p><img src="principle.png"></p><p>被转化的过程中文件样式如下：  </p><p><img src="transfer.png"></p><p>Markdown 的本质是让我们回归到内容本身，注重文章本身的结构，而不是样式。 </p><h2 id="2-怎么使用-Markdown"><a href="#2-怎么使用-Markdown" class="headerlink" title="2 怎么使用 Markdown"></a>2 怎么使用 Markdown</h2><h3 id="2-1-标题"><a href="#2-1-标题" class="headerlink" title="2.1 标题"></a>2.1 标题</h3><p>Markdown的标题写法有两种</p><h4 id="2-1-1-ATX-标题"><a href="#2-1-1-ATX-标题" class="headerlink" title="2.1.1 ATX 标题"></a>2.1.1 ATX 标题</h4><p>在标题文本的前面加 “#” 来表示，”#” 的个数代表标题的级数， “#” 后面加上一个空格，最多有六级标题。</p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none"># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题##### 这是六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2-Setext-标题"><a href="#2-1-2-Setext-标题" class="headerlink" title="2.1.2 Setext 标题"></a>2.1.2 Setext 标题</h4><p>在文字下方加上两个以上的 “=” （一阶标题）或者 “-“ （二阶标题）。</p><h3 id="2-2-字体"><a href="#2-2-字体" class="headerlink" title="2.2 字体"></a>2.2 字体</h3><p>修改字体通过将要修改的文字部分用 “*” 或者 “~” 包围，基本功能如下：</p><table><thead><tr><th align="center">功能</th><th align="center">示例</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">加粗</td><td align="center"><code>**加粗**</code></td><td align="center"><strong>加粗</strong></td></tr><tr><td align="center">斜体</td><td align="center"><code>*斜体*</code></td><td align="center"><em>斜体</em></td></tr><tr><td align="center">斜体加粗</td><td align="center"><code>***斜体加粗***</code></td><td align="center"><em><strong>斜体加粗</strong></em></td></tr><tr><td align="center">删除线</td><td align="center"><code>~~删除线~~</code></td><td align="center"><del>删除线</del></td></tr></tbody></table><h3 id="2-3-引用"><a href="#2-3-引用" class="headerlink" title="2.3 引用"></a>2.3 引用</h3><p>在要引用的文字前加上”&gt;”即可表示引用，也可多层嵌套。</p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none">&gt;引用&gt;&gt;引用之引用&gt;&gt;&gt;&gt;引用之引用之引用之引用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>效果</li></ul><blockquote><p>引用</p><blockquote><p>引用之引用</p><blockquote><blockquote><p>引用之引用之引用之引用</p></blockquote></blockquote></blockquote></blockquote><h3 id="2-4-分割线"><a href="#2-4-分割线" class="headerlink" title="2.4 分割线"></a>2.4 分割线</h3><p>用三个或三个以上的”-“或”*”表示即可，在使用<code>---</code>分割时注意与上文空行，否则会解析为Setext二级标题。</p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none">***----<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>效果</li></ul><hr><hr><h3 id="2-5-表格"><a href="#2-5-表格" class="headerlink" title="2.5 表格"></a>2.5 表格</h3><ul><li>语法</li></ul><pre class="line-numbers language-none"><code class="language-none">| 表头 | 表头  | 表头 || ---- | :---: | ---: || 内容 | 内容  | 内容 || 内容 | 内容  | 内容 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在第二行分割表头和内容，”-“ 符号至少有一个。<br>当前列的表格内的文字默认居左，在两边加 “:” 表示居中，在右边加 “:” 表示居右。  </p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none">| 省内排名 |         大学         | 全国排名 || :------: | :------------------: | :------: ||    1     |     华中科技大学     |    8     ||    2     |       武汉大学       |    9     ||    3     |     华中农业大学     |    42    ||    4     |     华中师范大学     |    46    ||    5     | 中国地质大学（武汉） |    48    ||    6     |     武汉理工大学     |    55    |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果</li></ul><table><thead><tr><th align="center">省内排名</th><th align="center">大学</th><th align="center">全国排名</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">华中科技大学</td><td align="center">8</td></tr><tr><td align="center">2</td><td align="center">武汉大学</td><td align="center">9</td></tr><tr><td align="center">3</td><td align="center">华中农业大学</td><td align="center">42</td></tr><tr><td align="center">4</td><td align="center">华中师范大学</td><td align="center">46</td></tr><tr><td align="center">5</td><td align="center">中国地质大学（武汉）</td><td align="center">48</td></tr><tr><td align="center">6</td><td align="center">武汉理工大学</td><td align="center">55</td></tr></tbody></table><h3 id="2-6-图片"><a href="#2-6-图片" class="headerlink" title="2.6 图片"></a>2.6 图片</h3><p>插入图片</p><ul><li>格式</li></ul><pre class="line-numbers language-none"><code class="language-none">![alt](图片地址 "title")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当图片加载不出来的时候会显示alt的内容；<br>当鼠标悬停在图片上时，显示title处的内容。<br>alt和title的内容可以不写。</p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none">![](markdown.png)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>效果</li></ul><p><img src="markdown.png"></p><h3 id="2-7-超链接"><a href="#2-7-超链接" class="headerlink" title="2.7 超链接"></a>2.7 超链接</h3><p>在文本中插入超链接后，点击超链接即可跳转到对应的网站。</p><ul><li>语法</li></ul><pre class="line-numbers language-none"><code class="language-none">[超链接名](超链接地址 "title")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>title的含义与图片处解释相同，可以不写。</p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none">[百度](http://baidu.com)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>效果</li></ul><p><a href="http://baidu.com/">百度</a>  </p><h3 id="2-8-列表"><a href="#2-8-列表" class="headerlink" title="2.8 列表"></a>2.8 列表</h3><p>列表分为有序列表和无序列表。</p><h4 id="2-8-1-无序列表"><a href="#2-8-1-无序列表" class="headerlink" title="2.8.1 无序列表"></a>2.8.1 无序列表</h4><ul><li>语法<br>无序列表用 “-“ 、 “+” 、 “*” 任何一种都可以。</li></ul><pre class="line-numbers language-none"><code class="language-none">- 列表内容+ 列表内容* 列表内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意： “-“ 、 “+” 、 “*” 跟内容之间都要有一个空格。</p><ul><li>效果</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><h4 id="2-8-2-有序列表"><a href="#2-8-2-有序列表" class="headerlink" title="2.8.2 有序列表"></a>2.8.2 有序列表</h4><ul><li>语法</li></ul><p>数字加”.”</p><pre class="line-numbers language-none"><code class="language-none">1. 列表内容2. 列表内容3. 列表内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：序号跟内容之间要有空格</p><ul><li>效果</li></ul><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><h4 id="2-8-3-列表的嵌套"><a href="#2-8-3-列表的嵌套" class="headerlink" title="2.8.3 列表的嵌套"></a>2.8.3 列表的嵌套</h4><p>在上一级和下一级之间加三个空格即可。</p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none">1. 列表内容   + 列表内容   + 列表内容2. 列表内容   + 列表内容+ 列表内容   + 列表内容      + 列表内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果</li></ul><ol><li>列表内容<ul><li>列表内容</li><li>列表内容</li></ul></li><li>列表内容<ul><li>列表内容</li></ul></li></ol><ul><li>列表内容<ul><li>列表内容<ul><li>列表内容</li></ul></li></ul></li></ul><h3 id="2-9-代码"><a href="#2-9-代码" class="headerlink" title="2.9 代码"></a>2.9 代码</h3><p>单行代码用两个反引号”`”括起来即可<br>代码块用”```”括起来，且两边的反引号要单独占一行</p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none">`代码内容`(```  代码...  代码...  代码...```)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（这里加括号是为了防止转译，实际上没有）</p><ul><li>效果</li></ul><p><code>代码内容</code></p><pre class="line-numbers language-none"><code class="language-none">代码...代码...代码...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>基本语法如上，它的功能还不止这些，Markdown还可以用来画流程图等等。</p><h2 id="3-Markdown-语法规范"><a href="#3-Markdown-语法规范" class="headerlink" title="3 Markdown 语法规范"></a>3 Markdown 语法规范</h2><p>Markdown 设计之初没有明确的语法规范，随着 Markdown 被更多的人使用，这种不规范直接导致了多种 Markdown 语法的变体，Markdown 解析器也变得混乱，无法统一。</p><p>2017 年 GitHub 发布了 Markdown GFM（GitHub Flavored Markdown） 标准规范，并且修改了 GitHub 的 Markdown 解析器以规范用户行为。</p><h3 id="3-1-语法规范建议"><a href="#3-1-语法规范建议" class="headerlink" title="3.1 语法规范建议"></a>3.1 语法规范建议</h3><p>推荐使用 GitHub GFM 规范。</p><h3 id="3-2-标题格式建议"><a href="#3-2-标题格式建议" class="headerlink" title="3.2 标题格式建议"></a>3.2 标题格式建议</h3><p>推荐使用 ATX 标题规范。<br>文章中尽量避免四级标题，三级标题下的并列内容建议使用列表。</p><h3 id="3-3-空行"><a href="#3-3-空行" class="headerlink" title="3.3 空行"></a>3.3 空行</h3><ul><li>不要有多余的空行<br>在 Markdown 文本中，想要做到渲染后真换行通常是使用两个空格加一个回车换行符，或者粗暴地空一行，但是不要连续空两行及以上。  </li><li>文件末尾空一行<br>强烈建议文件末尾空一行，大多数格式检查工具都会检查文件末尾的空行。文件末尾增加空行的可能原因是为了方便进行文件拼接处理。</li><li>标题前后各空一行  </li></ul><h3 id="3-4-空格"><a href="#3-4-空格" class="headerlink" title="3.4 空格"></a>3.4 空格</h3><ul><li>中英文之间需要增加空格</li><li>中文与数字之间需要增加空格</li><li>数字与单位之间需要增加空格</li><li>全角标点与其他字符之间不加空格</li></ul><h3 id="3-5-标点符号"><a href="#3-5-标点符号" class="headerlink" title="3.5 标点符号"></a>3.5 标点符号</h3><p>不重复使用标点符号</p><h3 id="3-6-全角和半角"><a href="#3-6-全角和半角" class="headerlink" title="3.6 全角和半角"></a>3.6 全角和半角</h3><ul><li>使用全角中文标点</li><li>数字使用半角字符</li><li>遇到完整的英文整句、特殊名词，其内容使用半角标点</li></ul><h3 id="3-7-名词"><a href="#3-7-名词" class="headerlink" title="3.7 名词"></a>3.7 名词</h3><ul><li>专有名词使用正确的大小写</li><li>不要使用不地道的缩写</li></ul><h3 id="3-8-有争议的点"><a href="#3-8-有争议的点" class="headerlink" title="3.8 有争议的点"></a>3.8 有争议的点</h3><p>无论是否遵循下述规则，从语法的角度来讲都是 <strong>正确</strong> 的。</p><ul><li><p>链接之间增加空格</p></li><li><p>加粗、斜体、高亮文本前后加空格</p></li><li><p>列表缩进</p><ul><li>建议使用 4 个空格进行文本缩进，尤其是遇到有序列表或者无序列表的时候。另外，在使用无序列表或者有序列表的时候，建议在上下级之间空一行，同级之间可以不空行。</li></ul></li><li><p>/ 的使用<br>建议 / 字符前后留空格，充当路径描述符的时候除外。</p></li><li><p>简体中文使用直角引号</p></li></ul><p>参考：  </p><ol><li><a href="http://gfm.docschina.org/zh-hans/">GitHub 风格的 Markdown 规范</a></li><li><a href="https://github.com/sparanoid/chinese-copywriting-guidelines">中文文案排版指北</a></li><li><a href="https://zh.wikipedia.org/wiki/Markdown">Markdown - 维基百科</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

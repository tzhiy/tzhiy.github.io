<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>你不知道的JavaScript 上卷</title>
      <link href="/2021/10/17/ni-bu-zhi-dao-de-javascript-shang-juan/"/>
      <url>/2021/10/17/ni-bu-zhi-dao-de-javascript-shang-juan/</url>
      
        <content type="html"><![CDATA[<h1 id="你不知道的-JavaScript-上卷"><a href="#你不知道的-JavaScript-上卷" class="headerlink" title="你不知道的 JavaScript 上卷"></a>你不知道的 JavaScript 上卷</h1><p>详细知识太多太细，这里仅仅只做简要概括总结。</p><h2 id="Part-1-作用域和闭包"><a href="#Part-1-作用域和闭包" class="headerlink" title="Part 1 作用域和闭包"></a>Part 1 作用域和闭包</h2><h3 id="CH1-作用域是什么"><a href="#CH1-作用域是什么" class="headerlink" title="CH1 作用域是什么"></a>CH1 作用域是什么</h3><h4 id="1-1-编译原理"><a href="#1-1-编译原理" class="headerlink" title="1.1 编译原理"></a>1.1 编译原理</h4><p>三步：分词/词法分析、解析/语法分析、代码生成。</p><h4 id="1-2-理解作用域"><a href="#1-2-理解作用域" class="headerlink" title="1.2 理解作用域"></a>1.2 理解作用域</h4><p>参与程序处理的有引擎（程序编译和执行的整个过程）、编译器（语法分析和代码生成）、作用域（确定代码对标识符的访问权限）。</p><p><strong>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。</strong>如果查找的目的是对变量进行赋值，那么就会使用 LHS（Left Hand Search） 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。</p><p>JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声明会被分解成两个独立的步骤：</p><ol><li>首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。 </li><li>接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。</li></ol><h4 id="1-3-作用域嵌套"><a href="#1-3-作用域嵌套" class="headerlink" title="1.3 作用域嵌套"></a>1.3 作用域嵌套</h4><p>LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。 </p><h4 id="1-4-异常"><a href="#1-4-异常" class="headerlink" title="1.4 异常"></a>1.4 异常</h4><p>不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。</p><h3 id="CH2-词法作用域"><a href="#CH2-词法作用域" class="headerlink" title="CH2 词法作用域"></a>CH2 词法作用域</h3><h4 id="2-1-词法阶段"><a href="#2-1-词法阶段" class="headerlink" title="2.1 词法阶段"></a>2.1 词法阶段</h4><p><strong>词法作用域就是定义在词法阶段的作用域。词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。</strong>编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。”遮蔽效应”是指作用域查找会在找到第一个匹配的标识符时停止。</p><h4 id="2-2-欺骗词法"><a href="#2-2-欺骗词法" class="headerlink" title="2.2 欺骗词法"></a>2.2 欺骗词法</h4><p>JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 使用示例</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"var b=2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">with</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。<strong>不要使用它们</strong>。</p><h3 id="CH3-函数作用域和块作用域"><a href="#CH3-函数作用域和块作用域" class="headerlink" title="CH3 函数作用域和块作用域"></a>CH3 函数作用域和块作用域</h3><h4 id="3-1-函数中的作用域"><a href="#3-1-函数中的作用域" class="headerlink" title="3.1 函数中的作用域"></a>3.1 函数中的作用域</h4><p>函数是 JavaScript 中最常见的作用域单元。<strong>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。</strong></p><h4 id="3-2-隐藏内部实现"><a href="#3-2-隐藏内部实现" class="headerlink" title="3.2 隐藏内部实现"></a>3.2 隐藏内部实现</h4><p>本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则——最小特权原则（这个原则是指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来）。</p><h4 id="3-3-函数作用域"><a href="#3-3-函数作用域" class="headerlink" title="3.3 函数作用域"></a>3.3 函数作用域</h4><p>匿名和具名：尽量具名，因为匿名函数调试困难、难以引用、语义较差。</p><p>立即执行函数表达式</p><h4 id="3-4-块作用域"><a href="#3-4-块作用域" class="headerlink" title="3.4 块作用域"></a>3.4 块作用域</h4><p>但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域， 也可以属于某个代码块（通常指 { .. } 内部）。</p><p>从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。 </p><p>在 ES6 中引入了 let 关键字（var 关键字的表亲），用来在任意代码块中声明变量。if  (..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块中。 </p><p>有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。</p><h3 id="CH4-提升"><a href="#CH4-提升" class="headerlink" title="CH4 提升"></a>CH4 提升</h3><p>我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 </p><p>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。 可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。 </p><p>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。 </p><p>要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题！</p><h3 id="CH5-闭包"><a href="#CH5-闭包" class="headerlink" title="CH5 闭包"></a>CH5 闭包</h3><h4 id="5-1-5-3-引入闭包"><a href="#5-1-5-3-引入闭包" class="headerlink" title="5.1 - 5.3 引入闭包"></a>5.1 - 5.3 引入闭包</h4><p>闭包实际上它只是一个标准，就是关于如何在函数作为值按需传递的词法环境中书写代码的。 </p><p>闭包如何产生：<strong>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</strong> </p><p>闭包是什么：函数持有对当前所在词法作用域的引用就是闭包。</p><h4 id="5-4-5-5-循环与模块"><a href="#5-4-5-5-循环与模块" class="headerlink" title="5.4 - 5.5 循环与模块"></a>5.4 - 5.5 循环与模块</h4><p>闭包能的实际应用：如果没能认出闭包，也不了解它的工作原理，在使用它的过程中就很容易犯错，比如在循环中。但同时闭包也是一个非常强大的工具，可以用多种形式来实现模块等模式。 </p><p>模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</p><h2 id="Part-2-this-和对象原型"><a href="#Part-2-this-和对象原型" class="headerlink" title="Part 2 this 和对象原型"></a>Part 2 this 和对象原型</h2><h3 id="CH1-关于-this"><a href="#CH1-关于-this" class="headerlink" title="CH1 关于 this"></a>CH1 关于 this</h3><h4 id="1-1-为什么学-this"><a href="#1-1-为什么学-this" class="headerlink" title="1.1 为什么学 this"></a>1.1 为什么学 this</h4><p>使用 this 可以在不同上下文中使用函数时不用针对每个对象编写不同版本的函数。</p><h4 id="1-2-误解"><a href="#1-2-误解" class="headerlink" title="1.2 误解"></a>1.2 误解</h4><p>学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域，你也许被这样的解释误导过，但其实它们都是错误的。 </p><h4 id="1-3-this-是什么"><a href="#1-3-this-是什么" class="headerlink" title="1.3 this 是什么"></a>1.3 this 是什么</h4><p>this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p><p>this 的上下文取决于函数调用时的各种条件。<strong>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息</strong>。</p><h3 id="CH2-this-全面解析"><a href="#CH2-this-全面解析" class="headerlink" title="CH2 this 全面解析"></a>CH2 this 全面解析</h3><h4 id="2-1-调用位置"><a href="#2-1-调用位置" class="headerlink" title="2.1 调用位置"></a>2.1 调用位置</h4><p>如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置（而不是声明的位置），调用位置取决于<strong>调用栈</strong>。</p><h4 id="2-2-2-3-绑定规则、优先级"><a href="#2-2-2-3-绑定规则、优先级" class="headerlink" title="2.2 - 2.3 绑定规则、优先级"></a>2.2 - 2.3 绑定规则、优先级</h4><p>找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。 </p><ol><li><p><strong>new 绑定</strong>：由 new 调用？绑定到新创建的对象。 </p></li><li><p><strong>显示绑定</strong>：由 call 或者 apply（或者 bind）调用？绑定到指定的对象。 </p></li><li><p>由上下文对象调用？绑定到那个上下文对象。 </p><p><strong>隐式调用</strong>：作为对象方法调用，this 指向这个对象；</p><p>隐式丢失：作为普通函数调用，会应用默认绑定</p></li><li><p><strong>默认绑定</strong>：在严格模式下绑定到 undefined，否则绑定到全局对象。 </p></li></ol><p>显示绑定和 new 绑定在声明情况下会同时使用？可以先用 bind 来传递部分参数，再由 new 绑定完成剩余参数传递。</p><h4 id="2-4-绑定例外"><a href="#2-4-绑定例外" class="headerlink" title="2.4 绑定例外"></a>2.4 绑定例外</h4><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值 在调用时会被忽略。如果函数并不关心 this 的话，你仍然需要传入一个占位值，这时可以选择 null。</p><p>一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。 </p><h4 id="2-5-this-词法"><a href="#2-5-this-词法" class="headerlink" title="2.5 this 词法"></a>2.5 this 词法</h4><p>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这其实和 ES6 之前代码中的 self = this 机制一样。</p><p>使用箭头函数是使用词法作用域风格的代码，使用 bind(…) 改变 this 指向是 this 风格的代码，两种风格最好不要混用。</p><h3 id="CH3-对象"><a href="#CH3-对象" class="headerlink" title="CH3 对象"></a>CH3 对象</h3><h4 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h4><p>JavaScript 中的对象有字面形式（比如 var a = { .. }）和构造形式（比如 var a = new  Array(..)）。字面形式更常用，不过有时候构造形式可以提供更多选项。</p><h4 id="3-2-类型"><a href="#3-2-类型" class="headerlink" title="3.2 类型"></a>3.2 类型</h4><p>许多人都以为“JavaScript 中万物都是对象”，这是错误的。对象是 6 个基础类型（string，number，boolean，null，undefined，object）之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。 </p><h4 id="3-3-内容"><a href="#3-3-内容" class="headerlink" title="3.3 内容"></a>3.3 内容</h4><p>对象就是键 / 值对的集合。可以通过 .propName 或者 [“propName”] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作（在设置属性值时是 [[Put]]）， [[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 [[Prototype]] 链（参见第 5 章）。</p><p>属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用 Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象（及其属性）的不可变性级别。 </p><p>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。 </p><h4 id="3-4-遍历"><a href="#3-4-遍历" class="headerlink" title="3.4 遍历"></a>3.4 遍历</h4><p>你可以使用 ES6 的 for..of 语法来遍历数据结构（数组、对象，等等）中的值，for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</p><h3 id="CH4-混合对象“类”"><a href="#CH4-混合对象“类”" class="headerlink" title="CH4 混合对象“类”"></a>CH4 混合对象“类”</h3><h4 id="4-1-类理论"><a href="#4-1-类理论" class="headerlink" title="4.1 类理论"></a>4.1 类理论</h4><p>类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。JavaScript 也有类似的语法，但是和其他语言中的类完全不同。</p><h4 id="4-2-类的机制"><a href="#4-2-类的机制" class="headerlink" title="4.2 类的机制"></a>4.2 类的机制</h4><p>类意味着复制。</p><p>传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。 </p><h4 id="4-3-类的继承"><a href="#4-3-类的继承" class="headerlink" title="4.3 类的继承"></a>4.3 类的继承</h4><p>多态（在继承链的不同层次名称相同但是功能不同的函数）看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。 </p><p>JavaScript 并不会（像类那样）自动创建对象的副本。 </p><p>混入模式（无论显式还是隐式）可以用来模拟类的复制行为，但是通常会产生丑陋并且脆 弱的语法，比如显式伪多态（OtherObj.methodName.call(this, …)），这会让代码更加难 懂并且难以维护。 </p><h4 id="4-4-混入"><a href="#4-4-混入" class="headerlink" title="4.4 混入"></a>4.4 混入</h4><p>此外，显式混入实际上无法完全模拟类的复制行为，因为对象（和函数！别忘了函数也是对象）只能复制引用，无法复制被引用的对象或者函数本身。忽视这一点会导致许多问题。 </p><p>总地来说，在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋下更多的隐患。</p><h3 id="CH5-原型"><a href="#CH5-原型" class="headerlink" title="CH5 原型"></a>CH5 原型</h3><p>如果要访问对象中并不存在的一个属性，[[Get]] 操作（参见第 3 章）就会查找对象内部 [[Prototype]] 关联的对象。这个关联关系实际上定义了一条“原型链”（有点像嵌套的作用域链），在查找属性时会对它进行遍历。 </p><p>所有普通对象都有内置的 Object.prototype，指向原型链的顶端（比如说全局作用域），如果在原型链中找不到指定的属性就会停止。toString()、valueOf() 和其他一些通用的功能都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们。 </p><p>关联两个对象最常用的方法是使用 new 关键词进行函数调用，在调用的 4 个步骤（第 2 章）中会创建一个关联其他对象的新对象。 </p><p>使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象”。带 new 的函数调用通常被称为“构造函数调用”，尽管它们实际上和传统面向类语言中的类构造函数不一样。</p><p>虽然这些 JavaScript 机制和传统面向类语言中的“类初始化”和“类继承”很相似，但是 JavaScript 中的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。</p><p>出于各种原因，以“继承”结尾的术语（包括“原型继承”）和其他面向对象的术语都无法帮助你理解 JavaScript 的真实机制（不仅仅是限制我们的思维模式）。 </p><p>相比之下，“委托”是一个更合适的术语，因为对象之间的关系不是复制而是委托。</p><h3 id="CH6-行为委托"><a href="#CH6-行为委托" class="headerlink" title="CH6 行为委托"></a>CH6 行为委托</h3><p>在软件架构中你可以选择是否使用类和继承设计模式。大多数开发者理所当然地认为类是唯一（合适）的代码组织方式，但是本章中我们看到了另一种更少见但是更强大的设计模式：行为委托。</p><p>行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制。也就是说，我们可以选择在 JavaScript 中努 力实现类机制（参见第 4 和第 5 章），也可以拥抱更自然的 [[Prototype]] 委托机制。</p><p>当你只用对象来设计代码时，不仅可以让语法更加简洁，而且可以让代码结构更加清晰。</p><p>对象关联（对象之前互相关联）是一种编码风格，它倡导的是直接创建和关联对象，不把 它们抽象成类。对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS 读书笔记</title>
      <link href="/2021/10/15/js-du-shu-bi-ji/"/>
      <url>/2021/10/15/js-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-读书笔记"><a href="#JS-读书笔记" class="headerlink" title="JS 读书笔记"></a>JS 读书笔记</h1><h2 id="1-JavaScript-设计模式与开发实践"><a href="#1-JavaScript-设计模式与开发实践" class="headerlink" title="1. JavaScript 设计模式与开发实践"></a>1. JavaScript 设计模式与开发实践</h2><ul><li><a href="https://tzhiy.github.io/2021/10/11/javascript-she-ji-mo-shi-yu-kai-fa-shi-jian-part-1-ji-chu-zhi-shi/">JavaScript 设计模式与开发实践 part 1 基础知识 | tzhiy’s Blog</a></li></ul><h2 id="2-你不知道的-JavaScript"><a href="#2-你不知道的-JavaScript" class="headerlink" title="2. 你不知道的 JavaScript"></a>2. 你不知道的 JavaScript</h2><ul><li><a href="https://tzhiy.github.io/2021/10/17/ni-bu-zhi-dao-de-javascript-shang-juan/">你不知道的JavaScript 上卷 | tzhiy’s Blog</a></li></ul><h2 id="3-JavaScript-高级语言程序设计"><a href="#3-JavaScript-高级语言程序设计" class="headerlink" title="3. JavaScript 高级语言程序设计"></a>3. JavaScript 高级语言程序设计</h2>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人人都是产品经理</title>
      <link href="/2021/10/15/ren-ren-du-shi-chan-pin-jing-li/"/>
      <url>/2021/10/15/ren-ren-du-shi-chan-pin-jing-li/</url>
      
        <content type="html"><![CDATA[<h1 id="人人都是产品经理"><a href="#人人都是产品经理" class="headerlink" title="人人都是产品经理"></a>人人都是产品经理</h1><p>不知道你有没有听过这样一个词，反人类设计。比方说有些台阶的宽度很奇葩，一步一个太短两步一个又太长。还有 USB 接口，常常要插反一次才能插进去。再比如有些公交车上方栏杆的扶手，对于个子不高的人来说就是个摆设。这些产品总让人感觉世界充满了恶意，这个时候你可能会思考怎么做才能不这么反人类呢？</p><p>恭喜你问出这个问题的时候，你已经向一个产品经理迈进了。</p><p>本书的作者苏杰认为，所谓产品经理就是发现问题并描述清楚问题，然后转化为一个需求，发动一批人，将这个需求完成，并且持续不断的以主人的心态去维护这个产品。像上面的例子中，负责公交车车内设计的人、制造 USB 充电线的人都属于产品经理的岗位范畴。</p><p>不过本书题目里的这个产品经理专指互联网领域的产品岗位。那么互联网行业的产品经理与传统制造业的有什么差别呢？</p><p>首先，在产品<strong>生命周期</strong>上，传统制造业的产品一般来说研发周期和生命周期都比较长。比如一辆汽车研发过程中，有至少三百个需要过程的细节，一般要几年才能完成。成品汽车被买回家以后，也常常要用好多年才会报废。</p><p>但互联网产品不一样。一个 APP 研发周期只需要几个月就够了，而且产品发布和更新迭代的速度也非常快。用户下载和卸载一个 APP，只需要动动手指就完成了生命周期，比传统行业的产品大大缩短。</p><p>此外，传统行业的主要<strong>盈利方式</strong>是销售产品，销售和利润成正比，但互联网产品是虚拟的，多数产品本身是免费供用户使用，赚钱方式多种多样。你比如说会员收费，第三方广告商或者大客户销售等等，盈利模式的不一样，也会对产品有不同的要求。</p><p>由此可见，互联网行业的产品经理相比以往已经发生了非常大的改变。</p><p>那么如何成为一个互联网产品经理，互联网的产品经理有哪些工作内容呢？这就是本书要回答的问题。</p><p>本书作者苏杰，二零零六年，从浙江大学硕士毕业之后，就进入了阿里巴巴做了八年的产品经理。二零一五年以后，他开始担任阿里百川创业基地合伙人。写这本书的时候，正是苏杰在阿里巴巴做产品经理的第四年。此前呢他一直都在自己的博客上记录作为产品清理的工作内容和体验心得，因为内容深入浅出，案例接地气。他的博客小有名气。后来他把博客的内容做了系统的整理和修订以后出版。</p><p>苏杰本人把本书定位为适合负一到三岁产品经理看的书。所谓负一岁也就是还没有入行，但是对产品经理一直非常感兴趣的人。可见这本书是写给还没有入门或者刚刚入门的初级产品经理们的。这本人人都是产品经理，可以说是风靡的圈里，圈外想转行或者毕业以后做产品经理的人，几乎人手一本。</p><p>我把本书内容归纳为三个问题：</p><p>第一，怎样入行成为互联网产品经理？</p><p>第二，初级产品经理的核心工作有哪些？</p><p>第三，初级产品经理如何继续进阶？</p><p>先来看第一个问题，<strong>怎样入行成为一名互联网产品经理</strong>。首先要锻炼和具备两种能力：其一是<strong>从用产品的思维转变为做产品的思维</strong>。其二是要<strong>能够有效的管理资源</strong>。</p><p>所谓<strong>从用产品的思维转变为做产品的思维</strong>，就是说要能够透过现象看本质，透过产品的功能琢磨产品背后的规则、逻辑和长远规划。如果说你一看到产品就忍不住思考它所解决的问题，在生活中一接触到某个事情，就忍不住要思考它深层次的原因，那么你就具备了成为产品经理的潜质。</p><p>另外一项素质要求是<strong>能有效的管理资源</strong>。由于互联网产品需要快速上线，产品经理往往要在各种资源不够的情况下做产品。这些资源包括信息、时间、人和钱。信息不足的时候就会有拍脑袋做决定的时候，时间和人员不足的时候就需要加班加点。钱不够的时候就需要精打细算。而这些状态，特别是互联网产品经理工作的常态。</p><p>这就是成为产品经理的两种基础能力：思维能力和管理资源的能力。事实上，多数人在工作和生活中都有运用。</p><p>所以在苏杰看来，很多人都具备成为产品经理的潜质。那么如何才能真正走到产品经理的岗位上去呢？</p><p>首先要明确自己具备哪些有利条件。比方说你曾经做过教育行业，对在线教育和知识变现行业比较熟悉，那就可以从这个领域的产品经理机会看齐。又或者你曾经做过金融行业，那么就可以尝试一下互联网金融企业的产品经理。</p><p>在苏杰看来，产品经理往往需要一个丰富的背景作为支持，只要能够找到自己的经历背景和产品经历的价值结合点，无论你曾经是做哪一行的，都有机会转行成为产品经理。</p><p>明确了自身优势以后，你就要找到一个入行切入点，最好是从本职工作中与产品经理有关的工作入手。比方说你是一个程序员，那就多参加产品需求的评审；如果你是一个设计师，就要多参与产品交互的设计；如果你是一个运营人员，那就多做一些策划类的工作。这样在面试产品经理的职位的时候，你就能够多一些把握和谈资。此外呢你还可以从周边的职位入手，像产品助理需求分析师等等，慢慢转型成为一个产品经理。</p><p>未来会有越来越多的行业与互联网结合。在苏杰看来，这将是一个巨大的人才市场增量。相应的产品经理的岗位机会也必将会越来越多。</p><p>好了，讲了如何入行，成为一名互联网产品经理。接下来看第二个问题，<strong>初级产品经理的核心工作有哪些</strong>？</p><p>如果我们把做产品的过程比作是装修，那么产品经理的工作就好比是<strong>策划</strong>和<strong>监督</strong>。</p><p>什么意思呢？在装修一栋房子之前，要设计每个装修的细节，类比产品经理的工作呢就是分析用户需求。在装修施工的时候，还需要跟进整个装修的进程。对于产品经理来说就是项目管理。另外装修还有一个繁琐的环节，就是和施工人员打交道，采集物资等等。那对于产品经理来说，那就是要协调团队资源。</p><p><strong>分析需求、管理项目、协调资源</strong>，这三项工作就是一个初级产品经理的日常。下面我来为你逐一讲述。</p><p>咱们先说<strong>分析需求</strong>。分析需求当然指的是用户的需求，可是到底谁才是产品的目标用户呢？有人认为谁给产品掏钱了，就以谁为目标。这其实是一种片面的理解。</p><p>事实上，互联网产品往往有两类用户，一类呢是<strong>使用免费产品的普通用户</strong>，还有一类是会因为种种原因而<strong>为产品付费的用户</strong>。他们实际上是产品的客户。尽管普通用户是免费使用的，但是他们往往占大多数，带来的口碑和流量等传播价值也是非常重要的。所以对于不同产品，目标用户往往会有主次之分。因而，不同时期的产品也会对目标用户会有所侧重。</p><p>你比如说很多产品为了能够获得更好的传播效果，在产品初期往往不惜代价免费提供给所有用户。这种情况下，免费用户就很重要。等到产品后期盈利成为一个重要目标的时候，客户的需求就需要重点考虑了。</p><p>另外还有一个特别的用户，产品经理要注意关注他的需求，那就是<strong>老板</strong>。尤其是很多初创团队初期的时候，往往没有太多资源去理清用户们真正的需求。那这个时候老板很可能就是最接近业务，最了解行业和用户的。所以产品经理应该尽量帮助老板明确产品的方向。</p><p>讲清楚了谁是目标用户以后，接下来很容易遇到一个误区，那就是<strong>用户的意见都要听吗？</strong>对此，苏杰的回答是要听，但不要照着做。</p><p>举个例子，苏杰在做阿里巴巴网店版的时候，经常到淘宝论坛上听取用户的意见。其中有些用户体检的时候经常说啊，你的产品应该做成这个样子。在苏杰看来，这个意见是十分危险的。在听取这些意见的时候，一定要保持清醒。</p><p>比如一个用户提出来在打印快递单的页面里，应该有某个小快递公司的快递单模板。经过苏杰的调查发现，这个小快递公司只服务于某个地区，而不是全国，并且类似的小快递公司还有很多。所以由于个别用户的需求而为所有用户都加上这个需求是非常浪费资源的。最终呢苏杰做了一个自定义快递单的功能，顺利解决这个问题。</p><p>由此可见，当用户提出自己需求的时候，他的表达往往是片面的。而产品经理要做的就是擦亮双眼，找出用户的说法背后真正的深层的需求，进而转化为产品的需求。</p><p>那么<strong>如何把用户的需求变为产品的需求，从而满足用户的需要呢</strong>？</p><p>有这样三种方法，第一，<strong>缺什么补什么</strong>。当然这也是最直接的方法。比如说小明需要某个功能，那么你就给他这个功能。</p><p>第二，<strong>满足用户的最低要求</strong>，这个是比较节省资源的方法。比如说小明想要一个随时在线的客服功能，但是你发现他想要客服功能的本质是因为他偶尔需要一点帮助。于是你给了他一个留言答复的功能，虽然说小明很不爽，但还是凑合着用了。</p><p>第三，就是<strong>转移用户的需求</strong>，这是比较灵活的办法。比如小明想要看小说，小红想要看视频，最终你发现他们的本质需求都是想通过娱乐来消磨时间。于是你给他们上了一款好玩的游戏，虽然不是大伙的初衷，但他们也都是比较满意的。</p><p>最后，产品经理必须要知道，能够活下来的需求永远是少数。在此，作者苏杰告诉我们，如果资源不足以支持你做出一个完整的功能的时候，那么宁可不做，也不能只做一半。产品经理需要着眼于大局，找到那个最具有商业价值性价比最高的用户需求，这样才能够在各种需求产品的 PK 中胜出，从而得到项目团队等资源的支持。</p><p>那这么一系列的动作完整执行下来，<strong>需求分析</strong>就告一段落了。产品经理即将进入下一个环节，<strong>通过项目来实现需求</strong>。这里的项目一般是指针对某一个特定的产品需求进行产品的局部完善。比如说为某个电商 APP 增加一个支付渠道，在一个 P 图应用中增加文字编辑的功能，这些都可以成为一个产品经理的工作项目。</p><p>在这个阶段，产品经理已经迅速转化为项目经理的角色。对于这种转变书上有一句话概括的十分准确。<strong>一个产品经理可能想要增加非常多的功能和特征，满足用户需求。但是项目经理却想要尽可能小的控制工作范围，以保证项目在规定时间和预算内完成</strong>。</p><p>具体来说，项目管理可以分为两个阶段，<strong>计划阶段</strong>和<strong>执行阶段</strong>。</p><p>什么是项目<strong>计划阶段</strong>呢？那就是产品经理就把产品究竟要怎么做，准确的传达给团队中的每一个人。这个时候产品经理就需要写<strong>需求文档</strong>了。这也是产品经理在项目计划阶段最主要的工作内容。</p><p>所谓需求文档，就是对这次项目要解决的功能需求做详细描述。咱们就拿美图 APP 增加文字编辑功能为例，需求文档里面<strong>首先应该写明这个需求的目的是什么？</strong>比如说为了增加用户的表达方式，制作表情包等等。<strong>其次要写明这个功能在产品中的定位和逻辑关系</strong>。比如文字编辑功能是作为流程中一个必要环节，增加进来的用户可以选择不增加文字，但不能绕过这个环节。<strong>之后，要说明这个需求的细节描述</strong>，比如提供的字号、颜色、字体等等。<strong>最后不要忘记后期的数据统计</strong>。针对后期运营中需要统计的点击量使用率等等。记得设置好数据埋点。</p><p>一旦项目计划获得整个项目组的认可以后，那就进入到了执行计划的阶段。这个时候产品经理就可以歇口气了。下面的活儿将由各位团队成员们完成。项目执行过程包括<strong>开发、测试和发布</strong>三个环节。</p><p><strong>开发环节</strong>就是开发经理会带领开发员们按照计划的要求，将产品需求实现为一段一段的代码，并进行自我检查。当开发员认为代码无误之后，就会提交给测试。</p><p><strong>测试环节</strong>中，测试员会通过各种方法检测代码逻辑是不是有误，代码质量是不是过关，测出了各种问题还会返还给开发员修改。</p><p>最后，产品通过了种种验证，就进入到了<strong>发布环节</strong>。这一阶段往往需要一系列负责人员的确认手续。为了避开用户使用的高峰时段，往往会选择在晚间。</p><p>发布实现一个产品流程。就好比一场考试，你需要完成题目，做好检查，然后交卷，等待老师的批阅，等待大家的评判。</p><p>苏杰还提醒说，在管理项目的过程中，必须要有一个心理准备，那就是<strong>在实际工作中，一个项目能够按照项目计划如期的进行下去，是一件非常困难的事情</strong>。在项目推进的过程中，总会存在各种不确定的状况。常见的状况，比如说需求方面的调整，边做边改是一个很无奈也很现实的问题，也总会发生一些紧急状况。你比如说付费流程出现了问题，导致用户买不了商品，那么就要紧急处理这些高优先级的问题。此外呢还有早期评估不到位，从而后期资源不足的现象。比如说一组人员同时进行多个项目的时候，就会产生资源上的冲突。这就像经典的软件项目管理书籍，人月神话里面说的那样，不可能有从头到尾不出现任何问题的软件项目。</p><p>那么面对层出不穷的问题，产品经理应该怎么办呢？</p><p><strong>首先要在项目计划阶段，把那些大大小小的需求目标细化为可操作的实践流程。</strong>咱们还是拿那个为美图 APP 增加文字编辑功能的案例来说。项目的需求目标是增加文字编辑功能，那么这个目标就可以细分为确定基本功能点与产品逻辑关系与设计讨论页面风格与字体。把基本功能点和运营沟通确定页面文案与要素和研发讨论如何在产品中搭载页面，哪几处需要统计数据研发要做好埋点等等。把需求目标细分为流程，并且在流程中确定每个任务的时间节点，这样做项目就可以比较稳定的推进。</p><p><strong>其次要尽可能的控制项目的任务量，让任务推进在敏捷中前行。</strong>比如说项目计划一旦确定，那就尽可能的不再增加额外的需求或功能。宁可把后面要求再加上的内容做下一次的迭代，也不要把当前的项目期限拉长。再比如说不要等所有研发结束再去测试一个功能点出来了，马上做针对性的测试。因为大部分的需求研发都不可能一次成功，尽早发现问题，尽早解决。</p><p>在项目管理中，虽然说产品经理被冠以经理的称号，但事实上并没有哪个团队是归他领导的。产品经理更像是一个中枢系统，协调各种团队资源来帮助你完成一款产品。这些资源包括设计与<strong>运营的内部支持</strong>，<strong>研发团队的技术支持</strong>，以及<strong>商业团队的推广支持</strong>。</p><p>那咱们先来看看<strong>设计与运营的内部支持</strong>。负责用户视觉体验的主要是设计师队伍。通常设计师队伍还会细分为负责操作流程的交互设计师和负责美工的视觉设计师等等。设计师们都是一群追求完美的人，把控的是产品使用上的各种细节问题，和设计师们沟通一定要充分清晰，并且尊重他们的专业度。要是一款产品具有持续的生命力，还需要运营人员不断的推广营销运营的目的就是要把用户带到产品中来。他们常常策划各种爆款活动，吸引新老用户参与。</p><p>运营人员往往会有业绩考核指标，那么为了达标呢，偶尔也会使用一些近乎流氓的手段，而功利性手段和产品最终的目的有时候会发生矛盾。这也是产品和运营人员最容易有分歧的地方，那这个时候不一定是哪一方有过错，只是需要在沟通中互相理解，共同承担责任，平衡好短期效益与长期效益。</p><p>咱们再来说说<strong>研发团队</strong>，研发团队通常会有各种技术分工，比如软件架构师、系统分析师、数据库管理员、开发工程师和测试工程师等等。他们往往是极其理性，喜欢减少不确定性，让工作尽在掌握之中。他们最介意的是由于信息不对等而引发工作量的增加。所以顺畅的沟通是产品经理和研发团队合作中最重要的一环。产品经理最好能懂一点研发的基础知识，以便更有效的沟通和管控项目流程。</p><p>另外还有位于最前线的<strong>商业团队</strong>。对于商业团队来说，最重要的任务就是销售和服务。商业团队直接对接客户。也就是前面讲过的，愿意为了产品付钱的用户。所以说产品经理要做的就是帮助销售人员找到最佳数据和核心卖点。在作者苏杰看来，商业团队能说会道，研发团队严谨周密，而产品团队就是商业团队和研发团队之间的平滑过渡。让业务人员冷静下来，让技术人员兴奋起来，就是产品经理协调能力的核心所在。</p><p>不过书中呢也讲到团队成员的职责界限通常是模糊的。有这么一个段子，一个程序员说我们公司以前没有测试人员，谁开发谁就测试。一个产品经理呢点点头啊，我们公司以前就没有程序员，我就是程序员。接着一个老板点点头，我们公司创业的时候，根本没有产品经理，我就是产品经理，我还要写代码，我还要测试，我还要跑客户公司，就我一个人。相信很多产品经理对这样的状况都会深有同感。新团队的成员们最开始都是全能超人，直到产品具有一定的规模以后，产品队伍才会壮大。有更明确的分工。所以协调团队资源有一个基础的原则，那就是要保证所有事儿都有人做，这个就是协调好团队的关键所在。</p><p>好，我们刚刚讲完了分析需求管理项目和协调团队资源。</p><p>如果我们把产品制作这个过程比作房子的装修，那么装修完成任务就结束了吗？当然不是，还要有人来居住和使用。房子还会发生变化。同样，随着时间的改变，产品的功能需求也会发生变化。那这么一来，产品经理就又要进行新一轮的分析需求，管理项目，协调资源的工作。这就是一个初级产品经理的核心工作。</p><p>那说完第二个问题，接下来看看第三个问题，<strong>初级产品经理如何继续进阶</strong>？</p><p>这本书呢是苏杰做产品经理，做到第四年的时候写的。所以作为一本产品经理的入门书，这本书在进阶这一部分的内容更偏向于方向性和思想性。</p><p>苏杰把产品经理的工作比作一个生态系统，这个生态系统呢有两个宏观的元素，阳光和大地。阳光驱动着整个生态循环，不断进行代表产品<strong>战略思维</strong>，而大地呢则是一切工作最厚重的根基。代表<strong>产品经理的自我修养</strong>。</p><p>咱们先来说说产品<strong>战略思维</strong>。什么是战略思维呢？我接着用居住来打比方，前面呢我把产品经理的日常工作比作房屋装修和维护。但其实啊在这之前还有一个重要的环节，那就是买房子。在这个环节，人们往往需要考虑手里有多少钱，贷款比例控制在多少，房型结构如何，能不能适应未来发展需要。哪些地段的房子有增值的可能，这些问题体现出来的就是战略思维。</p><p>而所谓的<strong>产品战略</strong>呢，就是一个互联网产品的宏观发展方向。简单来说就是<strong>我在哪里</strong>和<strong>我要去哪儿</strong>的问题。</p><p>我在哪里的问题呢？具体来说要弄清楚三点，<strong>所处行业</strong>、<strong>竞争对手</strong>，还有<strong>你自己的状况</strong>。咱们举个例子，如果你要做互联网教育，那么关于教育行业你要清楚有哪些准入门槛儿，国家有哪些鼓励政策，所在地区的教育市场有哪些空白等等。关于竞争对手，你要分析对方的教师队伍，市场品牌定位，想办法了解他们的学员体验、授课质量、制作成本等等，找到竞品的优势和劣势。至于自身，则需要弄清楚，在技术、经验、人脉、资金等方面，我有哪些长处，哪些短板，面临什么样的机会等等。</p><p>我要去哪儿指的就是<strong>产品瞄准的市场是哪里</strong>，<strong>目标用户是谁</strong>，<strong>要涉及到哪些利益关系</strong>，<strong>产品功能定位是什么</strong>等等。你比如说做电子商务，那这个行业的细分领域多如牛毛，需要确定自己是要做奢侈品还是做母婴用品。那相应的目标用户呢就会是。金领用户或者是宝妈用户，还要考虑一些利益相关的角色。除了用户，往往还有供应商、物流大客户和政府部门等等。而你的产品定位。都是建立在所有这些取舍的基础上。当然你可能还没有制定产品战略的机会，那么你也可以从一个完整的优秀产品中反观它的产品战略。从而体会一下老板们的大局观。而一个产品经理从做产品到做产品战略的过程，也是从方法论走向价值观的过程。</p><p>好，那说完产品战略，再来说说<strong>产品经理的自我修养</strong>。</p><p>在这一方面，苏杰特别强调了观察能力对产品经理自我修养的重要性。苏杰举例说，他有一个朋友非常善于观察疙瘩饭店大门的设计，有的门对着收银台吃饭，流程很顺畅，很受老顾客的欢迎。有的门和消费类型不符，小吃店用高档门令很多新顾客望而却步。有的门呢出入的时候弯弯绕绕，帮助顾客多的返点，分散人流。那么由此可见，什么样的门就决定着留下什么样的顾客。同样的，在产品工作中，你想要留住目标用户，也要符合他们的习惯。生活中处处都有产品的细节，善于观察的人，通常思路更宽，思维更活，也只有积极观察生活的人，才能保有好奇心和创造力，而这些品质正是创造产品的源泉。</p><p>人人都是产品经理，可谓是作者苏杰在工作和生活中悟出的一句箴言。在苏杰看来。<strong>产品经理是一类人，他们骨子里想要改变世界，不断的用看待产品的眼光去思考，去做事，最终形成一套思想和一种态度。那就叫做产品经理主义。</strong></p><p>参考：</p><p><a href="https://www.bilibili.com/video/BV1ia4y1Y7sv">经管 《人人都是产品经理》：一本书讲清楚如何入门产品经理 bilibili</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>人人都是产品经理 读书笔记</title>
      <link href="/2021/10/15/ren-ren-du-shi-chan-pin-jing-li-du-shu-bi-ji/"/>
      <url>/2021/10/15/ren-ren-du-shi-chan-pin-jing-li-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>思维导图：</p><p><img src="image-20211015221149794.png" alt="image-20211015221149794"></p><p>“产品经理之路”的部分展开如下：</p><p><img src="image-20211015215736475.png" alt="image-20211015215736475"></p><h1 id="《人人都是产品经理》读书笔记"><a href="#《人人都是产品经理》读书笔记" class="headerlink" title="《人人都是产品经理》读书笔记"></a>《人人都是产品经理》读书笔记</h1><p>—— 软件 1902 陶志远</p><h2 id="一、开始读书之前"><a href="#一、开始读书之前" class="headerlink" title="一、开始读书之前"></a>一、开始读书之前</h2><p>在看这本书之前，我们可以思考一下什么是产品经理。在日常生活中，我们有时候会看到一些设计不合理的事情，比如说 USB 插口，我们（几乎）每次使用都会插反一次才能再插进去；学校这学期新装的一系列减速带，让很多骑自行车的同学骑过一条路都要被它们磕到很多次。这些设计让我们感受到这个世界充满了恶意，我们会思考怎么才能设计一个更好的方案解决这些问题？</p><p>其实这些思维就已经在靠近产品经理这个职业了。产品经理就是发现问题并描述清楚问题，然后转化为一个需求，发动一批人，将这个需求完成，并且持续不断的以主人的心态去维护这个产品。</p><p>在互联网行业，产品经理与传统行业有所区别。在产品生命周期上，互联网行业的产品一般来说研发周期和生命周期都比较短。在盈利方式方面，互联网赚钱的方式多种多样。</p><p>作者在这本书中以深入浅出的案例告诉我们如何成为一个互联网产品经理，互联网的产品经理有哪些工作内容。这本书的定位是写给还没有入门或者刚刚入门的初级产品经理们的。</p><h2 id="二、产品经理之路"><a href="#二、产品经理之路" class="headerlink" title="二、产品经理之路"></a>二、产品经理之路</h2><p>如何成为产品经理？这本书可以归纳为三个方面：怎样入行成为互联网产品经理？初级产品经理的核心工作有哪些？初级产品经理如何继续进阶？下面我从这三个方面来分别说说我的理解。</p><h3 id="1-怎样入行成为互联网产品经理"><a href="#1-怎样入行成为互联网产品经理" class="headerlink" title="1. 怎样入行成为互联网产品经理"></a>1. 怎样入行成为互联网产品经理</h3><p>成为一名互联网产品经理。首先要锻炼和具备两种能力：其一是<strong>从用产品的思维转变为做产品的思维</strong>。其二是<strong>要能够有效的管理资源</strong>。所谓从用产品的思维转变为做产品的思维，就是说要能够透过现象看本质，透过产品的功能琢磨产品背后的规则、逻辑和长远规划。另外一项素质要求是能有效的管理资源。由于互联网产品需要快速上线，产品经理往往要在各种资源不够的情况下做产品。这些资源包括信息、时间、人和钱。这就是成为产品经理的两种基础能力：思维能力和管理资源的能力。事实上，多数人在工作和生活中都有运用。</p><p>很多人都具备成为产品经理的潜质。那么如何才能真正走到产品经理的岗位上去呢？<strong>首先要明确自己具备哪些有利条件</strong>。产品经理往往需要一个丰富的背景作为支持，只要能够找到自己的经历背景和产品经历的价值结合点，无论你曾经是做哪一行的，都有机会转行成为产品经理。<strong>明确了自身优势以后，你就要找到一个入行切入点</strong>，最好是从本职工作中与产品经理有关的工作入手。这样在面试产品经理的职位的时候，你就能够多一些把握和谈资。此外呢你还可以从周边的职位入手，像产品助理需求分析师等等，慢慢转型成为一个产品经理。</p><h3 id="2-初级产品经理的核心工作有哪些"><a href="#2-初级产品经理的核心工作有哪些" class="headerlink" title="2. 初级产品经理的核心工作有哪些"></a>2. 初级产品经理的核心工作有哪些</h3><p><strong>分析需求、管理项目、协调资源</strong>，这三项工作就是一个初级产品经理的日常。</p><p>分析需求当然指的是用户的需求，可是到底谁才是产品的目标用户呢？互联网产品往往有两类用户，一类呢是<strong>使用免费产品的普通用户</strong>，还有一类是会因为种种原因而<strong>为产品付费的用户</strong>。尽管普通用户是免费使用的，但是他们往往占大多数，带来的口碑和流量等传播价值也是非常重要的。</p><p>另外还有一个特别的用户，产品经理要注意关注他的需求，那就是<strong>老板</strong>。尤其是很多初创团队初期的时候，往往没有太多资源去理清用户们真正的需求。那这个时候老板很可能就是最接近业务，最了解行业和用户的。所以产品经理应该尽量帮助老板明确产品的方向。</p><p><strong>用户的意见都要听吗？</strong>要听，但不要照着做。当用户提出自己需求的时候，他的表达往往是片面的。而产品经理要做的就是擦亮双眼，找出用户的说法背后真正的深层的需求，进而转化为产品的需求。</p><p><strong>如何把用户的需求变为产品的需求，从而满足用户的需要呢？</strong>有三种方法。</p><p>第一，<strong>缺什么补什么</strong>。这种方法最直接。比如说小明需要某个功能，那么你就给他这个功能。</p><p>第二，<strong>满足用户的最低要求</strong>，这个是比较节省资源的方法。比如说小明想要一个随时在线的客服功能，但是你发现他想要客服功能的本质是因为他偶尔需要一点帮助。于是你给了他一个留言答复的功能，虽然说小明很不爽，但还是凑合着用了。</p><p>第三，就是<strong>转移用户的需求</strong>，这是比较灵活的办法。比如小明想要看小说，小红想要看视频，最终你发现他们的本质需求都是娱乐。于是你给他们上了一款好玩的游戏，虽然不是大伙的初衷，但他们也都是比较满意的。</p><p><strong>需求分析</strong>之后。产品经理即将进入下一个环节，<strong>通过项目来实现需求</strong>。</p><p>一个产品经理可能想要增加非常多的功能和特征，满足用户需求。但是项目经理却想要尽可能小的控制工作范围，以保证项目在规定时间和预算内完成。</p><p>项目管理可以分为两个阶段，<strong>计划阶段</strong>和<strong>执行阶段</strong>。</p><p>计划阶段就是产品经理就把产品究竟要怎么做，准确的传达给团队中的每一个人。这个时候产品经理就需要写需求文档了。这也是产品经理在项目计划阶段最主要的工作内容。</p><p>一旦项目计划获得整个项目组的认可以后，那就进入到了执行计划的阶段。这个时候产品经理就可以歇口气了。下面的活儿将由各位团队成员们完成。项目执行过程包括<strong>开发、测试和发布</strong>三个环节。</p><p>在实际工作中，一个项目能够按照项目计划如期的进行下去，是一件非常困难的事情。那么面对层出不穷的问题，产品经理应该怎么办呢？首先要在项目计划阶段，把那些大大小小的需求目标细化为可操作的实践流程。其次要尽可能的控制项目的任务量，让任务推进在敏捷中前行。</p><p>在项目管理中，虽然说产品经理被冠以经理的称号，但事实上并没有哪个团队是归他领导的。产品经理更像是一个中枢系统，协调各种团队资源来帮助你完成一款产品。这些资源包括设计与<strong>运营的内部支持</strong>，<strong>研发团队的技术支持</strong>，以及<strong>商业团队的推广支持</strong>。</p><h3 id="3-初级产品经理如何继续进阶"><a href="#3-初级产品经理如何继续进阶" class="headerlink" title="3. 初级产品经理如何继续进阶"></a>3. 初级产品经理如何继续进阶</h3><p>作者把产品经理的工作比作一个生态系统，这个生态系统呢有两个宏观的元素，阳光和大地。阳光驱动着整个生态循环，不断进行代表产品<strong>战略思维</strong>，而大地则是一切工作最厚重的根基，代表<strong>产品经理的自我修养</strong>。</p><p>什么是战略思维呢？所谓的<strong>产品战略</strong>，就是一个互联网产品的宏观发展方向。简单来说就是<strong>我在哪里</strong>和<strong>我要去哪儿</strong>的问题。</p><p>我在哪里的问题呢？具体来说要弄清楚三点，<strong>所处行业</strong>、<strong>竞争对手</strong>，还有<strong>自己的状况</strong>。如果你要做互联网教育，那么关于教育行业你要清楚有哪些准入门槛儿，国家有哪些鼓励政策，所在地区的教育市场有哪些空白等等。关于竞争对手，你要分析对方的教师队伍，市场品牌定位，想办法了解他们的学员体验、授课质量、制作成本等等，找到竞品的优势和劣势。至于自身，则需要弄清楚，在技术、经验、人脉、资金等方面，我有哪些长处，哪些短板，面临什么样的机会等等。</p><p>我要去哪儿指的就是<strong>产品瞄准的市场是哪里</strong>，<strong>目标用户是谁</strong>，<strong>要涉及到哪些利益关系</strong>，<strong>产品功能定位是什么</strong>等等。比如说做电子商务，那这个行业的细分领域多如牛毛，需要确定自己是要做奢侈品还是做母婴用品。那相应的目标用户呢就会是。金领用户或者是宝妈用户，还要考虑一些利益相关的角色。除了用户，往往还有供应商、物流大客户和政府部门等等。而你的产品定位。都是建立在所有这些取舍的基础上。当然你可能还没有制定产品战略的机会，那么你也可以从一个完整的优秀产品中反观它的产品战略。从而体会一下老板们的大局观。而一个产品经理从做产品到做产品战略的过程，也是从方法论走向价值观的过程。</p><p><strong>产品经理的自我修养</strong>又是什么？在这一方面，作者特别强调了<strong>观察能力</strong>对产品经理自我修养的重要性。作者举例说，他有一个朋友非常善于观察疙瘩饭店大门的设计，有的门对着收银台吃饭，流程很顺畅，很受老顾客的欢迎。有的门和消费类型不符，小吃店用高档门令很多新顾客望而却步。有的门呢出入的时候弯弯绕绕，帮助顾客多的返点，分散人流。那么由此可见，什么样的门就决定着留下什么样的顾客。同样的，在产品工作中，你想要留住目标用户，也要符合他们的习惯。生活中处处都有产品的细节，善于观察的人，通常思路更宽，思维更活，也只有积极观察生活的人，才能保有好奇心和创造力，而这些品质正是创造产品的源泉。</p><h2 id="三、读完书的思考"><a href="#三、读完书的思考" class="headerlink" title="三、读完书的思考"></a>三、读完书的思考</h2><p>读完这本书之后我发现，本书的书名“人人都是产品经理”可以说是作者在工作和生活中悟出的一句箴言。在作者看来，<strong>产品经理是一类人，他们骨子里想要改变世界，不断的用看待产品的眼光去思考，去做事，最终形成一套思想和一种态度。那就叫做产品经理主义。</strong></p><p>在读这本书的过程中，有人在课程群里问“我不想当产品经理需要读这本书吗？”，在这里我的理解是：需要。这本书提到过产品经理应该爱生活、有理想、会思考、能沟通。我相信<strong>这些能力都会在互联网行业或者是在任何行业都需要得到体现</strong>。我们作为互联网人，需要抱着这个态度去不断学习新的事物，同时保持敏锐的观察力和独立思考的能力，这样才能在互联网浪潮中保持自己的初心。</p><p>参考：</p><p><a href="https://tzhiy.github.io/2021/10/15/ren-ren-du-shi-chan-pin-jing-li/">人人都是产品经理 | tzhiy’s Blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 产品经理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 设计模式与开发实践 part 1 基础知识</title>
      <link href="/2021/10/11/javascript-she-ji-mo-shi-yu-kai-fa-shi-jian-part-1-ji-chu-zhi-shi/"/>
      <url>/2021/10/11/javascript-she-ji-mo-shi-yu-kai-fa-shi-jian-part-1-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="1-面向对象的-JavaScript"><a href="#1-面向对象的-JavaScript" class="headerlink" title="1 面向对象的 JavaScript"></a>1 面向对象的 JavaScript</h2><p>JavaScript 中没有提供传统的面向对象语言中的类式继承，而是通过原型委托的方式来实现对象之间的继承，JavaScript 也没有在语言层面提供对抽象类和接口的支持。</p><h3 id="1-1-动态类型语言和鸭子类型"><a href="#1-1-动态类型语言和鸭子类型" class="headerlink" title="1.1 动态类型语言和鸭子类型"></a>1.1 动态类型语言和鸭子类型</h3><p>编译语言可分为<strong>静态类型语言</strong>和<strong>动态类型语言</strong>。静态类型语言在编译时就已经确定变量的类型，而动态类型语言在程序运行时变量被赋予某个值之后才知道变量的类型。</p><p>这两种语言各有优缺点。静态类型语言在编译时就能够发现类型不匹配的错误，以便让编译器帮我们提前避免；并且知道了变量的类型之后，编译器可以针对这些信息进行性能优化，提高程序执行速度。缺点就是在编写的过程中会迫使程序员按照强契约编写程序，并且增加程序的代码量，分散程序员的注意力。</p><p>动态类型语言的有点是代码量少，使程序员精力集中，这样可以专注于逻辑表达，帮助阅读理解。缺点就是无法保证变量的类型。</p><p>JavaScript 作为动态类型语言无需进行类型检测，我们在调用对象的方法时不需要考虑它有没有这个方法。</p><p><strong>鸭子模型</strong>告诉我们要关注对象的行为而不是对象的本身。根据鸭子模型我们可以在动态类型语言中实现“<strong>面向接口编程，而不是面向实现编程</strong>”。比如说有一个对象的方法可以正确地实现需要的功能，我们就可以使用这个对象的方法。</p><h3 id="1-2-多态"><a href="#1-2-多态" class="headerlink" title="1.2 多态"></a>1.2 多态</h3><h4 id="1-JavaScript-的多态"><a href="#1-JavaScript-的多态" class="headerlink" title="1 JavaScript 的多态"></a>1 JavaScript 的多态</h4><p><strong>多态</strong>可以理解为复数形态，意思是同一个操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。</p><p>多态背后的思想就是将“做什么”与“谁去做以及去怎么做”分离开来，也就是将“不变的事物”与“可能改变的事物分离开来”。这样的程序是可生长的，符合<strong>开放封闭原则</strong>（软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的），相对于修改代码，增加代码来实现同样的功能更加安全。</p><p>要实现多态，实际先要消除类型之间的耦合关系。在 Java 这种静态类型语言中，我们想要消除类型之间的耦合关系需要通过<strong>向上转型</strong>来实现多态：当给一个类变量赋值时，变量即可以使用这个类本身，还可以使用这个类的超类。而在 JavaScript 中，变量类型在运行期可变，这告诉我们 JavaScript 对象的多态性是与生俱来的，不存在“类型耦合”。</p><h4 id="2-多态在面向对象设计中的作用"><a href="#2-多态在面向对象设计中的作用" class="headerlink" title="2 多态在面向对象设计中的作用"></a>2 多态在面向对象设计中的作用</h4><p>多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。每个对象应该做什么成为该对象的一个方法被安装在对象的内部，每个对象负责它们自己的行为，这正是面向对象设计的优点。</p><p>在 JavaScript 中，函数是一等对象，函数可以封装行为并四处传递，不同函数返回不同值也是多态性的一种体现。</p><h3 id="1-3-封装"><a href="#1-3-封装" class="headerlink" title="1.3 封装"></a>1.3 封装</h3><p><strong>封装</strong>的目的是将信息隐藏。</p><h4 id="1-封装数据"><a href="#1-封装数据" class="headerlink" title="1 封装数据"></a>1 封装数据</h4><p>在许多语言的对象系统中，封装数据是由语法解析来实现的，这些语言也许提供了 private、  public、protected 等关键字来提供不同的访问权限。</p><p>在 JavaScript 中，我们只能依赖变量的作用域来实现封装特性，而且只能模拟出 public 和 private 这两种封装性。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">var</span> __name <span class="token operator">=</span> <span class="token string">'sven'</span><span class="token punctuation">;</span> <span class="token comment">// 私有（private）变量</span><span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token function-variable function">getName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 公开（public）方法</span><span class="token keyword">return</span> __name<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> myObject<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：sven </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> myObject<span class="token punctuation">.</span>__name <span class="token punctuation">)</span> <span class="token comment">// 输出：undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-封装实现"><a href="#2-封装实现" class="headerlink" title="2 封装实现"></a>2 封装实现</h4><p>封装的目的是将信息隐藏，封装应该被视为“任何形式的封装”，也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。</p><p>封装的主要目的其实是使对象内部的实现细节对外部不可见，使得对象之间的耦合度变松散，只通过暴露的 API 进行通信。修改一个对象时，我们可以随意修改它的内部实现，对外部的接口没有变化就不会影响它的其他功能。</p><h4 id="3-封装类型"><a href="#3-封装类型" class="headerlink" title="3 封装类型"></a>3 封装类型</h4><p>封装类型是静态类型语言中一种重要的封装方式。一般而言，封装类型是通过抽象类和接口来进行的。</p><p>在 JavaScript 中，并没有对抽象类和接口的支持。JavaScript 本身也是一门<strong>类型模糊的语言</strong>。在封装类型方面，JavaScript 没有能力，也没有必要做得更多。</p><h4 id="4-封装变化"><a href="#4-封装变化" class="headerlink" title="4 封装变化"></a>4 封装变化</h4><p>通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，我们只需要替换那些容易变化的部分。当我们想办法把程序中变化的部分封装好之后，剩下的即是稳定而可复用的部分了。</p><h3 id="1-4-原型模式和基于原型继承的-JavaScript-对象系统"><a href="#1-4-原型模式和基于原型继承的-JavaScript-对象系统" class="headerlink" title="1.4 原型模式和基于原型继承的 JavaScript 对象系统"></a>1.4 原型模式和基于原型继承的 JavaScript 对象系统</h3><p>在以类为中心的面向对象编程语言中，类和对象的关系可以想象成铸模和铸件的关系，对象总是从类中创建而来。而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。</p><h4 id="1-使用克隆的原型模式"><a href="#1-使用克隆的原型模式" class="headerlink" title="1 使用克隆的原型模式"></a>1 使用克隆的原型模式</h4><p>从设计模式的角度讲，<strong>原型模式</strong>是用于创建对象的一种模式，如果我们想要创建一个对象，一种方法是先指定它的类型，然后通过类来创建这个对象。原型模式选择了另外一种方式，我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。</p><h4 id="2-克隆是创建对象的手段"><a href="#2-克隆是创建对象的手段" class="headerlink" title="2 克隆是创建对象的手段"></a>2 克隆是创建对象的手段</h4><p>原型模式的真正目的并非在于需要得到一个一模一样的对象，而是提供了一种便捷的方式去创建某个类型的对象，克隆只是创建这个对象的过程和手段。</p><p>在用 Java 等静态类型语言编写程序的时候，类型之间的解耦非常重要。依赖倒置原则提醒我们创建对象的时候要避免依赖具体类型，而用 new XXX 创建对象的方式显得很僵硬。</p><p>原型模式提供了另外一种创建对象的方式，通过克隆对象，我们就不用再关心对象的具体类型名字。</p><p>JavaScript 就是使用原型模式来搭建整个面向对象系统的。<strong>在 JavaScript 语言中不存在类的概念，对象也并非从类中创建出来的，所有的 JavaScript 对象都是从某个对象上克隆而来的。</strong></p><h4 id="3-原型编程范型的一些规则"><a href="#3-原型编程范型的一些规则" class="headerlink" title="3 原型编程范型的一些规则"></a>3 原型编程范型的一些规则</h4><ul><li><p>所有的数据都是对象。</p></li><li><p>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。</p></li><li><p>对象会记住它的原型。</p></li><li><p>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。</p></li></ul><h4 id="4-JavaScript中的原型继承"><a href="#4-JavaScript中的原型继承" class="headerlink" title="4 JavaScript中的原型继承"></a>4 JavaScript中的原型继承</h4><ol><li><p>所有的数据都是对象</p><p>JavaScript 中绝大部分数据都是对象，JavaScript 中的根对象是 Object.prototype 对象。Object.prototype 对象是一个空的对象。我们在 JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的，Object.prototype 对象就是它们的<strong>原型</strong>。</p></li><li><p>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</p><p>在 JavaScript 语言里，我们并不需要关心克隆的细节，因为这是引擎内部负责实现的。我们所需要做的只是显式地调用 <code>var obj1 = new Object()</code> 或者 <code>var obj2 = {}</code>。此时，引擎内部会从 Object.prototype 上面克隆一个对象出来，我们最终得到的就是这个对象。 </p></li><li><p>对象会记住它的原型</p><p>如果请求可以在一个链条中依次往后传递，那么每个节点都必须知道它的下一个节点。同理， 要完成 Io 语言或者 JavaScript 语言中的原型链查找机制，每个对象至少应该先记住它自己的原型。 </p><p>目前我们一直在讨论“对象的原型”，就 JavaScript 的真正实现来说，其实并不能说对象有原型，而只能说对象的构造器有原型。对于“对象把请求委托给它自己的原型”这句话，更好的说法是对象把请求委托给它的构造器的原型。</p></li><li><p>如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型</p><p>这条规则即是原型继承的精髓所在。从对 Io 语言的学习中，我们已经了解到，当一个对象无法响应某个请求的时候，它会顺着原型链把请求传递下去，直到遇到一个可以处理该请求的对象为止。</p><p>而在 JavaScript 中，每个对象都是从 Object.prototype 对象克隆而来的，如果是这样的话， 我们只能得到单一的继承关系，即每个对象都继承自 Object.prototype 对象，这样的对象系统显然是非常受限的。</p><p>实际上，虽然 JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的，但对象构造器的原型并不仅限于 Object.prototype 上，而是可以动态指向其他对象。这样一来，当对象 a 需要借用对象 b 的能力时，可以有选择性地把对象 a 的构造器的原型指向对象 b，从而达到继承的效果。</p></li></ol><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h4><p>ECMAScript 6 带来了新的 Class 语法。这让 JavaScript 看起来像是一门基于类的语言， 但其背后仍是通过原型机制来创建对象。</p><p>本节讲述了本书的第一个设计模式——原型模式。原型模式是一种设计模式，也是一种编程泛型，它构成了 JavaScript 这门语言的根本。</p><h2 id="2-this、-call-和-apply"><a href="#2-this、-call-和-apply" class="headerlink" title="2 this、 call 和 apply"></a>2 this、 call 和 apply</h2><h3 id="2-1-this"><a href="#2-1-this" class="headerlink" title="2.1 this"></a>2.1 this</h3><p>跟别的语言大相径庭的是，JavaScript 的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。</p><h4 id="1-this-的指向"><a href="#1-this-的指向" class="headerlink" title="1 this 的指向"></a>1 this 的指向</h4><p>this 的指向大致可以分为以下 4 种：</p><ol><li><p>作为对象的方法调用</p><p>当函数作为对象的方法被调用时，this 指向该对象。</p></li><li><p>作为普通函数调用</p><p>当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象。</p></li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js">window<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'globalName'</span><span class="token punctuation">;</span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function-variable function">getA</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">alert</span> <span class="token punctuation">(</span> <span class="token keyword">this</span> <span class="token operator">===</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：true </span><span class="token function">alert</span> <span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: 1 </span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> obj<span class="token punctuation">.</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 作为对象的方法调用 this === obj</span><span class="token keyword">var</span> getA <span class="token operator">=</span> obj<span class="token punctuation">.</span>getA<span class="token punctuation">;</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 作为普通函数调用 this === "globalName"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><p>构造器调用</p><p>JavaScript 中没有类，但是可以从构造器中创建对象，同时也提供了 new 运算符，使得构造器看起来更像一个类。</p><p>除了宿主提供的一些内置函数，大部分 JavaScript 函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象。</p></li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">MyClass</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'sven'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">alert</span> <span class="token punctuation">(</span> obj<span class="token punctuation">.</span>name <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：sven </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">MyClass</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'sven'</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token comment">// 显式地返回一个对象</span>     name<span class="token operator">:</span> <span class="token string">'anne'</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">alert</span> <span class="token punctuation">(</span> obj<span class="token punctuation">.</span>name <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：anne </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">MyClass</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'sven'</span>     <span class="token keyword">return</span> <span class="token string">'anne'</span><span class="token punctuation">;</span> <span class="token comment">// 返回 string 类型</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">alert</span> <span class="token punctuation">(</span> obj<span class="token punctuation">.</span>name <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：sven </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><p>Function.prototype.call 或 Function.prototype.apply 调用</p><p>跟普通的函数调用相比，用 call 或 apply 可以动态地改变传入函数的 this。</p></li></ol><h4 id="2-丢失的-this"><a href="#2-丢失的-this" class="headerlink" title="2 丢失的 this"></a>2 丢失的 this</h4><p>若是普通函数调用方式，this 是指向全局 window 的，我们可以用 Function.prototype.call 或 Function.prototype.apply 可以动态地改变传入函数的 this。</p><h3 id="2-2-call-和-apply"><a href="#2-2-call-和-apply" class="headerlink" title="2.2 call 和 apply"></a>2.2 call 和 apply</h3><h4 id="1-call-和-apply-的区别"><a href="#1-call-和-apply-的区别" class="headerlink" title="1 call 和 apply 的区别"></a>1 call 和 apply 的区别</h4><p>Function.prototype.call 和 Function.prototype.apply 都是非常常用的方法。它们的作用一模一样，区别仅在于传入参数形式的不同。 </p><p>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</p><p>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</p><p>两种方法如何选择？当调用一个函数时，JavaScript 的解释器并不会计较形参和实参在数量、类型以及顺序上的区别，JavaScript 的参数在内部就是用一个数组来表示的。从这个意义上说，apply 比 call 的使用率更高。</p><p>call 是包装在 apply 上面的一颗语法糖，如果我们明确地知道函数接受多少个参数，而且想一目了然地表达形参和实参的对应关系，那么也可以用 call 来传送参数。</p><p>当使用 call 或者 apply 的时候，如果我们传入的第一个参数为 null，函数体内的 this 会指向默认的宿主对象。但如果是在严格模式下，函数体内的 this 还是为 null。</p><h4 id="2-call-和-apply-的用途"><a href="#2-call-和-apply-的用途" class="headerlink" title="2 call 和 apply 的用途"></a>2 call 和 apply 的用途</h4><ol><li><p>改变 this 指向</p><p>call 和 apply 最常见的用途是改变函数内部的 this 指向。</p></li><li><p>Function.prototype.bind</p></li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">context</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 保存原函数</span><span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 返回一个新的函数</span><span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> context<span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 执行新的函数的时候，会把之前传入的 context</span>        <span class="token comment">// 当作新函数体内的 this </span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   我们通过 Function.prototype.bind 来“包装” func 函数，并且传入一个对象 context 当作参数，这个 context 对象就是我们想修正的 this 对象。</p><ol start="3"><li><p>借用其他对象的方法</p><p>借用方法的第一种场景是“借用构造函数”，通过这种技术，可以实现一些类似继承的效果。</p><p>借用方法的第二种运用场景跟我们的关系更加密切。 函数的参数列表 arguments 是一个类数组对象，虽然它也有“下标”，但它并非真正的数组， 所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。这种情况下，我们常常会借用 Array.prototype 对象上的方法，比如想往 arguments 中添加一个新的元素，通常会借用 Array.prototype.push。</p></li></ol><h2 id="3-闭包和高阶函数"><a href="#3-闭包和高阶函数" class="headerlink" title="3 闭包和高阶函数"></a>3 闭包和高阶函数</h2><h3 id="3-1-闭包"><a href="#3-1-闭包" class="headerlink" title="3.1 闭包"></a>3.1 闭包</h3><p><strong>闭包</strong>的形成与变量的作用域以及变量的生存周期密切相关。</p><h4 id="1-变量的作用域"><a href="#1-变量的作用域" class="headerlink" title="1 变量的作用域"></a>1 变量的作用域</h4><p>变量的作用域，就是指变量的有效范围。</p><p>当在函数中声明一个变量的时候，如果该变量前面没有带上关键字 var，这个变量就会成为全局变量；用 var 关键字在函数中声明变量，这时候的变量即是局部变量，只有在该函数内部才能访问到这个变量，在函数外面是访问不到的。</p><p>为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。</p><h4 id="2-变量的生存周期"><a href="#2-变量的生存周期" class="headerlink" title="2 变量的生存周期"></a>2 变量的生存周期</h4><p>对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。</p><p>而对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>a<span class="token operator">++</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当执行 <code>var f = func();</code> 时，f 返回了一个匿名函数的引用，它可以访问到 func() 被调用时产生的环境，而局部变量 a 一直处在这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起 来被延续了。</p><h4 id="3-闭包的更多作用"><a href="#3-闭包的更多作用" class="headerlink" title="3 闭包的更多作用"></a>3 闭包的更多作用</h4><ol><li>封装变量<br>闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> <span class="token function-variable function">mult</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// cache...</span><span class="token punctuation">}</span>    <span class="token comment">// =&gt;</span><span class="token keyword">var</span> mult <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment">// cache...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来， 我们常常把这些代码块封装在独立的小函数里面。如果这些小函数不需要在程序的其他 地方使用，最好是把它们用闭包封闭起来。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> mult <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">var</span> cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">var</span> <span class="token function-variable function">calculate</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 封闭 calculate 函数var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ){ a = a * arguments[i]; } return a; }; return function(){ var args = Array.prototype.join.call( arguments, ',' ); if ( args in cache ){ return cache[ args ]; }return cache[ args ] = calculate.apply( null, arguments ); } })(); </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li><p>延续局部变量的寿命</p><p>由于函数调用介绍后，局部变量随即被销毁，我们可以把变量用闭包封闭起来，解决丢失的问题。</p></li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> report <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">var</span> imgs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">src</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">var</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  imgs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> img <span class="token punctuation">)</span><span class="token punctuation">;</span>  img<span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-闭包和面向对象设计"><a href="#4-闭包和面向对象设计" class="headerlink" title="4 闭包和面向对象设计"></a>4 闭包和面向对象设计</h4><p>过程与数据的结合是形容面向对象中的“对象”时经常使用的表达。对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。通常用面向对象思想能实现的功能，用闭包也能实现。</p><h4 id="5-用闭包实现命令模式"><a href="#5-用闭包实现命令模式" class="headerlink" title="5 用闭包实现命令模式"></a>5 用闭包实现命令模式</h4><p>命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者（执行者）之间的耦合关系。在命令被执行之前，可以预先往命令对象中植入命令的接收者。</p><p>在 JavaScript 中，函数作为一等对象，本身就可以四处传递，用函数对象而不是普通对象来封装请求显得更加简单和自然。如果需要往函数对象中预先植入命令的接收者，那么闭包可以完成这个工作。在面向对象版本的命令模式中，预先植入的命令接收者被当成对象的属性保存起来；而在闭包版本的命令模式中，命令接收者会被封闭在闭包形成的环境中。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 面向对象版本的命令模式OpenTvCommand.prototype.execute = function(){      this.receiver.open(); // 执行命令，打开电视机}; OpenTvCommand.prototype.undo = function(){      this.receiver.close(); // 撤销命令，关闭电视机}; // 闭包版本的命令模式var createCommand = function( receiver ){ var execute = function(){ return receiver.open(); // 执行命令，打开电视机} var undo = function(){ return receiver.close(); // 执行命令，关闭电视机} return { execute: execute, undo: undo } }; </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="6-闭包与内存管理"><a href="#6-闭包与内存管理" class="headerlink" title="6 闭包与内存管理"></a>6 闭包与内存管理</h4><p>局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设为 null。</p><h3 id="3-2-高阶函数"><a href="#3-2-高阶函数" class="headerlink" title="3.2 高阶函数"></a>3.2 高阶函数</h3><p>高阶函数是指至少满足下列条件之一的函数。</p><ol><li>函数可以作为参数被传递； </li><li>函数可以作为返回值输出。</li></ol><p>以下是一些高阶函数的应用场景：</p><h4 id="1-函数作为参数传递"><a href="#1-函数作为参数传递" class="headerlink" title="1 函数作为参数传递"></a>1 函数作为参数传递</h4><ol><li><p>回调函数</p><p>在 ajax 异步请求的应用中，回调函数的使用非常频繁。当我们想在 ajax 请求返回之后做一 些事情，但又并不知道请求返回的确切时间时，最常见的方案就是把 callback 函数当作参数传入 发起 ajax 请求的方法中，待请求完成之后执行 callback 函数。</p><p>回调函数的应用不仅只在异步请求中，当一个函数不适合执行一些请求时，我们也可以把这 些请求封装成一个函数，并把它作为参数传递给另外一个函数，“委托”给另外一个函数来执行。</p></li><li><p>Array.prototype.sort</p><p>Array.prototype.sort 接受一个函数当作参数，这个函数里面封装了数组元素的排序规则。从 Array.prototype.sort 的使用可以看到，我们的目的是对数组进行排序，这是不变的部分；而使 用什么规则去排序，则是可变的部分。把可变的部分封装在函数参数里，动态传入 Array.prototype.sort，使 Array.prototype.sort 方法成为了一个非常灵活的方法</p></li></ol><h4 id="2-函数作为返回值输出"><a href="#2-函数作为返回值输出" class="headerlink" title="2 函数作为返回值输出"></a>2 函数作为返回值输出</h4><p>让函数继续返回一个可执行的函数，意味着运算过程是可延续的。</p><ol><li><p>判断数据的类型</p></li><li><p>getSingle</p></li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">getSingle</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span> <span class="token parameter">fn</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">var</span> ret<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ret <span class="token operator">||</span> <span class="token punctuation">(</span> ret <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arguments <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   这个高阶函数的例子，既把函数当作参数传递，又让函数执行后返回了另外一个函数。</p><h4 id="3-高阶函数实现AOP"><a href="#3-高阶函数实现AOP" class="headerlink" title="3 高阶函数实现AOP"></a>3 高阶函数实现AOP</h4><h4 id="4-高阶函数的其他应用"><a href="#4-高阶函数的其他应用" class="headerlink" title="4 高阶函数的其他应用"></a>4 高阶函数的其他应用</h4><ol><li><p>currying</p><p>currying 又称部分求值。一个 currying 的函数首先会接受一些参数，接受了这些参数之后， 该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。</p></li><li><p>uncurrying</p><p><strong>柯里化</strong>，是固定部分参数，返回一个接受剩余参数的函数，也称为部分计算函数，目的是为了缩小适用范围，创建一个针对性更强的函数。核心思想是把多参数传入的函数拆成单参数（或部分）函数，内部再返回调用下一个单参数（或部分）函数，依次处理剩余的参数。</p><p>而<strong>反柯里化</strong>，从字面讲，意义和用法跟函数柯里化相比正好相反，扩大适用范围，创建一个应用范围更广的函数。使本来只有特定对象才适用的方法，扩展到更多的对象。</p></li><li><p>函数节流</p><p>在一些少数情况下，函数的触发不是由用户直接控制的。在这些场景下，函数有可能被非常频繁地调用，而造成大的性能问题。</p><ol><li><p>函数被频繁调用的场景</p><p>window.onresize 事件、 mousemove 事件、 上传进度。</p></li><li><p>函数节流的原理</p><p>我们需要按时间段来忽略掉一些事件请求，可以借助 setTimeout 来完成这件事情。</p></li></ol></li><li><p>分时函数</p><p>某些函数确实是用户主动调用的，但因为一些客观的原因，这些函数会严重地影响页面性能。解决方案之一是下面的 timeChunk 函数，timeChunk 函数让创建节点的工作分批进行。</p></li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">timeChunk</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">ary<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> count</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">var</span> obj<span class="token punctuation">,</span> t<span class="token punctuation">;</span> <span class="token keyword">var</span> len <span class="token operator">=</span> ary<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token keyword">var</span> <span class="token function-variable function">start</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span> count <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">,</span> ary<span class="token punctuation">.</span>length <span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">var</span> obj <span class="token operator">=</span> ary<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fn</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> t <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> ary<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 如果全部节点都已经被创建好return clearInterval( t ); } start(); }, 200 ); // 分批执行的时间间隔，也可以用参数的形式传入}; };</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li><p>惰性加载函数</p><p>在 Web 开发中，因为浏览器之间的实现差异，一些嗅探工作总是不可避免。</p></li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">addEvent</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">elem<span class="token punctuation">,</span> type<span class="token punctuation">,</span> handler</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> window<span class="token punctuation">.</span>addEventListener <span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token function-variable function">addEvent</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">elem<span class="token punctuation">,</span> type<span class="token punctuation">,</span> handler</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>      elem<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span> type<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> window<span class="token punctuation">.</span>attachEvent <span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token function-variable function">addEvent</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">elem<span class="token punctuation">,</span> type<span class="token punctuation">,</span> handler</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>      elem<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span> <span class="token string">'on'</span> <span class="token operator">+</span> type<span class="token punctuation">,</span> handler <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   此时 addEvent 依然被声明为一个普通函数，在函数里依然有一些分支判断。但是在第一次进入条件分支之后，在函数内部会重写这个函数，重写之后的函数就是我们期望的 addEvent 函数，在下一次进入 addEvent 函数的时候，addEvent 函数里不再存在条件分支语句。</p><h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><p>就设计模式而言，因为 JavaScript 这门语言的自身特点， 许多设计模式在 JavaScript 之中的实现跟在一些传统面向对象语言中的实现相差很大。在 JavaScript 中，很多设计模式都是通过闭包和高阶函数实现的。这并不奇怪，相对于模式的实现过程，我们更关注的是模式可以帮助我们完成什么。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端基础知识</title>
      <link href="/2021/10/11/qian-duan-ji-chu-zhi-shi/"/>
      <url>/2021/10/11/qian-duan-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="前端基础知识"><a href="#前端基础知识" class="headerlink" title="前端基础知识"></a>前端基础知识</h1><p>参考路线：<a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">前端基础知识</a></p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions#Web_mechanics">常见问题 - 学习 Web 开发 | MDN (mozilla.org)</a></p><p>互联网、网站、URL、域名、网络服务器、超链接</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 基础 笔记整合（共 6 篇）</title>
      <link href="/2021/09/03/js-ji-chu-bi-ji-zheng-he/"/>
      <url>/2021/09/03/js-ji-chu-bi-ji-zheng-he/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-基础-笔记整合（共-6-篇）"><a href="#JS-基础-笔记整合（共-6-篇）" class="headerlink" title="JS 基础 笔记整合（共 6 篇）"></a>JS 基础 笔记整合（共 6 篇）</h1><ul><li><p>JavaScript</p><ol><li><p><a href="https://tzhiy.github.io/2021/08/13/js-ji-chu-yu-fa/">JS 基础 变量、函数、对象 | tzhiy’s Blog</a></p></li><li><p><a href="https://tzhiy.github.io/2021/08/14/js-ji-chu-dom/#toc-heading-24">JS 基础 DOM | tzhiy’s Blog</a></p></li></ol><p> ​       对页面元素或节点的增删改查和属性修改</p><ol start="3"><li><p><a href="https://blog.csdn.net/Augenstern_QXL/article/details/115406408">JS 基础 BOM（引用自：Augenstern_QXL的博客）</a></p><p>window 对象常见事件、定时器、JS 执行机制、location 对象、navgation 对象、history 对象</p></li><li><p><a href="https://blog.csdn.net/Augenstern_QXL/article/details/115219073">JS 面向对象（引用自：Augenstern_QXL的博客）</a></p><p>面向对象、构造函数和原型、继承、ES5 新增方法（数组、字符串、对象方法）、函数进阶（定义、调用、this 指向）</p></li><li><p><a href="https://blog.csdn.net/Augenstern_QXL/article/details/115344398">JS ES6 基础内容（引用自：Augenstern_QXL的博客）</a></p><p>严格模式、高阶函数、闭包、深拷贝和浅拷贝、正则表达式</p></li></ol></li><li><p>JSON </p><ol><li><p><a href="https://javascript.ruanyifeng.com/stdlib/json.html#">JSON对象 – JavaScript 标准参考教程（alpha） (ruanyifeng.com)</a></p><p>JSON 格式、JSON 对象、JSON.stringify()、JSON.parse()</p></li></ol></li><li><p>AJAX</p><ol><li><p><a href="http://javascript.ruanyifeng.com/bom/ajax.html">AJAX – JavaScript 标准参考教程（alpha） (ruanyifeng.com)</a></p><p>AJAX简介、XMLHttpRequest 属性、XMLHttpRequest 方法、XMLHttpRequest 实例、文件上传</p></li><li><p><a href="https://www.runoob.com/ajax/ajax-tutorial.html">AJAX 教程 | 菜鸟教程 (runoob.com)</a></p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 整合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础 &amp; UI设计</title>
      <link href="/2021/08/15/byte1-css-ji-chu/"/>
      <url>/2021/08/15/byte1-css-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础"><a href="#CSS-基础" class="headerlink" title="CSS 基础"></a>CSS 基础</h1><h2 id="1-CSS-是啥"><a href="#1-CSS-是啥" class="headerlink" title="1 CSS 是啥"></a>1 CSS 是啥</h2><h3 id="1-1-CSS-诞生背景"><a href="#1-1-CSS-诞生背景" class="headerlink" title="1.1 CSS 诞生背景"></a>1.1 CSS 诞生背景</h3><h3 id="1-2-CSS-基础规则"><a href="#1-2-CSS-基础规则" class="headerlink" title="1.2 CSS 基础规则"></a>1.2 CSS 基础规则</h3><h2 id="2-CSS-怎么学"><a href="#2-CSS-怎么学" class="headerlink" title="2 CSS 怎么学"></a>2 CSS 怎么学</h2><h3 id="2-1-免费课程"><a href="#2-1-免费课程" class="headerlink" title="2.1 免费课程"></a>2.1 免费课程</h3><h3 id="2-2-持续学习"><a href="#2-2-持续学习" class="headerlink" title="2.2 持续学习"></a>2.2 持续学习</h3><h2 id="3-CSS-常用规则"><a href="#3-CSS-常用规则" class="headerlink" title="3 CSS 常用规则"></a>3 CSS 常用规则</h2><h3 id="3-1-布局相关"><a href="#3-1-布局相关" class="headerlink" title="3.1 布局相关"></a>3.1 布局相关</h3><h3 id="3-2-装饰相关"><a href="#3-2-装饰相关" class="headerlink" title="3.2 装饰相关"></a>3.2 装饰相关</h3><h2 id="4-CSS-精益求精"><a href="#4-CSS-精益求精" class="headerlink" title="4 CSS 精益求精"></a>4 CSS 精益求精</h2><h3 id="4-1-CSS-调试"><a href="#4-1-CSS-调试" class="headerlink" title="4.1 CSS 调试"></a>4.1 CSS 调试</h3><h3 id="4-2-CSS-扩展"><a href="#4-2-CSS-扩展" class="headerlink" title="4.2 CSS 扩展"></a>4.2 CSS 扩展</h3><h3 id="4-3-CSS-革新"><a href="#4-3-CSS-革新" class="headerlink" title="4.3 CSS 革新"></a>4.3 CSS 革新</h3>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> UI </tag>
            
            <tag> YOUTHCAMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 基础</title>
      <link href="/2021/08/15/byte1-html-ji-chu/"/>
      <url>/2021/08/15/byte1-html-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-基础"><a href="#HTML-基础" class="headerlink" title="HTML 基础"></a>HTML 基础</h1><h2 id="1-网页三大元素"><a href="#1-网页三大元素" class="headerlink" title="1 网页三大元素"></a>1 网页三大元素</h2><h2 id="2-HTML-简介"><a href="#2-HTML-简介" class="headerlink" title="2 HTML 简介"></a>2 HTML 简介</h2><h2 id="3-HTML-结构"><a href="#3-HTML-结构" class="headerlink" title="3 HTML 结构"></a>3 HTML 结构</h2><h2 id="4-常用元素"><a href="#4-常用元素" class="headerlink" title="4 常用元素"></a>4 常用元素</h2><h2 id="5-语义化"><a href="#5-语义化" class="headerlink" title="5 语义化"></a>5 语义化</h2><h3 id="5-1-语义化-区块"><a href="#5-1-语义化-区块" class="headerlink" title="5.1 语义化-区块"></a>5.1 语义化-区块</h3><h3 id="5-2-语义化-分组"><a href="#5-2-语义化-分组" class="headerlink" title="5.2 语义化-分组"></a>5.2 语义化-分组</h3><h3 id="5-3-语义化-文本"><a href="#5-3-语义化-文本" class="headerlink" title="5.3 语义化-文本"></a>5.3 语义化-文本</h3><h2 id="6-多媒体元素"><a href="#6-多媒体元素" class="headerlink" title="6 多媒体元素"></a>6 多媒体元素</h2><h2 id="7-HTML-解析"><a href="#7-HTML-解析" class="headerlink" title="7 HTML 解析"></a>7 HTML 解析</h2>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> YOUTHCAMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节青训营 课程笔记整合 （共 18 篇，更新中...）</title>
      <link href="/2021/08/15/zi-jie-qing-xun-ying-ke-cheng-bi-ji/"/>
      <url>/2021/08/15/zi-jie-qing-xun-ying-ke-cheng-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="字节青训营-课程笔记整合-（共-18-篇，更新中…）"><a href="#字节青训营-课程笔记整合-（共-18-篇，更新中…）" class="headerlink" title="字节青训营 课程笔记整合 （共 18 篇，更新中…）"></a>字节青训营 课程笔记整合 （共 18 篇，更新中…）</h1><ul><li><p>HTML 基础</p><p><a href="https://tzhiy.github.io/2021/08/15/byte1-html-ji-chu/">HTML 基础 | tzhiy’s Blog</a></p></li><li><p>CSS 基础</p><p><a href="https://tzhiy.github.io/2021/08/15/byte1-css-ji-chu/">CSS 基础 | tzhiy’s Blog</a></p></li><li><p>UI 设计</p><p><a href="https://www.yuque.com/shenyangdong/kb/gk2bw1#nqjxs">给开发看的 UI 设计 · 语雀 (yuque.com)</a></p></li><li><p>跟着月影学 JavaScript</p></li><li><p>Web 标准与前端开发</p></li><li><p>前端必须知道的开发调试知识</p></li><li><p>TypeScript 入门</p></li><li><p>React 实战</p></li><li><p>前端动画实现</p></li><li><p>Node.js 基础入门</p></li><li><p>Node.js 实践</p></li><li><p>Web 开发的安全之旅</p></li><li><p>HTTP 使用指南</p></li><li><p>前端进阶指南之前端工程化</p></li><li><p>JavaScript 中的设计模式</p></li><li><p>小程序开发入门</p></li><li><p>走进 Web 多媒体技术</p></li><li><p>不同技术框架的游戏实现</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
            <tag> UI </tag>
            
            <tag> YOUTHCAMP </tag>
            
            <tag> 整合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础 笔记整合（共 11 篇）</title>
      <link href="/2021/08/15/css-ji-chu-bi-ji-zheng-he/"/>
      <url>/2021/08/15/css-ji-chu-bi-ji-zheng-he/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础-笔记整合-（共-11-篇）"><a href="#CSS-基础-笔记整合-（共-11-篇）" class="headerlink" title="CSS 基础 笔记整合 （共 11 篇）"></a>CSS 基础 笔记整合 （共 11 篇）</h1><p>对以前的笔记进行了整理。</p><ul><li><p><a href="https://tzhiy.github.io/2021/07/19/css-1-7/">CSS 基础总结 1/7 | tzhiy’s Blog</a></p><p>CSS 简介、基础选择器、字体属性、文本属性、CSS 引入方式</p></li><li><p><a href="https://tzhiy.github.io/2021/07/20/css-2-7/">CSS 基础总结 2/7 | tzhiy’s Blog</a></p><p>Emmet 语法、CSS 三大特性</p></li><li><p><a href="https://tzhiy.github.io/2021/07/20/css-3-7/">CSS 基础总结 3/7 | tzhiy’s Blog</a></p><p>盒子模型、圆角边框、盒子阴影、文字阴影</p></li><li><p><a href="https://tzhiy.github.io/2021/07/22/css-4-7/">CSS 基础总结 4/7 | tzhiy’s Blog</a></p><p>浮动、常见网页布局、清除浮动</p></li><li><p><a href="https://tzhiy.github.io/2021/07/23/css-5-7/">CSS 基础总结 5/7 | tzhiy’s Blog</a></p><p>学成在线案例</p></li><li><p><a href="https://tzhiy.github.io/2021/07/29/css-6-7/#toc-heading-13">CSS 基础总结 6/7 | tzhiy’s Blog</a></p><p>定位、网页布局总结、元素的显示与隐藏</p></li><li><p><a href="https://tzhiy.github.io/2021/07/31/css-7-7/">CSS 基础总结 7/7 | tzhiy’s Blog</a></p><p>精灵图、字体图标、三角、用户界面样式、vertical-align 属性样式、溢出文字省略号显示、常见布局技巧、CSS 初始化</p></li><li><p><a href="https://tzhiy.github.io/2021/07/31/html5css3-ti-gao/#toc-heading-13">HTML5 和 CSS3 提高 | tzhiy’s Blog</a></p><p>HTML5 新特性：语义化标签、多媒体标签、新 input 类型、 新表单属性</p><p>CSS3 新特性：属性选择器、结构伪类选择器、伪元素选择器、盒子模型、transition 过渡</p></li><li><p>其他补充：</p><ol><li>flex 布局 <a href="https://juejin.cn/post/6844903586841755655">Flex-弹性布局原来如此简单</a></li><li>grid 布局 <a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></li><li>transition 和 animation <a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html">CSS动画简介 - 阮一峰的网络日志 (ruanyifeng.com)</a></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
            <tag> 整合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 基础 DOM</title>
      <link href="/2021/08/14/js-ji-chu-dom/"/>
      <url>/2021/08/14/js-ji-chu-dom/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-基础-DOM"><a href="#JS-基础-DOM" class="headerlink" title="JS 基础 DOM"></a>JS 基础 DOM</h1><h2 id="1-DOM-简介"><a href="#1-DOM-简介" class="headerlink" title="1 DOM 简介"></a>1 DOM 简介</h2><p>文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言（HTML或者XML）的标准编程接口。</p><p>W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。</p><img src="image-20210814144234682.png" alt="image-20210814144234682" style="zoom:80%;"><ul><li>文档：一个页面就是一个文档，DOM 中使用 doucument  来表示</li><li>元素：页面中的所有标签都是元素，DOM中使用 element 表示</li><li>节点：网页中的所有内容都是节点（标签，属性，文本，注释等），DOM中使用node表示</li></ul><p>DOM 把以上内容都看做是对象</p><h2 id="2-获取元素"><a href="#2-获取元素" class="headerlink" title="2 获取元素"></a>2 获取元素</h2><h3 id="2-1-根据ID获取"><a href="#2-1-根据ID获取" class="headerlink" title="2.1 根据ID获取"></a>2.1 根据ID获取</h3><p><code>getElementByld()</code> 返回带ID的元素对象</p><pre class="line-numbers language-none"><code class="language-none">doucument.getElementByld('id名')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>console.dir()</code> 可以打印我们获取的元素对象</p><h3 id="2-2-根据标签名获取"><a href="#2-2-根据标签名获取" class="headerlink" title="2.2 根据标签名获取"></a>2.2 根据标签名获取</h3><p><code>getElementByTagName()</code> 返回带有标签名的<strong>对象的集合</strong></p><pre class="line-numbers language-none"><code class="language-none">doucument.getElementsByTagName('标签名');//或者根据标签名获取父元素内部所有指定标签名的子元素ol.getElementsByTagName('li');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>返回的是获取过来元素对象的集合，以伪数组的形式存储</p><h3 id="2-3-通过H5新增方法获取"><a href="#2-3-通过H5新增方法获取" class="headerlink" title="2.3 通过H5新增方法获取"></a>2.3 通过H5新增方法获取</h3><table><thead><tr><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>document.getElementsByClassName('类名')</code></td><td align="center">根据类名返回元素对象合集</td></tr><tr><td align="center"><code>document.querySelector('选择器');</code></td><td align="center">根据指定选择器返回第一个元素对象</td></tr><tr><td align="center"><code>document.querySelectorAll('选择器');</code></td><td align="center">根据指定选择器返回所有元素对象</td></tr></tbody></table><p><code>querySelector</code> 和 <code>querySelectorAll</code> 里面的选择器需要加符号,比如: <code>document.querySelector('#nav');</code></p><h3 id="2-4-获取特殊元素"><a href="#2-4-获取特殊元素" class="headerlink" title="2.4 获取特殊元素"></a>2.4 获取特殊元素</h3><table><thead><tr><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>document.body;</code></td><td align="center">返回body元素对象</td></tr><tr><td align="center"><code>document.documentElement;</code></td><td align="center">返回html元素对象</td></tr></tbody></table><h2 id="3-事件基础"><a href="#3-事件基础" class="headerlink" title="3 事件基础"></a>3 事件基础</h2><p>触发-响应机制。</p><h3 id="3-1-执行步骤"><a href="#3-1-执行步骤" class="headerlink" title="3.1 执行步骤"></a>3.1 执行步骤</h3><ol><li>获取事件源</li><li>注册事件(绑定事件)</li><li>添加事件处理程序(采取函数赋值形式)</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;    // 1. 获取事件源    var div = document.querySelector('div');    // 2. 绑定事件 注册事件    // div.onclick     // 3. 添加事件处理程序     div.onclick = function() {        console.log('我被选中了');    }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-鼠标事件"><a href="#3-2-鼠标事件" class="headerlink" title="3.2 鼠标事件"></a>3.2 鼠标事件</h3><table><thead><tr><th align="center">鼠标事件</th><th align="center">触发条件</th></tr></thead><tbody><tr><td align="center">onclick</td><td align="center">鼠标点击左键触发</td></tr><tr><td align="center">onmouseover</td><td align="center">鼠标经过触发</td></tr><tr><td align="center">onmouseout</td><td align="center">鼠标离开触发</td></tr><tr><td align="center">onfocus</td><td align="center">获得鼠标焦点触发</td></tr><tr><td align="center">onblur</td><td align="center">失去鼠标焦点触发</td></tr><tr><td align="center">onmousemove</td><td align="center">鼠标移动触发</td></tr><tr><td align="center">onmouseup</td><td align="center">鼠标弹起触发</td></tr><tr><td align="center">onmousedown</td><td align="center">鼠标按下触发</td></tr></tbody></table><h2 id="4-操作元素"><a href="#4-操作元素" class="headerlink" title="4 操作元素"></a>4 操作元素</h2><p>我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。</p><h3 id="4-1-元素内容"><a href="#4-1-元素内容" class="headerlink" title="4.1 元素内容"></a>4.1 元素内容</h3><pre class="line-numbers language-none"><code class="language-none">element.innerText//从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉。element.innerHTML//起始位置到终止位置的全部内容，包括HTML标签，同时保留空格和换行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-元素属性"><a href="#4-2-元素属性" class="headerlink" title="4.2 元素属性"></a>4.2 元素属性</h3><pre class="line-numbers language-none"><code class="language-none">// 元素.属性img.src = "xxx";input.value = "xxx";input.type = "xxx";input.checked = "xxx";input.selected = true / false;input.disabled = true / false;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-样式属性"><a href="#4-3-样式属性" class="headerlink" title="4.3 样式属性"></a>4.3 样式属性</h3><ol><li>行内样式</li></ol><pre class="line-numbers language-none"><code class="language-none">// element.stylediv.style.backgroundColor = 'pink';div.style.width = '250px';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>类名样式</li></ol><pre class="line-numbers language-none"><code class="language-none">// element.className<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div class="first"&gt;文本&lt;/div&gt;    &lt;script&gt;        // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用        var test = document.querySelector('div');        test.onclick = function() {            // this.style.backgroundColor = 'purple';            // 让我们当前元素的类名改为了 change            // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况            // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器            // this.className = 'change';            this.className = 'first change';        }    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-自定义属性"><a href="#4-4-自定义属性" class="headerlink" title="4.4 自定义属性"></a>4.4 自定义属性</h3><ol><li>获取属性值</li></ol><pre class="line-numbers language-none"><code class="language-none">//获取内置属性值(元素本身自带的属性)element.属性;//获取自定义的属性或内置属性值element.getAttribute('属性');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>设置属性值</li></ol><pre class="line-numbers language-none"><code class="language-none">//设置内置属性值element.属性 = '值';//设置自定义的属性或内置属性值element.setAttribute('属性');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>移除属性值</li></ol><pre class="line-numbers language-none"><code class="language-none">element.removeAttribute('属性');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>自定义属性目的：</li></ol><ul><li>保存并保存数据，有些数据可以保存到页面中而不用保存到数据库中</li><li>有些自定义属性很容易引起歧义，不容易判断到底是内置属性还是自定义的，所以H5有了规定</li></ul><ol start="5"><li>设置自定义属性</li></ol><p>H5规定自定义属性 <code>data-</code>开头作为属性名并赋值</p><pre class="line-numbers language-none"><code class="language-none">&lt;div data-index = "1"&gt;&lt;/&gt;// 或者使用JavaScript设置div.setAttribute('data-index',1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li>获取自定义属性</li></ol><ul><li>兼容性获取 <code>element.getAttribute('data-index')</code></li><li>H5新增的：<code>element.dataset.index</code> 或<code>element.dataset['index']</code> IE11才开始支持</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div getTime="20" data-index="2" data-list-name="andy"&gt;&lt;/div&gt;    &lt;script&gt;        var div = document.querySelector('div');        console.log(div.getAttribute('getTime'));        div.setAttribute('data-time', 20);        console.log(div.getAttribute('data-index'));        console.log(div.getAttribute('data-list-name'));        // h5新增的获取自定义属性的方法 它只能获取data-开头的        // dataset 是一个集合里面存放了所有以data开头的自定义属性        console.log(div.dataset);        console.log(div.dataset.index);        console.log(div.dataset['index']);        // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法        console.log(div.dataset.listName);        console.log(div.dataset['listName']);    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-节点"><a href="#5-节点" class="headerlink" title="5 节点"></a>5 节点</h2><h3 id="5-1-节点概述"><a href="#5-1-节点概述" class="headerlink" title="5.1 节点概述"></a>5.1 节点概述</h3><p>网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。</p><p>HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。</p><img src="image-20210814144234682.png" alt="image-20210814144234682" style="zoom: 80%;"><p>一般的，节点至少拥有 nodeType（节点类型）、nodeName（节点名称）和 nodeValue（节点值）这三个基本属性。</p><ul><li>元素节点：nodeType 为1</li><li>属性节点：nodeType 为2</li><li>文本节点：nodeType 为3（文本节点包括文字、空格、换行等）</li></ul><p>我们在实际开发中，节点操作主要操作的是<strong>元素节点</strong></p><p>利用 DOM 树可以把节点划分为不同的层级关系，常见的是<strong>父子兄层级关系</strong>。</p><h3 id="5-2-父节点"><a href="#5-2-父节点" class="headerlink" title="5.2 父节点"></a>5.2 父节点</h3><pre class="line-numbers language-none"><code class="language-none">node.parentNode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-3-子节点"><a href="#5-3-子节点" class="headerlink" title="5.3 子节点"></a>5.3 子节点</h3><pre class="line-numbers language-none"><code class="language-none">parentNode.childNodes //返回所有的子节点的集合parentNode.children //返回所有的子元素节点的集合，常用parentNode.firstChild //所有子节点中的第一个子结点parentNode.lastChild //所有子节点中的最后一个子结点parentNode.firstElementChild //所有子节点中的第一个子元素结点，兼容性parentNode.lastElementChild //所有子节点中的最后一个子元素结点，兼容性//由于一些兼容性问题，我们可以用以下方法返回第一个和最后一个子元素节点：parentNode.chilren[0]parentNode.chilren[parentNode.chilren.length - 1]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-4-兄弟节点"><a href="#5-4-兄弟节点" class="headerlink" title="5.4 兄弟节点"></a>5.4 兄弟节点</h3><pre class="line-numbers language-none"><code class="language-none">node.nextSibling //下一个兄弟节点node.previousSibling //上一个兄弟节点node.nextElementSibling //下一个兄弟元素节点，兼容性node.previousElementSibling //上一个兄弟节点，兼容性//可以自己封装函数解决兼容性问题function getNextElementSibling(element) {    var el = element;    while(el = el.nextSibling) {        if(el.nodeType === 1){            return el;        }    }    return null;}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-5-创建节点"><a href="#5-5-创建节点" class="headerlink" title="5.5 创建节点"></a>5.5 创建节点</h3><h4 id="5-5-1-添加节点"><a href="#5-5-1-添加节点" class="headerlink" title="5.5.1 添加节点"></a>5.5.1 添加节点</h4><pre class="line-numbers language-none"><code class="language-none">node.appendChild() 方法将一个节点添加到指定父节点的子节点列表末尾。node.insertBefore() 方法将一个节点添加到父节点的指定子节点前面<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-5-2-删除节点"><a href="#5-5-2-删除节点" class="headerlink" title="5.5.2 删除节点"></a>5.5.2 删除节点</h4><pre class="line-numbers language-none"><code class="language-none">node.removeChild(child)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-5-3-复制节点"><a href="#5-5-3-复制节点" class="headerlink" title="5.5.3 复制节点"></a>5.5.3 复制节点</h4><pre class="line-numbers language-none"><code class="language-none">node.cloneNode()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果括号参数为空或者为 false ，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点</li><li>如果括号参数为 true ，则是深度拷贝，会复制节点本身以及里面所有的子节点</li></ul><h2 id="6-DOM-核心"><a href="#6-DOM-核心" class="headerlink" title="6 DOM 核心"></a>6 DOM 核心</h2><p>对于DOM操作，我们主要针对子元素的操作，主要有：</p><h3 id="6-1-创建"><a href="#6-1-创建" class="headerlink" title="6.1 创建"></a>6.1 创建</h3><ol><li>document.write</li><li>innerHTML</li><li>createElement</li></ol><h3 id="6-2-增"><a href="#6-2-增" class="headerlink" title="6.2 增"></a>6.2 增</h3><ol><li>appendChild</li><li>insertBefore</li></ol><h3 id="6-3-删"><a href="#6-3-删" class="headerlink" title="6.3 删"></a>6.3 删</h3><ol><li>removeChild</li></ol><h3 id="6-4-改"><a href="#6-4-改" class="headerlink" title="6.4 改"></a>6.4 改</h3><ol><li>修改元素属性：src、href、title 等</li><li>修改普通元素内容：innerHTML、innerText</li><li>修改表单元素：value、type、disabled</li><li>修改元素样式：style、className</li></ol><h3 id="6-5-查"><a href="#6-5-查" class="headerlink" title="6.5 查"></a>6.5 查</h3><ol><li>DOM提供的API方法：getElementById、getElementsByTagName (方法较老，不推荐)</li><li><strong>H5提供的新方法</strong>：querySelector、querySelectorAll (推荐)</li><li><strong>利用节点操作获取元素</strong>：父（parentNode）、子（children）、兄（previousElementSibling、nextElementSibling）（推荐）</li></ol><h3 id="6-6-属性操作"><a href="#6-6-属性操作" class="headerlink" title="6.6 属性操作"></a>6.6 属性操作</h3><p>主要针对于自定义属性</p><ol><li>setAttribute：设置dom的属性值</li><li>getAttribute：得到dom的属性值</li><li>removeAttribute：移除属性</li></ol><h2 id="7-事件高级"><a href="#7-事件高级" class="headerlink" title="7 事件高级"></a>7 事件高级</h2><h3 id="7-1-注册事件（绑定事件）"><a href="#7-1-注册事件（绑定事件）" class="headerlink" title="7.1 注册事件（绑定事件）"></a>7.1 注册事件（绑定事件）</h3><p>给元素添加事件，称为注册事件或者绑定事件。</p><p>注册事件有两种方式：传统方式和方法监听注册方式。</p><p>传统方式具有注册事件的唯一性。</p><h4 id="1-addEventListener-事件监听方式"><a href="#1-addEventListener-事件监听方式" class="headerlink" title="1 addEventListener 事件监听方式"></a>1 addEventListener 事件监听方式</h4><pre class="line-numbers language-none"><code class="language-none">eventTarget.addEventListener(type,listener[,useCapture])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>type</code>:事件类型字符串，比如 click 、mouseover，注意这里不要带on</li><li><code>listener</code>：事件处理函数，事件发生时，会调用该监听函数</li><li><code>useCapture</code>：可选参数，是一个布尔值，默认是 false。</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;button&gt;传统注册事件&lt;/button&gt;    &lt;button&gt;方法监听注册事件&lt;/button&gt;    &lt;button&gt;ie9 attachEvent&lt;/button&gt;    &lt;script&gt;        var btns = document.querySelectorAll('button');        // 1. 传统方式注册事件        btns[0].onclick = function() {            alert('hi');        }        btns[0].onclick = function() {                alert('hao a u');        }                // 2. 事件监听注册事件 addEventListener         // (1) 里面的事件类型是字符串 所以加引号 而且不带on        // (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）        btns[1].addEventListener('click', function() {            alert(22);        })        btns[1].addEventListener('click', function() {                alert(33);        })                // 3. attachEvent ie9以前的版本支持        btns[2].attachEvent('onclick', function() {            alert(11);        })    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-attachEvent事件监听方式（兼容）"><a href="#2-attachEvent事件监听方式（兼容）" class="headerlink" title="2 attachEvent事件监听方式（兼容）"></a>2 attachEvent事件监听方式（兼容）</h4><pre class="line-numbers language-none"><code class="language-none">eventTarget.attachEvent(eventNameWithOn,callback)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-注册事件兼容性解决方案"><a href="#3-注册事件兼容性解决方案" class="headerlink" title="3 注册事件兼容性解决方案"></a>3 注册事件兼容性解决方案</h4><pre class="line-numbers language-none"><code class="language-none">function addEventListener(element, eventName, fn) {     // 判断当前浏览器是否支持 addEventListener 方法     if (element.addEventListener) {       element.addEventListener(eventName, fn);  // 第三个参数 默认是false     } else if (element.attachEvent) {       element.attachEvent('on' + eventName, fn);     } else {       // 相当于 element.onclick = fn;       element['on' + eventName] = fn;      }}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-2-删除事件（解绑事件）"><a href="#7-2-删除事件（解绑事件）" class="headerlink" title="7.2 删除事件（解绑事件）"></a>7.2 删除事件（解绑事件）</h3><h4 id="1-removeEventListener-删除事件方式"><a href="#1-removeEventListener-删除事件方式" class="headerlink" title="1 removeEventListener 删除事件方式"></a>1 removeEventListener 删除事件方式</h4><pre class="line-numbers language-none"><code class="language-none">eventTarget.removeEventListener(type,listener[,useCapture]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>type</code>:事件类型字符串，比如click、mouseover，注意这里不要带 on</li><li><code>listener</code>：事件处理函数，事件发生时，会调用该监听函数</li><li><code>useCapture</code>：可选参数，是一个布尔值，默认是 false。</li></ul><h4 id="2-detachEvent删除事件方式-兼容"><a href="#2-detachEvent删除事件方式-兼容" class="headerlink" title="2 detachEvent删除事件方式(兼容)"></a>2 detachEvent删除事件方式(兼容)</h4><pre class="line-numbers language-none"><code class="language-none">eventTarget.detachEvent(eventNameWithOn,callback);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-传统事件删除方式"><a href="#3-传统事件删除方式" class="headerlink" title="3 传统事件删除方式"></a>3 传统事件删除方式</h4><pre class="line-numbers language-none"><code class="language-none">eventTarget.onclick = null;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div&gt;1&lt;/div&gt;    &lt;div&gt;2&lt;/div&gt;    &lt;div&gt;3&lt;/div&gt;    &lt;script&gt;        var divs = document.querySelectorAll('div');        divs[0].onclick = function() {            alert(11);            // 1. 传统方式删除事件            divs[0].onclick = null;        }        // 2.removeEventListener 删除事件        divs[1].addEventListener('click',fn);   //里面的fn不需要调用加小括号        function fn(){            alert(22);            divs[1].removeEventListener('click',fn);        }        // 3.IE9 中的删除事件方式        divs[2].attachEvent('onclick',fn1);        function fn1() {            alert(33);            divs[2].detachEvent('onclick',fn1);        }    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-删除事件兼容性解决方案"><a href="#4-删除事件兼容性解决方案" class="headerlink" title="4 删除事件兼容性解决方案"></a>4 删除事件兼容性解决方案</h4><pre class="line-numbers language-none"><code class="language-none">function removeEventListener(element, eventName, fn) {      // 判断当前浏览器是否支持 removeEventListener 方法      if (element.removeEventListener) {        element.removeEventListener(eventName, fn);  // 第三个参数 默认是false      } else if (element.detachEvent) {        element.detachEvent('on' + eventName, fn);      } else {        element['on' + eventName] = null; } <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-3-DOM事件流"><a href="#7-3-DOM事件流" class="headerlink" title="7.3 DOM事件流"></a>7.3 DOM事件流</h3><ul><li>事件流描述的是从页面中接收事件的顺序</li><li>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流</li></ul><img src="image-20210814164549426.png" alt="image-20210814164549426" style="zoom: 67%;"><ul><li>事件冒泡： IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。</li><li>事件捕获： 网景最早提出，由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。</li></ul><h4 id="1-捕获阶段"><a href="#1-捕获阶段" class="headerlink" title="1 捕获阶段"></a>1 捕获阶段</h4><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div class="father"&gt;        &lt;div class="son"&gt;son盒子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // dom 事件流 三个阶段        // 1. JS 代码中只能执行捕获或者冒泡其中的一个阶段。        // 2. onclick 和 attachEvent（ie） 只能得到冒泡阶段。        // 3. 捕获阶段 如果addEventListener 第三个参数是 true 那么则处于捕获阶段  document -&gt; html -&gt; body -&gt; father -&gt; son        var son = document.querySelector('.son');        son.addEventListener('click', function() {             alert('son');        }, true);        var father = document.querySelector('.father');        father.addEventListener('click', function() {            alert('father');        }, true);    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="capture.gif" alt="capture" style="zoom:67%;"><h4 id="2-冒泡阶段"><a href="#2-冒泡阶段" class="headerlink" title="2 冒泡阶段"></a>2 冒泡阶段</h4><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div class="father"&gt;        &lt;div class="son"&gt;son盒子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;// 4. 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 那么则处于冒泡阶段  son -&gt; father -&gt;body -&gt; html -&gt; document        var son = document.querySelector('.son');        son.addEventListener('click', function() {            alert('son');        }, false);        var father = document.querySelector('.father');        father.addEventListener('click', function() {            alert('father');        }, false);        document.addEventListener('click', function() {            alert('document');        })    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="bubble.gif" alt="bubble" style="zoom:67%;"><h4 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h4><ul><li>JS 代码中只能执行捕获或者冒泡其中的一个阶段</li><li><code>onclick</code> 和 <code>attachEvent</code>只能得到冒泡阶段</li><li><code>addEventListener(type,listener[,useCapture])</code>第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序；如果是 false (不写默认就是false),表示在事件冒泡阶段调用事件处理程序</li><li>实际开发中我们很少使用事件捕获，我们更关注事件冒泡。</li><li>有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave</li></ul><h3 id="7-4-事件对象"><a href="#7-4-事件对象" class="headerlink" title="7.4 事件对象"></a>7.4 事件对象</h3><pre class="line-numbers language-none"><code class="language-none">eventTarget.onclick = function(event) {   // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt } eventTarget.addEventListener('click', function(event) {   // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt  })<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>官方解释：event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态</li><li>简单理解：<ul><li>事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面</li><li>这个对象就是事件对象 event，它有很多属性和方法，比如<ul><li>谁绑定了这个事件</li><li>鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置</li><li>键盘触发事件的话，会得到键盘的相关信息，如按了哪个键</li></ul></li></ul></li><li>这个 event 是个形参，系统帮我们设定为事件对象，不需要传递实参过去</li><li>当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）</li></ul><h4 id="1-事件对象的兼容性方案"><a href="#1-事件对象的兼容性方案" class="headerlink" title="1 事件对象的兼容性方案"></a>1 事件对象的兼容性方案</h4><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div&gt;123&lt;/div&gt;    &lt;script&gt;        // 事件对象        var div = document.querySelector('div');        div.onclick = function(e) {                // console.log(e);                // console.log(window.event);                // e = e || window.event;                console.log(e);            }        // 1. event 就是一个事件对象 写到我们侦听函数的 小括号里面 当形参来看        // 2. 事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数        // 3. 事件对象 是 我们事件的一系列相关数据的集合 跟事件相关的 比如鼠标点击里面就包含了鼠标的相关信息，鼠标坐标啊，如果是键盘事件里面就包含的键盘事件的信息 比如 判断用户按下了那个键        // 4. 这个事件对象我们可以自己命名 比如 event 、 evt、 e        // 5. 事件对象也有兼容性问题 ie678 通过 window.event 兼容性的写法  e = e || window.event;    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-事件对象的常见属性和方法"><a href="#2-事件对象的常见属性和方法" class="headerlink" title="2 事件对象的常见属性和方法"></a>2 事件对象的常见属性和方法</h4><table><thead><tr><th align="center">事件对象属性方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">e.target</td><td align="center">返回触发事件的对象 标准</td></tr><tr><td align="center">e.srcElement</td><td align="center">返回触发事件的对象 非标准 ie6-8使用</td></tr><tr><td align="center">e.type</td><td align="center">返回事件的类型 比如<code>click</code> <code>mouseover</code> 不带on</td></tr><tr><td align="center">e.cancelBubble</td><td align="center">该属性阻止冒泡，非标准，ie6-8使用</td></tr><tr><td align="center">e.returnValue</td><td align="center">该属性阻止默认行为 非标准，ie6-8使用</td></tr><tr><td align="center">e.preventDefault()</td><td align="center">该方法阻止默认行为 标准 比如不让链接跳转</td></tr><tr><td align="center">e.stopPropagation()</td><td align="center">阻止冒泡 标准</td></tr></tbody></table><p><code>e.target</code> 和 <code>this</code> 的区别：</p><ul><li>this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素）</li><li>e.target 是事件触发的元素</li></ul><h3 id="7-5-事件对象阻止默认行为"><a href="#7-5-事件对象阻止默认行为" class="headerlink" title="7.5 事件对象阻止默认行为"></a>7.5 事件对象阻止默认行为</h3><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div&gt;123&lt;/div&gt;    &lt;a href="http://www.baidu.com"&gt;百度&lt;/a&gt;    &lt;form action="http://www.baidu.com"&gt;        &lt;input type="submit" value="提交" name="sub"&gt;    &lt;/form&gt;    &lt;script&gt;        // 常见事件对象的属性和方法        // 1. 返回事件类型        var div = document.querySelector('div');        div.addEventListener('click', fn);        div.addEventListener('mouseover', fn);        div.addEventListener('mouseout', fn);        function fn(e) {            console.log(e.type);        }        // 2. 阻止默认行为（事件） 让链接不跳转 或者让提交按钮不提交        var a = document.querySelector('a');        a.addEventListener('click', function(e) {                e.preventDefault(); //  dom 标准写法            })            // 3. 传统的注册方式        a.onclick = function(e) {            // 普通浏览器 e.preventDefault();  方法            // e.preventDefault();            // 低版本浏览器 ie678  returnValue  属性            // e.returnValue;            // 我们可以利用return false 也能阻止默认行为 没有兼容性问题 特点： return 后面的代码不执行了， 而且只限于传统的注册方式            return false;            alert(11);        }    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-6-阻止事件冒泡"><a href="#7-6-阻止事件冒泡" class="headerlink" title="7.6 阻止事件冒泡"></a>7.6 阻止事件冒泡</h3><pre class="line-numbers language-none"><code class="language-none">//标准写法e.stopPropagation();&lt;body&gt;    &lt;div class="father"&gt;        &lt;div class="son"&gt;son儿子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // 常见事件对象的属性和方法        // 阻止冒泡  dom 推荐的标准 stopPropagation()         var son = document.querySelector('.son');        son.addEventListener('click', function(e) {            alert('son');            e.stopPropagation(); // stop 停止  Propagation 传播            e.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡        }, false);        var father = document.querySelector('.father');        father.addEventListener('click', function() {            alert('father');        }, false);        document.addEventListener('click', function() {            alert('document');        })    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-7-事件委托"><a href="#7-7-事件委托" class="headerlink" title="7.7 事件委托"></a>7.7 事件委托</h3><ul><li>事件委托也称为事件代理，在 jQuery 里面称为事件委派</li><li>事件委托的原理：不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;ul&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点        var ul = document.querySelector('ul');        ul.addEventListener('click', function(e) {            // alert('知否知否，点我应有弹框在手！');            // e.target 这个可以得到我们点击的对象            e.target.style.backgroundColor = 'pink';            // 点了谁，就让谁的style里面的backgroundColor颜色变为pink        })    &lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-8-常用鼠标事件"><a href="#7-8-常用鼠标事件" class="headerlink" title="7.8 常用鼠标事件"></a>7.8 常用鼠标事件</h3><table><thead><tr><th align="center">鼠标事件</th><th align="center">触发条件</th></tr></thead><tbody><tr><td align="center">onclick</td><td align="center">鼠标点击左键触发</td></tr><tr><td align="center">onmouseover</td><td align="center">鼠标经过触发</td></tr><tr><td align="center">onmouseout</td><td align="center">鼠标离开触发</td></tr><tr><td align="center">onfocus</td><td align="center">获得鼠标焦点触发</td></tr><tr><td align="center">onblur</td><td align="center">失去鼠标焦点触发</td></tr><tr><td align="center">onmousemove</td><td align="center">鼠标移动触发</td></tr><tr><td align="center">onmouseup</td><td align="center">鼠标弹起触发</td></tr><tr><td align="center">onmousedown</td><td align="center">鼠标按下触发</td></tr></tbody></table><h3 id="7-9-常用的键盘事件"><a href="#7-9-常用的键盘事件" class="headerlink" title="7.9 常用的键盘事件"></a>7.9 常用的键盘事件</h3><table><thead><tr><th align="center">键盘事件</th><th align="center">触发条件</th></tr></thead><tbody><tr><td align="center">onkeyup</td><td align="center">某个键盘按键被松开时触发</td></tr><tr><td align="center">onkeydown</td><td align="center">某个键盘按键被按下时触发</td></tr><tr><td align="center">onkeypress</td><td align="center">某个键盘按键被按下时触发，但是它不识别功能键，比如 ctrl、 shift、 箭头等</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 基础 变量、函数、对象</title>
      <link href="/2021/08/13/js-ji-chu-yu-fa/"/>
      <url>/2021/08/13/js-ji-chu-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-基础-变量、函数、对象"><a href="#JS-基础-变量、函数、对象" class="headerlink" title="JS 基础 变量、函数、对象"></a>JS 基础 变量、函数、对象</h1><p>总结中删去了大量与 C 语言重复的内容。</p><h2 id="0-JavaScript-简介"><a href="#0-JavaScript-简介" class="headerlink" title="0 JavaScript 简介"></a>0 JavaScript 简介</h2><h3 id="0-1-JavaScript"><a href="#0-1-JavaScript" class="headerlink" title="0.1 JavaScript"></a>0.1 JavaScript</h3><ul><li>JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 即脚本）</li><li>脚本语言：不需要编译，运行过程中由 JS 解释器( JS 引擎）逐行来进行解释并执行</li><li>现在也可以基于 Node.js 技术进行服务器端编程</li></ul><h3 id="0-2-浏览器执行-JS"><a href="#0-2-浏览器执行-JS" class="headerlink" title="0.2 浏览器执行 JS"></a>0.2 浏览器执行 JS</h3><p>浏览器分成两部分：渲染引擎和 JS 引擎</p><ul><li>渲染引擎：用来解析HTML与CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit</li><li>JS 引擎：也称为 JS 解释器。 用来读取网页中的 JavaScript 代码，对其处理后运行，比如 Chrome 浏览器的 V8</li></ul><p>浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎（解释器）来执行 JS 代码。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以JavaScript 语言归为脚本语言，会逐行解释执行。</p><h3 id="0-3-JS的组成"><a href="#0-3-JS的组成" class="headerlink" title="0.3 JS的组成"></a>0.3 JS的组成</h3><p>JavaScript 包括 ECMAScript、DOM、BOM。</p><h4 id="1-ECMAScript"><a href="#1-ECMAScript" class="headerlink" title="1 ECMAScript"></a>1 ECMAScript</h4><p><strong>ECMAScript</strong> 是由ECMA 国际进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。</p><p>ECMAScript：ECMAScript 规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。</p><h4 id="2-DOM文档对象模型"><a href="#2-DOM文档对象模型" class="headerlink" title="2 DOM文档对象模型"></a>2 DOM文档对象模型</h4><p><strong>DOM</strong>是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。</p><h4 id="3-BOM浏览器对象模型"><a href="#3-BOM浏览器对象模型" class="headerlink" title="3 BOM浏览器对象模型"></a>3 BOM浏览器对象模型</h4><p><strong>BOM</strong>是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</p><h2 id="1-JS-书写格式"><a href="#1-JS-书写格式" class="headerlink" title="1 JS 书写格式"></a>1 JS 书写格式</h2><h3 id="1-1-行内式"><a href="#1-1-行内式" class="headerlink" title="1.1 行内式"></a>1.1 行内式</h3><pre class="line-numbers language-none"><code class="language-none">&lt;input type="button" value="点我试试" onclink="alert('Hello World')" /&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-内嵌式"><a href="#1-2-内嵌式" class="headerlink" title="1.2 内嵌式"></a>1.2 内嵌式</h3><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;     alert('Hello World!');&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-3-外部JS"><a href="#1-3-外部JS" class="headerlink" title="1.3 外部JS"></a>1.3 外部JS</h3><pre class="line-numbers language-none"><code class="language-none">&lt;script src="my.js"&gt;&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-JS-基本语法"><a href="#2-JS-基本语法" class="headerlink" title="2 JS 基本语法"></a>2 JS 基本语法</h2><h3 id="2-1-输入输出"><a href="#2-1-输入输出" class="headerlink" title="2.1 输入输出"></a>2.1 输入输出</h3><table><thead><tr><th align="center">方法</th><th align="center">说明</th><th align="center">归属</th></tr></thead><tbody><tr><td align="center">alert(msg);</td><td align="center">浏览器弹出警示框</td><td align="center">浏览器</td></tr><tr><td align="center">console.log(msg);</td><td align="center">浏览器控制台打印输出信息</td><td align="center">浏览器</td></tr><tr><td align="center">prompt(info);</td><td align="center">浏览看弹出输入框，用户可以输入</td><td align="center">浏览器</td></tr></tbody></table><h3 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h4><p><code>var</code> 是一个 JS 关键字，用来声明变量(variable)。使用该关键字声明变量后，计算机会自动为变量分配内存空间。</p><h4 id="2-声明变量的特殊情况"><a href="#2-声明变量的特殊情况" class="headerlink" title="2 声明变量的特殊情况"></a>2 声明变量的特殊情况</h4><table><thead><tr><th align="center">说明</th><th align="center">情况</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">只声明，不赋值</td><td align="center">var age; console.log(age);</td><td align="center">undefined</td></tr><tr><td align="center">不声明，不赋值，直接使用</td><td align="center">console.log(age)</td><td align="center">报错</td></tr><tr><td align="center">不声明，只赋值，会自动声明该变量</td><td align="center">age = 10;console.log(age);</td><td align="center">10</td></tr></tbody></table><h3 id="2-3-数据类型"><a href="#2-3-数据类型" class="headerlink" title="2.3 数据类型"></a>2.3 数据类型</h3><p><strong>JavaScript是一种弱类型或动态语言。</strong>这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。</p><p>JS 把数据类型分为两类：</p><ul><li>基本数据类型(Number, String, Boolean, Undefined, Null)</li><li>复杂数据类型(Object)</li></ul><p>基本数据类型</p><table><thead><tr><th>简单数据类型</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>number</td><td>数字型，包含整型值和浮点型值，如21，0.21</td><td>0</td></tr><tr><td>boolean</td><td>布尔值类型，如true，false ，等价于1和0</td><td>false</td></tr><tr><td>undefined</td><td>var a; 声明了变量a但是没有赋值，此时a=undefined</td><td>undefined（未定义的）</td></tr><tr><td>string</td><td>字符串类型，如“张三”</td><td>“”</td></tr><tr><td>null</td><td>var a = null;声明了变量a为空值</td><td>null</td></tr></tbody></table><p>详细信息参考：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F(string_literals)">语法和数据类型 - JavaScript | MDN (mozilla.org)</a></p><h3 id="2-4-数据类型的转换"><a href="#2-4-数据类型的转换" class="headerlink" title="2.4 数据类型的转换"></a>2.4 数据类型的转换</h3><h4 id="1-转换为字符串型"><a href="#1-转换为字符串型" class="headerlink" title="1 转换为字符串型"></a>1 转换为字符串型</h4><table><thead><tr><th align="center">方式</th><th align="center">说明</th><th align="center">案例</th></tr></thead><tbody><tr><td align="center">toString()</td><td align="center">转成字符串</td><td align="center">var num = 1; alert(num.toString());</td></tr><tr><td align="center">String()强制转换</td><td align="center">转成字符串</td><td align="center">var num = 1; alert(String(num));</td></tr><tr><td align="center"><strong>加号拼接字符串</strong></td><td align="center">和字符串拼接的结果都是字符串</td><td align="center">var num =1; alert(num+“我是字符串”);</td></tr></tbody></table><h4 id="2-转换为数字型"><a href="#2-转换为数字型" class="headerlink" title="2  转换为数字型"></a>2  转换为数字型</h4><table><thead><tr><th>方式</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td><strong>parselnt(string)函数</strong></td><td>将string类型转成整数数值型</td><td>parselnt(‘78’)</td></tr><tr><td><strong>parseFloat(string)函数</strong></td><td>将string类型转成浮点数数值型</td><td>parseFloat(‘78.21’)</td></tr><tr><td>Number()强制转换函数</td><td>将string类型转换为数值型</td><td>Number(‘12’)</td></tr><tr><td>js 隐式转换(- * /)</td><td>利用算术运算隐式转换为数值型</td><td>‘12’-0</td></tr></tbody></table><h4 id="3-转换为布尔型"><a href="#3-转换为布尔型" class="headerlink" title="3 转换为布尔型"></a>3 转换为布尔型</h4><table><thead><tr><th>方法</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td>Boolean()函数</td><td>其他类型转成布尔值</td><td>Boolean(‘true’);</td></tr></tbody></table><ul><li>代表空、否定的值会被转换为false，如 ’ ’ , 0, NaN , null , undefined</li><li>其余的值都会被被转换为true</li></ul><h3 id="2-5-运算符"><a href="#2-5-运算符" class="headerlink" title="2.5 运算符"></a>2.5 运算符</h3><p>运算符（operator）也被称为<strong>操作符</strong>，是用于实现赋值、比较和执行算数运算等功能的符号</p><p>JavaScript 中常用的运算符有：</p><ul><li>算数运算符</li><li>递增和递减运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>赋值运算符</li></ul><h3 id="2-6-流程控制"><a href="#2-6-流程控制" class="headerlink" title="2.6 流程控制"></a>2.6 流程控制</h3><ul><li>if</li><li>switch</li><li>三元表达式</li></ul><h2 id="3-断点调试"><a href="#3-断点调试" class="headerlink" title="3 断点调试"></a>3 断点调试</h2><ol><li>浏览器中按 F12 -&gt; sources -&gt;找到需要调试的文件 -&gt; 在程序的某一行设置断点</li><li>刷新浏览器</li><li>Watch: 监视，通过watch可以监视变量的值的变化</li><li>F11: 程序单步执行，观察watch中变量的值的变化</li></ol><h2 id="4-循环"><a href="#4-循环" class="headerlink" title="4 循环"></a>4 循环</h2><ul><li>for</li><li>while</li><li>do - while</li><li>continue 关键字</li><li>break 关键字</li></ul><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><h3 id="5-1-创建数组"><a href="#5-1-创建数组" class="headerlink" title="5.1 创建数组"></a>5.1 创建数组</h3><p>JavaScript 中创建数组有两种方式：</p><ul><li>利用 new 创建数组</li><li>利用数组字面量创建数组</li></ul><pre class="line-numbers language-none"><code class="language-none">// 1.利用数组字面量方式创建空的数组 var 数组名 =[];// 2.使用数组字面量方式创建带初始值的数组var 数组名 =['小白','小黑','小黄','瑞奇'];// 3.数组中可以存放任意类型的数据，例如字符串，数字，布尔值等var arrStus =['小白',12,true,28.9];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-数组中新增元素"><a href="#5-2-数组中新增元素" class="headerlink" title="5.2 数组中新增元素"></a>5.2 数组中新增元素</h3><h4 id="1-通过修改-length-长度新增数组元素"><a href="#1-通过修改-length-长度新增数组元素" class="headerlink" title="1 通过修改 length 长度新增数组元素"></a>1 通过修改 length 长度新增数组元素</h4><ul><li>可以通过修改 length 长度来实现数组扩容的目的</li><li>length 属性是可读写的</li></ul><pre class="line-numbers language-none"><code class="language-none">var arr = ['red', 'green', 'blue', 'pink'];arr.length = 7;console.log(arr);console.log(arr[4]);console.log(arr[5]);console.log(arr[6]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中索引号是 4，5，6 的空间没有给值，就是声明变量未给值，默认值就是 <strong>undefined</strong></p><h4 id="2-通过修改数组索引新增数组元素"><a href="#2-通过修改数组索引新增数组元素" class="headerlink" title="2 通过修改数组索引新增数组元素"></a>2 通过修改数组索引新增数组元素</h4><ul><li>可以通过修改数组索引的方式追加数组元素</li><li>不能直接给数组名赋值，否则会覆盖掉以前的数据</li><li>这种方式也是我们最常用的一种方式</li></ul><pre class="line-numbers language-none"><code class="language-none">var arr = ['red', 'green', 'blue', 'pink'];arr[4] = 'hotpink';console.log(arr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="6-1-函数的参数"><a href="#6-1-函数的参数" class="headerlink" title="6.1 函数的参数"></a>6.1 函数的参数</h3><h4 id="形参和实参个数不匹配"><a href="#形参和实参个数不匹配" class="headerlink" title="形参和实参个数不匹配"></a>形参和实参个数不匹配</h4><table><thead><tr><th align="center">参数个数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">实参个数等于形参个数</td><td align="center">输出正确结果</td></tr><tr><td align="center">实参个数多于形参个数</td><td align="center">只取到形参的个数</td></tr><tr><td align="center">实参个数小于形参个数</td><td align="center">多的形参定义为undefined</td></tr></tbody></table><h3 id="6-2-arguments-的使用"><a href="#6-2-arguments-的使用" class="headerlink" title="6.2 arguments 的使用"></a>6.2 arguments 的使用</h3><p>当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。</p><ul><li><strong>arguments</strong>存放的是传递过来的实参</li><li><strong>arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</strong><ol><li>具有 length 属性</li><li>按索引方式储存数据</li><li>不具有数组的 push , pop 等方法</li></ol></li></ul><h3 id="6-3-函数的两种声明方式"><a href="#6-3-函数的两种声明方式" class="headerlink" title="6.3 函数的两种声明方式"></a>6.3 函数的两种声明方式</h3><h4 id="1-自定义函数方式-命名函数"><a href="#1-自定义函数方式-命名函数" class="headerlink" title="1 自定义函数方式(命名函数)"></a>1 自定义函数方式(命名函数)</h4><p>利用函数关键字 function 自定义函数方式。</p><pre class="line-numbers language-none"><code class="language-none">// 声明定义方式function fn() {...}// 调用  fn(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</strong></p><h4 id="2-函数表达式方式-匿名函数"><a href="#2-函数表达式方式-匿名函数" class="headerlink" title="2 函数表达式方式(匿名函数)"></a>2 函数表达式方式(匿名函数)</h4><pre class="line-numbers language-none"><code class="language-none">// 这是函数表达式写法，匿名函数后面跟分号结束var fn = function(){...};// 调用的方式，函数调用必须写到函数体下面fn();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>因为函数没有名字，所以也称为<strong>匿名函数</strong></li><li>这个 fn 里面存储的是一个函数</li><li><strong>函数调用的代码必须写到函数体后面</strong></li></ol><h2 id="7-作用域"><a href="#7-作用域" class="headerlink" title="7 作用域"></a>7 作用域</h2><h3 id="7-1-全局作用域"><a href="#7-1-全局作用域" class="headerlink" title="7.1 全局作用域"></a>7.1 全局作用域</h3><h3 id="7-2-局部（函数）作用域"><a href="#7-2-局部（函数）作用域" class="headerlink" title="7.2 局部（函数）作用域"></a>7.2 局部（函数）作用域</h3><h3 id="7-3-块级作用域"><a href="#7-3-块级作用域" class="headerlink" title="7.3 块级作用域"></a>7.3 块级作用域</h3><p><code>var</code> 声明的变量没有块级作用域， <code>let</code> 和 <code>const</code> 声明的变量有块级作用域。我们常用 <code>let</code> 和 <code>const</code> 声明变量。</p><h2 id="8-预解析"><a href="#8-预解析" class="headerlink" title="8 预解析"></a>8 预解析</h2><p>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：<strong>预解析和代码执行。</strong></p><ul><li><strong>预解析</strong>：js引擎会把js里面所有的 <strong>var</strong> 还有 <strong>function</strong> 提升到当前作用域的最前面</li><li><strong>代码执行</strong>：从上到下执行JS语句</li></ul><h3 id="8-1-变量预解析（变量提升）"><a href="#8-1-变量预解析（变量提升）" class="headerlink" title="8.1 变量预解析（变量提升）"></a>8.1 变量预解析（变量提升）</h3><p>变量提升: 变量的声明会被提升到<strong>当前作用域</strong>的最上面，变量的赋值不会提升</p><pre class="line-numbers language-none"><code class="language-none">console.log(num);  // undefinedvar num = 10;   //相当于执行了以下代码var num;// 变量声明提升到当前作用域最上面console.log(num);num = 10;// 变量的赋值不会提升<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>8.2 函数预解析（函数提升）</p><p>函数提升： 函数的声明会被提升到<strong>当前作用域</strong>的最上面，但是不会调用函数。</p><pre class="line-numbers language-none"><code class="language-none">fn();//hellofunction fn() {    console.log('hello');}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-对象"><a href="#9-对象" class="headerlink" title="9 对象"></a>9 对象</h2><p>对象是由属性和方法组成的。</p><h3 id="9-1-创建对象"><a href="#9-1-创建对象" class="headerlink" title="9.1 创建对象"></a>9.1 创建对象</h3><p>在 JavaScript 中，现阶段我们可以采用三种方式创建对象（object）：</p><ul><li>利用字面量创建对象</li><li>利用 new Object创建对象</li><li>利用构造函数创建对象</li></ul><h4 id="1-利用字面量创建对象"><a href="#1-利用字面量创建对象" class="headerlink" title="1 利用字面量创建对象"></a>1 利用字面量创建对象</h4><p>对象字面量：就是花括号 <code>{ }</code> 里面包含了表达这个具体事物（对象）的属性和方法</p><p><code>{ }</code> 里面采取键值对的形式表示</p><ul><li>键：相当于属性名</li><li>值：相当于属性值，可以是任意类型的值</li></ul><pre class="line-numbers language-none"><code class="language-none">var star = {    name : 'pink',    age : 18,    sex : '男',    sayHi : function(){        alert('大家好啊~');    }};// 多个属性或者方法中间用逗号隔开// 方法冒号后面跟的是一个匿名函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-利用-new-Object-创建对象"><a href="#2-利用-new-Object-创建对象" class="headerlink" title="2  利用 new Object 创建对象"></a>2  利用 <code>new Object</code> 创建对象</h4><p>跟之前的 <code>new Array()</code> 原理一致：<code>var 对象名 = new Object();</code></p><p>使用的格式：对象.属性 = 值</p><pre class="line-numbers language-none"><code class="language-none">var obj = new Object(); //创建了一个空的对象obj.name = '张三丰';obj.age = 18;obj.sex = '男';obj.sayHi = function() {    console.log('hi~');}//1.我们是利用等号赋值的方法添加对象//2.每个属性和方法之间用分号结束console.log(obj.uname);console.log(obj['sex']);obj.sayHi();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-利用构造函数创建对象"><a href="#3-利用构造函数创建对象" class="headerlink" title="3 利用构造函数创建对象"></a>3 利用构造函数创建对象</h4><p><strong>构造函数</strong> ：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p><p>在 js 中，使用构造函数要时要注意以下两点：</p><ul><li>构造函数用于创建某一类对象，其首字母要大写</li><li>构造函数要和 new 一起使用才有意义</li></ul><pre class="line-numbers language-none"><code class="language-none">//构造函数的语法格式function 构造函数名() {    this.属性 = 值;    this.方法 = function() {}}new 构造函数名();//示例function People(uname, age, sex) {    this.name = uname;    this.age = age;    this.sex = sex;    this.sing = function(sang){        console.log(sang);    }}var xm = new People('小明', 18, '男');console.log(typeof xm) // object对象，调用函数返回的是对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>构造函数名字首字母要大写</li><li>函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。</li><li>构造函数中不需要 return 返回结果。</li><li>当我们创建对象的时候，必须用 new 来调用构造函数。</li></ul><h4 id="4-对象的调用"><a href="#4-对象的调用" class="headerlink" title="4 对象的调用"></a>4 对象的调用</h4><ul><li>对象里面的属性调用 : <code>对象.属性名</code> 或者 <code>对象['属性名']</code></li><li>对象里面的方法调用：对象.方法名() </li></ul><h4 id="5-变量、函数、属性、方法总结"><a href="#5-变量、函数、属性、方法总结" class="headerlink" title="5 变量、函数、属性、方法总结"></a>5 变量、函数、属性、方法总结</h4><ul><li>变量：单独声明赋值，单独存在</li><li>函数：单独存在的，通过<code>函数名()</code>的方式就可以调用</li><li>属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征</li><li>方法：对象里面的函数称为方法，不需要声明，使用<code>对象.方法名()</code>的方式就可以调用，方法用来描述该对象的行为和功能</li></ul><h3 id="9-2-遍历对象的属性"><a href="#9-2-遍历对象的属性" class="headerlink" title="9.2 遍历对象的属性"></a>9.2 遍历对象的属性</h3><p><code>for...in</code> 语句用于对数组或者对象的属性进行循环操作</p><pre class="line-numbers language-none"><code class="language-none">for(变量 in 对象名字){    // 在此执行代码}for(var k in obj) {    console.log(k);//这里的 k 是属性名    console.log(obj[k]);//这里的 obj[k] 是属性值}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-内置对象"><a href="#10-内置对象" class="headerlink" title="10 内置对象"></a>10 内置对象</h2><ul><li>JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象</li><li>内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能</li><li>JavaScript 提供了多个内置对象：Math、 Date 、Array、String等</li></ul><h3 id="10-1-Math"><a href="#10-1-Math" class="headerlink" title="10.1 Math"></a>10.1 Math</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math">Math - JavaScript | MDN (mozilla.org)</a></p><h3 id="10-2-Date"><a href="#10-2-Date" class="headerlink" title="10.2  Date"></a>10.2  Date</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date">Date - JavaScript | MDN (mozilla.org)</a></p><h3 id="10-3-Array"><a href="#10-3-Array" class="headerlink" title="10.3  Array"></a>10.3  Array</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">Array - JavaScript | MDN (mozilla.org)</a></p><h3 id="10-4-String"><a href="#10-4-String" class="headerlink" title="10.4 String"></a>10.4 String</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String">String - JavaScript | MDN (mozilla.org)</a></p><h2 id="11-简单类型与复杂类型"><a href="#11-简单类型与复杂类型" class="headerlink" title="11 简单类型与复杂类型"></a>11 简单类型与复杂类型</h2><p>简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。</p><ul><li>值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型：string ，number，boolean，undefined，null</li><li>引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型：通过 <code>new</code> 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等</li></ul><h3 id="11-1-堆和栈"><a href="#11-1-堆和栈" class="headerlink" title="11.1 堆和栈"></a>11.1 堆和栈</h3><ol><li>栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。简单数据类型存放到栈里面；</li><li>堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型存放到堆里面。</li></ol><p>注意：JavaScript中没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式，便于将来学习其他语言。</p><h3 id="11-2-简单类型的内存分配"><a href="#11-2-简单类型的内存分配" class="headerlink" title="11.2 简单类型的内存分配"></a>11.2 简单类型的内存分配</h3><ul><li>值类型变量的数据直接存放在变量（栈空间）中</li><li>引用类型（复杂数据类型）：通过 new 关键字创建的对象（系统对象、自定义对象），引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</li></ul><img src="image-20210814022505364.png" alt="image-20210814022505364" style="zoom: 67%;"><p>复杂类型传参可以理解为传的是复杂类型的地址。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 和 CSS3 提高</title>
      <link href="/2021/07/31/html5css3-ti-gao/"/>
      <url>/2021/07/31/html5css3-ti-gao/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5-和-CSS3-提高"><a href="#HTML5-和-CSS3-提高" class="headerlink" title="HTML5 和 CSS3 提高"></a>HTML5 和 CSS3 提高</h1><h2 id="1-HTML5-的新特性"><a href="#1-HTML5-的新特性" class="headerlink" title="1 HTML5 的新特性"></a>1 HTML5 的新特性</h2><img src="image-20210731041634217.png" alt="image-20210731041634217" style="zoom:67%;"><h3 id="1-1-HTML5-新增的语义化标签"><a href="#1-1-HTML5-新增的语义化标签" class="headerlink" title="1.1 HTML5 新增的语义化标签"></a>1.1 HTML5 新增的语义化标签</h3><p>以前布局，我们基本用 div 来做。div 对于搜索引擎来说，是没有语义的。</p><pre class="line-numbers language-none"><code class="language-none">&lt;div class=“header”&gt; &lt;/div&gt;&lt;div class=“nav”&gt; &lt;/div&gt;&lt;div class=“content”&gt; &lt;/div&gt;&lt;div class=“footer”&gt; &lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20210731041705440.png" alt="image-20210731041705440"></p><h3 id="1-2-HTML5-新增的多媒体标签"><a href="#1-2-HTML5-新增的多媒体标签" class="headerlink" title="1.2 HTML5 新增的多媒体标签"></a>1.2 HTML5 新增的多媒体标签</h3><img src="image-20210731041726954.png" alt="image-20210731041726954" style="zoom:67%;"><p>HTML5 在不使用插件的情况下，也可以原生的支持视频格式文件的播放，当然，支持的格式是有限的。</p><h4 id="1-2-1-视频-lt-video-gt"><a href="#1-2-1-视频-lt-video-gt" class="headerlink" title="1.2.1 视频 <video>"></a>1.2.1 视频 <code>&lt;video&gt;</code></h4><img src="image-20210731041820911.png" alt="image-20210731041820911" style="zoom:67%;"><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;video src="文件地址" controls="controls"&gt;&lt;/video&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;video controls="controls" width="300"&gt;&lt;source src="move.ogg" type="video/ogg" &gt;&lt;source src="move.mp4" type="video/mp4" &gt;您的浏览器暂不支持 &lt;video&gt; 标签播放视频&lt;/ video &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>常见属性：</strong></p><img src="image-20210731041938663.png" alt="image-20210731041938663" style="zoom:67%;"><h4 id="1-2-2-音频-lt-audio-gt"><a href="#1-2-2-音频-lt-audio-gt" class="headerlink" title="1.2.2 音频 <audio>"></a>1.2.2 音频 <code>&lt;audio&gt;</code></h4><p>当前 <code>&lt;audio&gt;</code> 元素支持三种音频格式：</p><img src="image-20210731042055915.png" alt="image-20210731042055915" style="zoom:67%;"><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;audio src="文件地址" controls="controls"&gt;&lt;/audio&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt; audio controls="controls" &gt;&lt;source src="happy.mp3" type="audio/mpeg" &gt;&lt;source src="happy.ogg" type="audio/ogg" &gt;您的浏览器暂不支持 &lt;audio&gt; 标签。&lt;/ audio&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>常见属性：</strong></p><img src="image-20210731042149080.png" alt="image-20210731042149080" style="zoom:67%;"><p>谷歌浏览器把音频和视频自动播放禁止了。</p><h4 id="1-2-3-多媒体标签总结"><a href="#1-2-3-多媒体标签总结" class="headerlink" title="1.2.3 多媒体标签总结"></a>1.2.3 多媒体标签总结</h4><img src="image-20210731042338376.png" alt="image-20210731042338376" style="zoom:67%;"><h3 id="1-3-HTML5-新增的-input-类型"><a href="#1-3-HTML5-新增的-input-类型" class="headerlink" title="1.3 HTML5 新增的 input 类型"></a>1.3 HTML5 新增的 input 类型</h3><img src="image-20210731042357462.png" alt="image-20210731042357462" style="zoom:67%;"><p>重点记住： number tel search 这三个。</p><h3 id="1-4-HTML5-新增的表单属性"><a href="#1-4-HTML5-新增的表单属性" class="headerlink" title="1.4 HTML5 新增的表单属性"></a>1.4 HTML5 新增的表单属性</h3><img src="image-20210731042419720.png" alt="image-20210731042419720" style="zoom:67%;"><p>可以通过以下设置方式修改placeholder里面的字体颜色：</p><pre class="line-numbers language-none"><code class="language-none">input::placeholder { color: pink;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2-CSS3-的新特性"><a href="#2-CSS3-的新特性" class="headerlink" title="2 CSS3 的新特性"></a>2 CSS3 的新特性</h2><h3 id="2-1-CSS3-的现状"><a href="#2-1-CSS3-的现状" class="headerlink" title="2.1 CSS3 的现状"></a>2.1 CSS3 的现状</h3><img src="image-20210731042506578.png" alt="image-20210731042506578" style="zoom:67%;"><img src="image-20210731042521374.png" alt="image-20210731042521374" style="zoom:67%;"><h3 id="2-2-属性选择器"><a href="#2-2-属性选择器" class="headerlink" title="2.2 属性选择器"></a>2.2 属性选择器</h3><p>属性选择器可以根据元素特定属性的来选择元素。 这样就可以不用借助于类或者id选择器。</p><img src="image-20210731042535868.png" alt="image-20210731042535868" style="zoom:67%;"><p>注意：类选择器、属性选择器、伪类选择器，权重为 10。</p><h3 id="2-3-结构伪类选择器"><a href="#2-3-结构伪类选择器" class="headerlink" title="2.3 结构伪类选择器"></a>2.3 结构伪类选择器</h3><p>结构伪类选择器主要根据<strong>文档结构</strong>来选择器元素， 常用于根据父级选择器里面的子元素。</p><img src="image-20210731042624202.png" alt="image-20210731042624202" style="zoom:67%;"><p>注意：类选择器、属性选择器、伪类选择器，权重为 10。</p><img src="image-20210731042641306.png" alt="image-20210731042641306" style="zoom:67%;"><p>区别： </p><ol><li>nth-child 对父元素里面所有孩子排序选择（序号是固定的） 先找到第n个孩子，然后看看是否和E匹配 </li><li>nth-of-type 对父元素里面指定子元素进行排序选择。 先去匹配E ，然后再根据E 找第n个孩子</li></ol><img src="image-20210731042711743.png" alt="image-20210731042711743" style="zoom:67%;"><h3 id="2-4-伪元素选择器（重点）"><a href="#2-4-伪元素选择器（重点）" class="headerlink" title="2.4 伪元素选择器（重点）"></a>2.4 伪元素选择器（重点）</h3><img src="image-20210731042727210.png" alt="image-20210731042727210" style="zoom:67%;"><h4 id="2-4-1-伪元素选择器使用场景1：伪元素字体图标"><a href="#2-4-1-伪元素选择器使用场景1：伪元素字体图标" class="headerlink" title="2.4.1 伪元素选择器使用场景1：伪元素字体图标"></a>2.4.1 伪元素选择器使用场景1：伪元素字体图标</h4><img src="image-20210731042830398.png" alt="image-20210731042830398" style="zoom:67%;"><pre class="line-numbers language-none"><code class="language-none">p::before {position: absolute;right: 20px;top: 10px;content: '\e91e';font-size: 20px;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-2-伪元素选择器使用场景2：仿土豆效果"><a href="#2-4-2-伪元素选择器使用场景2：仿土豆效果" class="headerlink" title="2.4.2 伪元素选择器使用场景2：仿土豆效果"></a>2.4.2 伪元素选择器使用场景2：仿土豆效果</h4><pre class="line-numbers language-none"><code class="language-none">/* 当我们鼠标经过了 土豆这个盒子，就让里面before遮罩层显示出来 */.tudou:hover::before { /* 而是显示元素 */ display: block;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-3-伪元素选择器使用场景3：伪元素清除浮动"><a href="#2-4-3-伪元素选择器使用场景3：伪元素清除浮动" class="headerlink" title="2.4.3 伪元素选择器使用场景3：伪元素清除浮动"></a>2.4.3 伪元素选择器使用场景3：伪元素清除浮动</h4><img src="image-20210731042920949.png" alt="image-20210731042920949" style="zoom:67%;"><img src="image-20210731042930714.png" alt="image-20210731042930714" style="zoom:67%;"><img src="image-20210731042938165.png" alt="image-20210731042938165" style="zoom:67%;"><img src="image-20210731042953142.png" alt="image-20210731042953142" style="zoom:67%;"><h3 id="2-5-CSS3-盒子模型"><a href="#2-5-CSS3-盒子模型" class="headerlink" title="2.5 CSS3 盒子模型"></a>2.5 CSS3 盒子模型</h3><img src="image-20210731043035312.png" alt="image-20210731043035312" style="zoom:67%;"><h3 id="2-6-CSS3-其他特性（了解）"><a href="#2-6-CSS3-其他特性（了解）" class="headerlink" title="2.6 CSS3 其他特性（了解）"></a>2.6 CSS3 其他特性（了解）</h3><img src="image-20210731043114296.png" alt="image-20210731043114296" style="zoom:67%;"><img src="image-20210731043126496.png" style="zoom:67%;"><h3 id="2-7-CSS3-过渡（重点）"><a href="#2-7-CSS3-过渡（重点）" class="headerlink" title="2.7 CSS3 过渡（重点）"></a>2.7 CSS3 过渡（重点）</h3><img src="image-20210731043151085.png" alt="image-20210731043151085" style="zoom:67%;"><img src="image-20210731043158942.png" alt="image-20210731043158942" style="zoom:67%;"><h2 id="狭义的HTML5-CSS3"><a href="#狭义的HTML5-CSS3" class="headerlink" title="狭义的HTML5 CSS3"></a>狭义的HTML5 CSS3</h2><img src="image-20210731043256872.png" alt="image-20210731043256872" style="zoom:67%;"><h2 id="广义的HTML5"><a href="#广义的HTML5" class="headerlink" title="广义的HTML5"></a>广义的HTML5</h2><img src="image-20210731043304433.png" alt="image-20210731043304433" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础总结 7/7</title>
      <link href="/2021/07/31/css-7-7/"/>
      <url>/2021/07/31/css-7-7/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础总结-7-7"><a href="#CSS-基础总结-7-7" class="headerlink" title="CSS 基础总结 7/7"></a>CSS 基础总结 7/7</h1><h2 id="1-精灵图"><a href="#1-精灵图" class="headerlink" title="1 精灵图"></a>1 精灵图</h2><h3 id="1-1-为什么需要精灵图"><a href="#1-1-为什么需要精灵图" class="headerlink" title="1.1 为什么需要精灵图"></a>1.1 为什么需要精灵图</h3><img src="image-20210731033446339.png" alt="image-20210731033446339" style="zoom:67%;"><img src="image-20210731033508435.png" alt="image-20210731033508435" style="zoom:67%;"><h3 id="1-2-精灵图（sprites）的使用"><a href="#1-2-精灵图（sprites）的使用" class="headerlink" title="1.2 精灵图（sprites）的使用"></a>1.2 精灵图（sprites）的使用</h3><img src="image-20210731033527478.png" alt="image-20210731033527478" style="zoom:67%;"><h2 id="2-字体图标"><a href="#2-字体图标" class="headerlink" title="2 字体图标"></a>2 字体图标</h2><h3 id="2-1-字体图标的产生"><a href="#2-1-字体图标的产生" class="headerlink" title="2.1 字体图标的产生"></a>2.1 字体图标的产生</h3><img src="image-20210731033623041.png" alt="image-20210731033623041" style="zoom:67%;"><h3 id="2-2-字体图标的优点"><a href="#2-2-字体图标的优点" class="headerlink" title="2.2 字体图标的优点"></a>2.2 字体图标的优点</h3><img src="image-20210731033641913.png" alt="image-20210731033641913" style="zoom:67%;"><img src="image-20210731033653183.png" alt="image-20210731033653183" style="zoom:67%;"><h3 id="2-3-字体图标的下载"><a href="#2-3-字体图标的下载" class="headerlink" title="2.3 字体图标的下载"></a>2.3 字体图标的下载</h3><img src="image-20210731033713669.png" alt="image-20210731033713669" style="zoom:67%;"><h3 id="2-4-字体图标的引入"><a href="#2-4-字体图标的引入" class="headerlink" title="2.4 字体图标的引入"></a>2.4 字体图标的引入</h3><img src="image-20210731033735008.png" alt="image-20210731033735008" style="zoom:67%;"><h4 id="2-4-1-字体文件格式"><a href="#2-4-1-字体文件格式" class="headerlink" title="2.4.1 字体文件格式"></a>2.4.1 字体文件格式</h4><img src="image-20210731033755060.png" alt="image-20210731033755060" style="zoom:67%;"><h4 id="2-4-2-字体的声明"><a href="#2-4-2-字体的声明" class="headerlink" title="2.4.2 字体的声明"></a>2.4.2 字体的声明</h4><p>.在 CSS 样式中全局声明字体： 简单理解把这些字体文件通过css引入到我们页面中。</p><p>一定注意字体文件路径的问题。</p><pre class="line-numbers language-none"><code class="language-none">@font-face { font-family: 'icomoon'; src: url('fonts/icomoon.eot?7kkyc2'); src: url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype'), url('fonts/icomoon.ttf?7kkyc2') format('truetype'), url('fonts/icomoon.woff?7kkyc2') format('woff'), url('fonts/icomoon.svg?7kkyc2#icomoon') format('svg'); font-weight: normal; font-style: normal;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（在下载的 style.css 文件中复制）</p><h4 id="2-4-3-HTML-标签内添加小图标"><a href="#2-4-3-HTML-标签内添加小图标" class="headerlink" title="2.4.3 HTML 标签内添加小图标"></a>2.4.3 HTML 标签内添加小图标</h4><img src="image-20210731034022920.png" alt="image-20210731034022920" style="zoom:67%;"><h4 id="2-4-4-给标签定义字体"><a href="#2-4-4-给标签定义字体" class="headerlink" title="2.4.4 给标签定义字体"></a>2.4.4 给标签定义字体</h4><img src="image-20210731034102244.png" alt="image-20210731034102244" style="zoom:67%;"><h3 id="2-5-字体图标的追加"><a href="#2-5-字体图标的追加" class="headerlink" title="2.5 字体图标的追加"></a>2.5 字体图标的追加</h3><img src="image-20210731034121415.png" alt="image-20210731034121415" style="zoom:67%;"><img src="image-20210731034127524.png" alt="image-20210731034127524" style="zoom:67%;"><h2 id="3-CSS-三角"><a href="#3-CSS-三角" class="headerlink" title="3 CSS 三角"></a>3 CSS 三角</h2><img src="image-20210731034152733.png" alt="image-20210731034152733" style="zoom:67%;"><pre class="line-numbers language-none"><code class="language-none">div { width: 0; height: 0; line-height: 0; font-size: 0; border: 50px solid transparent; border-left-color: pink;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-CSS-用户界面样式"><a href="#4-CSS-用户界面样式" class="headerlink" title="4 CSS 用户界面样式"></a>4 CSS 用户界面样式</h2><h3 id="4-0-什么是界面样式"><a href="#4-0-什么是界面样式" class="headerlink" title="4.0 什么是界面样式"></a>4.0 什么是界面样式</h3><img src="image-20210731034228067.png" alt="image-20210731034228067" style="zoom:67%;"><h3 id="4-1-鼠标样式-cursor"><a href="#4-1-鼠标样式-cursor" class="headerlink" title="4.1 鼠标样式 cursor"></a>4.1 鼠标样式 cursor</h3><pre class="line-numbers language-none"><code class="language-none">li {cursor: pointer; }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="image-20210731034300808.png" alt="image-20210731034300808" style="zoom:67%;"><h3 id="4-2-轮廓线-outline"><a href="#4-2-轮廓线-outline" class="headerlink" title="4.2 轮廓线 outline"></a>4.2 轮廓线 outline</h3><p>给表单添加 outline: 0; 或者 outline: none; 样式之后，就可以去掉默认的蓝色边框。</p><pre class="line-numbers language-none"><code class="language-none">input {outline: none; }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-3-防止拖拽文本域-resize"><a href="#4-3-防止拖拽文本域-resize" class="headerlink" title="4.3 防止拖拽文本域 resize"></a>4.3 防止拖拽文本域 resize</h3><p>实际开发中，我们文本域右下角是不可以拖拽的。</p><pre class="line-numbers language-none"><code class="language-none">textarea{ resize: none;}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-vertical-align-属性应用"><a href="#5-vertical-align-属性应用" class="headerlink" title="5 vertical-align 属性应用"></a>5 vertical-align 属性应用</h2><h3 id="5-0-vertical-align-属性"><a href="#5-0-vertical-align-属性" class="headerlink" title="5.0  vertical-align 属性"></a>5.0  vertical-align 属性</h3><p>CSS 的 <strong>vertical-align</strong> 属性使用场景： 经常用于设置图片或者表单(行内块元素）和文字垂直对齐。 </p><p>官方解释： 用于设置一个元素的<strong>垂直对齐方式</strong>，但是它只针对于行内元素或者行内块元素有效。</p><pre class="line-numbers language-none"><code class="language-none">vertical-align : baseline | top | middle | bottom <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="image-20210731034547011.png" alt="image-20210731034547011" style="zoom:67%;"><img src="image-20210731034553446.png" alt="image-20210731034553446" style="zoom:67%;"><h3 id="5-1-图片、表单和文字对齐"><a href="#5-1-图片、表单和文字对齐" class="headerlink" title="5.1 图片、表单和文字对齐"></a>5.1 图片、表单和文字对齐</h3><img src="image-20210731034633745.png" alt="image-20210731034633745" style="zoom:67%;"><h3 id="5-2-解决图片底部默认空白缝隙问题"><a href="#5-2-解决图片底部默认空白缝隙问题" class="headerlink" title="5.2 解决图片底部默认空白缝隙问题"></a>5.2 解决图片底部默认空白缝隙问题</h3><img src="C:/Users/tzy/Desktop/article/css/css7of7/image-20210731034649015.png" alt="image-20210731034649015" style="zoom:67%;"><h2 id="6-溢出的文字省略号显示"><a href="#6-溢出的文字省略号显示" class="headerlink" title="6 溢出的文字省略号显示"></a>6 溢出的文字省略号显示</h2><img src="image-20210731040225932.png" alt="image-20210731040225932" style="zoom:67%;"><h3 id="6-1-单行文本溢出显示省略号"><a href="#6-1-单行文本溢出显示省略号" class="headerlink" title="6.1  单行文本溢出显示省略号"></a>6.1  单行文本溢出显示省略号</h3><p>必须满足三个条件</p><pre class="line-numbers language-none"><code class="language-none">/*1. 先强制一行内显示文本*/white-space: nowrap; （ 默认 normal 自动换行）/*2. 超出的部分隐藏*/overflow: hidden;/*3. 文字用省略号替代超出的部分*/text-overflow: ellipsis;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-多行文本溢出显示省略号"><a href="#6-2-多行文本溢出显示省略号" class="headerlink" title="6.2 多行文本溢出显示省略号"></a>6.2 多行文本溢出显示省略号</h3><p>多行文本溢出显示省略号，有较大兼容性问题， 适合于webKit浏览器或移动端（移动端大部分是webkit内 核）</p><pre class="line-numbers language-none"><code class="language-none">overflow: hidden;text-overflow: ellipsis;/* 弹性伸缩盒子模型显示 */display: -webkit-box;/* 限制在一个块元素显示的文本的行数 */-webkit-line-clamp: 2;/* 设置或检索伸缩盒对象的子元素的排列方式 */-webkit-box-orient: vertical;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更推荐让后台人员来做这个效果，因为后台人员可以设置显示多少个字，操作更简单。</p><h2 id="7-常见布局技巧"><a href="#7-常见布局技巧" class="headerlink" title="7 常见布局技巧"></a>7 常见布局技巧</h2><h3 id="7-1-margin负值运用"><a href="#7-1-margin负值运用" class="headerlink" title="7.1 margin负值运用"></a>7.1 margin负值运用</h3><img src="image-20210731035005055.png" alt="image-20210731035005055" style="zoom:67%;"><h3 id="7-2-文字围绕浮动元素"><a href="#7-2-文字围绕浮动元素" class="headerlink" title="7.2 文字围绕浮动元素"></a>7.2 文字围绕浮动元素</h3><img src="image-20210731035044206.png" alt="image-20210731035044206" style="zoom:67%;"><h3 id="7-3-行内块巧妙运用"><a href="#7-3-行内块巧妙运用" class="headerlink" title="7.3 行内块巧妙运用"></a>7.3 行内块巧妙运用</h3><img src="image-20210731035118099.png" alt="image-20210731035118099" style="zoom:67%;"><h3 id="7-4-CSS-三角强化"><a href="#7-4-CSS-三角强化" class="headerlink" title="7.4 CSS 三角强化"></a>7.4 CSS 三角强化</h3><img src="image-20210731035146874.png" alt="image-20210731035146874" style="zoom:67%;"><pre class="line-numbers language-none"><code class="language-none">width: 0;height: 0;border-color: transparent red transparent transparent;border-style: solid;border-width: 22px 8px 0 0;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8-CSS-初始化"><a href="#8-CSS-初始化" class="headerlink" title="8 CSS 初始化"></a>8 CSS 初始化</h2><img src="image-20210731035230440.png" alt="image-20210731035230440" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础总结 6/7</title>
      <link href="/2021/07/29/css-6-7/"/>
      <url>/2021/07/29/css-6-7/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础总结-6-7"><a href="#CSS-基础总结-6-7" class="headerlink" title="CSS 基础总结 6/7"></a>CSS 基础总结 6/7</h1><h2 id="1-定位"><a href="#1-定位" class="headerlink" title="1 定位"></a>1 定位</h2><h3 id="1-1-为什么需要定位"><a href="#1-1-为什么需要定位" class="headerlink" title="1.1 为什么需要定位"></a>1.1 为什么需要定位</h3><p>提问： 以下情况使用标准流或者浮动能实现吗？ </p><ol><li>某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子。</li><li>当我们滚动窗口的时候，盒子是固定屏幕某个位置的。</li></ol><p>以上效果，标准流或浮动都无法快速实现，此时需要定位来实现。 </p><p>所以： </p><ol><li>浮动可以让多个块级盒子一行没有缝隙排列显示， 经常用于横向排列盒子。 </li><li>定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。</li></ol><h3 id="1-2-定位组成"><a href="#1-2-定位组成" class="headerlink" title="1.2 定位组成"></a>1.2 定位组成</h3><img src="image-20210729233532811.png" alt="image-20210729233532811" style="zoom:67%;"><img src="image-20210729233601687.png" alt="image-20210729233601687" style="zoom: 67%;"><h3 id="1-3-静态定位-static（了解）"><a href="#1-3-静态定位-static（了解）" class="headerlink" title="1.3 静态定位 static（了解）"></a>1.3 静态定位 static（了解）</h3><img src="image-20210729233622998.png" alt="image-20210729233622998" style="zoom:67%;"><h3 id="1-4-相对定位-relative（重要）"><a href="#1-4-相对定位-relative（重要）" class="headerlink" title="1.4 相对定位 relative（重要）"></a>1.4 相对定位 relative（重要）</h3><img src="image-20210729233637499.png" alt="image-20210729233637499" style="zoom:67%;"><h3 id="1-5-绝对定位-absolute（重要）"><a href="#1-5-绝对定位-absolute（重要）" class="headerlink" title="1.5 绝对定位 absolute（重要）"></a>1.5 绝对定位 absolute（重要）</h3><img src="image-20210729233703677.png" alt="image-20210729233703677" style="zoom:67%;"><h3 id="1-6-子绝父相的由来"><a href="#1-6-子绝父相的由来" class="headerlink" title="1.6 子绝父相的由来"></a>1.6 子绝父相的由来</h3><img src="image-20210729233736427.png" alt="image-20210729233736427" style="zoom:67%;"><h3 id="1-7-固定定位-fixed-（重要）"><a href="#1-7-固定定位-fixed-（重要）" class="headerlink" title="1.7 固定定位 fixed （重要）"></a>1.7 固定定位 fixed （重要）</h3><img src="image-20210729233801202.png" alt="image-20210729233801202" style="zoom:67%;"><img src="image-20210729233811218.png" alt="image-20210729233811218" style="zoom:67%;"><h3 id="1-8-粘性定位-sticky（了解）"><a href="#1-8-粘性定位-sticky（了解）" class="headerlink" title="1.8 粘性定位 sticky（了解）"></a>1.8 粘性定位 sticky（了解）</h3><img src="image-20210729233822508.png" alt="image-20210729233822508" style="zoom:67%;"><h3 id="1-9-定位的总结"><a href="#1-9-定位的总结" class="headerlink" title="1.9 定位的总结"></a>1.9 定位的总结</h3><img src="image-20210729233846329.png" alt="image-20210729233846329" style="zoom:67%;"><h3 id="1-10-定位叠放次序-z-index"><a href="#1-10-定位叠放次序-z-index" class="headerlink" title="1.10 定位叠放次序 z-index"></a>1.10 定位叠放次序 z-index</h3><img src="image-20210729233924197.png" alt="image-20210729233924197" style="zoom: 67%;"><h3 id="1-11-定位的拓展"><a href="#1-11-定位的拓展" class="headerlink" title="1.11 定位的拓展"></a>1.11 定位的拓展</h3><img src="image-20210729233955233.png" alt="image-20210729233955233" style="zoom:67%;"><img src="image-20210729234007050.png" alt="image-20210729234007050" style="zoom:67%;"><img src="image-20210729234029204.png" alt="image-20210729234029204" style="zoom: 67%;"><img src="image-20210729234213271.png" alt="image-20210729234213271" style="zoom:67%;"><h2 id="2-网页布局总结"><a href="#2-网页布局总结" class="headerlink" title="2 网页布局总结"></a>2 网页布局总结</h2><img src="image-20210729234240106.png" alt="image-20210729234240106" style="zoom:67%;"><h2 id="3-元素的显示与隐藏"><a href="#3-元素的显示与隐藏" class="headerlink" title="3 元素的显示与隐藏"></a>3 元素的显示与隐藏</h2><img src="image-20210729234321556.png" alt="image-20210729234321556" style="zoom:67%;"><h3 id="3-1-display-属性"><a href="#3-1-display-属性" class="headerlink" title="3.1 display 属性"></a>3.1 display 属性</h3><img src="image-20210729234350926.png" alt="image-20210729234350926" style="zoom:67%;"><h3 id="3-2-visibility-可见性"><a href="#3-2-visibility-可见性" class="headerlink" title="3.2 visibility 可见性"></a>3.2 visibility 可见性</h3><img src="image-20210729234408680.png" alt="image-20210729234408680" style="zoom:67%;"><h3 id="3-3-overflow-溢出"><a href="#3-3-overflow-溢出" class="headerlink" title="3.3 overflow 溢出"></a>3.3 overflow 溢出</h3><img src="image-20210729234427342.png" alt="image-20210729234427342" style="zoom:67%;"><h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><img src="image-20210729234504721.png" alt="image-20210729234504721" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奖牌榜微信小程序</title>
      <link href="/2021/07/28/jiang-pai-bang-wei-xin-xiao-cheng-xu/"/>
      <url>/2021/07/28/jiang-pai-bang-wei-xin-xiao-cheng-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="奖牌榜微信小程序"><a href="#奖牌榜微信小程序" class="headerlink" title="奖牌榜微信小程序"></a>奖牌榜微信小程序</h1><p>该小程序实现奥运会奖牌榜的动态显示和其他页面的静态显示。奥运会期间累计超1400人数和4700人次访问。</p><img src="gh_fb62dfa5e95e_258.jpg" style="zoom: 67%;"><img src="demo.gif" alt="demo.gif" style="zoom: 25%;">]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础总结 5/7</title>
      <link href="/2021/07/23/css-5-7/"/>
      <url>/2021/07/23/css-5-7/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础总结-5-7"><a href="#CSS-基础总结-5-7" class="headerlink" title="CSS 基础总结 5/7"></a>CSS 基础总结 5/7</h1><h2 id="1-学成在线案例"><a href="#1-学成在线案例" class="headerlink" title="1 学成在线案例"></a>1 学成在线案例</h2><h3 id="1-0-结果展示"><a href="#1-0-结果展示" class="headerlink" title="1.0 结果展示"></a>1.0 结果展示</h3><p><img src="image-20210723181305580.png"></p><h3 id="1-1-准备素材和工具"><a href="#1-1-准备素材和工具" class="headerlink" title="1.1 准备素材和工具"></a>1.1 准备素材和工具</h3><ol><li>学成在线 PSD 源文件。 </li><li>开发工具 = PS（切图）/ cutterman 插件 + vscode（代码） + chrome（测试）。</li></ol><h3 id="1-2-案例准备工作"><a href="#1-2-案例准备工作" class="headerlink" title="1.2 案例准备工作"></a>1.2 案例准备工作</h3><p>我们本次采取结构与样式相分离思想：</p><ol><li>创建 study 目录文件夹 (用于存放我们这个页面的相关内容)。 </li><li>用vscode打开study目录文件夹</li><li>study 目录内新建 images 文件夹，用于保存图片。</li><li>新建首页文件 index.html（以后我们的网站首页统一规定为 index.html )。</li><li>新建 style.css 样式文件。我们本次采用外链样式表。</li><li>将样式引入到我们的 HTML 页面文件中。</li><li>样式表写入清除内外边距的样式，来检测样式表是否引入成功。</li></ol><h3 id="1-3-CSS-属性书写顺序-重点"><a href="#1-3-CSS-属性书写顺序-重点" class="headerlink" title="1.3 CSS 属性书写顺序(重点)"></a>1.3 CSS 属性书写顺序(重点)</h3><p>建议遵循以下顺序：</p><ol><li><strong>布局定位属性</strong>：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）</li><li><strong>自身属性</strong>：width / height / margin / padding / border / background </li><li><strong>文本属性</strong>：color / font / text-decoration / text-align / vertical-align / white- space / break-word </li><li><strong>其他属性（CSS3）</strong>：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …</li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-none"><code class="language-none">.jdc { display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif; color: #333; background: rgba(0,0,0,.5); border-radius: 10px;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-页面布局整体思路"><a href="#1-4-页面布局整体思路" class="headerlink" title="1.4 页面布局整体思路"></a>1.4 页面布局整体思路</h3><p>为了提高网页制作的效率，布局时通常有以下的整体思路： </p><ol><li>必须确定页面的版心（可视区），我们测量可得知。 </li><li>分析页面中的行模块，以及每个行模块中的列模块。即页面布局第一准则。</li><li>一行中的列模块经常浮动布局，先确定每个列的大小，之后确定列的位置。即页面布局第二准则。 </li><li>制作 HTML 结构。我们还是遵循，先有结构，后有样式的原则。结构永远最重要。</li></ol><h3 id="1-5-确定版心"><a href="#1-5-确定版心" class="headerlink" title="1.5 确定版心"></a>1.5 确定版心</h3><p>这个页面的版心是 1200 像素，每个版心都要水平居中对齐，可以定义版心为公共类：</p><pre class="line-numbers language-none"><code class="language-none">.w { width: 1200px; margin: auto;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-6-头部制作"><a href="#1-6-头部制作" class="headerlink" title="1.6 头部制作"></a>1.6 头部制作</h3><p><img src="image-20210723180516664.png" alt="image-20210723180516664"></p><ul><li>1 号是版心盒子 header 1200 * 42 的盒子水平居中对齐，上下给一个 margin 值就可以</li><li>版心盒子里面包含 2 号盒子 logo </li><li>版心盒子里面包含 3 号盒子 nav 导航栏 </li><li>版心盒子里面包含 4 号盒子 search 搜索框</li><li>版心盒子里面包含 5 号盒子 user 个人信息 </li><li>注意：要求里面的 4 个盒子必须都是浮动</li></ul><p>导航栏注意点：</p><p>实际开发中，我们不会直接用链接a 而是用 li 包含链接(li+a)的做法。 </p><ol><li>li+a 语义更清晰，一看这就是有条理的列表型内容。 </li><li>如果直接用a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎有降权的风险）， 从而影响网站排名 </li></ol><p>注意:  </p><ol><li>让导航栏一行显示, 给 li 加浮动, 因为 li 是块级元素, 需要一行显示.</li><li>这个nav导航栏可以不给宽度,将来可以继续添加其余文字 </li><li>因为导航栏里面文字不一样多,所以最好给链接 a 左右padding 撑开盒子,而不是指定宽度</li></ol><img src="image-20210723180650653.png" alt="image-20210723180650653" style="zoom: 67%;"><h3 id="1-7-banner-制作"><a href="#1-7-banner-制作" class="headerlink" title="1.7 banner 制作"></a>1.7 banner 制作</h3><img src="image-20210723180719138.png" alt="image-20210723180719138" style="zoom: 67%;"><ul><li>1 号盒子是通栏的大盒子 banner，不给宽度，给高度，给一个蓝色背景 </li><li>2 号盒子是版心，要水平居中对齐 </li><li>3 号盒子版心内，左对齐 subnav 侧导航栏 </li><li>4 号盒子版心内，右对齐 course 课程</li></ul><h3 id="1-8-精品推荐小模块"><a href="#1-8-精品推荐小模块" class="headerlink" title="1.8 精品推荐小模块"></a>1.8 精品推荐小模块</h3><img src="image-20210723181001430.png" alt="image-20210723181001430" style="zoom:67%;"><h3 id="1-9-精品推荐大模块"><a href="#1-9-精品推荐大模块" class="headerlink" title="1.9 精品推荐大模块"></a>1.9 精品推荐大模块</h3><img src="image-20210723180853694.png" alt="image-20210723180853694" style="zoom:67%;"><img src="image-20210723180903393.png" alt="image-20210723180903393" style="zoom:67%;"><h3 id="1-10-底部模块"><a href="#1-10-底部模块" class="headerlink" title="1.10 底部模块"></a>1.10 底部模块</h3><img src="image-20210723180914636.png" alt="image-20210723180914636" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础总结 4/7</title>
      <link href="/2021/07/22/css-4-7/"/>
      <url>/2021/07/22/css-4-7/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础总结-4-7"><a href="#CSS-基础总结-4-7" class="headerlink" title="CSS 基础总结 4/7"></a>CSS 基础总结 4/7</h1><h2 id="1-浮动"><a href="#1-浮动" class="headerlink" title="1 浮动"></a>1 浮动</h2><h3 id="1-1-传统网页布局的三种方式"><a href="#1-1-传统网页布局的三种方式" class="headerlink" title="1.1 传统网页布局的三种方式"></a>1.1 传统网页布局的三种方式</h3><p>CSS 提供了三种传统布局方式（简单说，就是盒子如何进行排列顺序）：</p><ul><li>普通流（标准流）</li><li>浮动 </li><li>定位</li></ul><h3 id="1-2-标准流（普通流-文档流）"><a href="#1-2-标准流（普通流-文档流）" class="headerlink" title="1.2 标准流（普通流/文档流）"></a>1.2 标准流（普通流/文档流）</h3><p>所谓的标准流: 就是标签按照规定好默认方式排列。</p><ol><li><p>块级元素会独占一行，从上向下顺序排列。</p><p>常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table</p></li><li><p>行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。 </p><p>常用元素：span、a、i、em 等 </p></li></ol><p>以上都是标准流布局，标准流是最基本的布局方式。 </p><p>这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了。</p><p>注意：实际开发中，一个页面基本都包含了这三种布局方式（后面移动端学习新的布局方式） 。</p><h3 id="1-3-为什么需要浮动？"><a href="#1-3-为什么需要浮动？" class="headerlink" title="1.3 为什么需要浮动？"></a>1.3 为什么需要浮动？</h3><p>有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。 因为浮动可以改变元素标签默认的排列方式。</p><p>浮动最典型的应用：可以让多个块级元素一行内排列显示。</p><p>网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。</p><h3 id="1-4-什么是浮动？"><a href="#1-4-什么是浮动？" class="headerlink" title="1.4 什么是浮动？"></a>1.4 什么是浮动？</h3><p>float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。 </p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">选择器 { float: 属性值; }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20210722161806165.png" alt="image-20210722161806165"></p><h3 id="1-5-浮动特性（重难点）"><a href="#1-5-浮动特性（重难点）" class="headerlink" title="1.5 浮动特性（重难点）"></a>1.5 浮动特性（重难点）</h3><ol><li>浮动元素会脱离标准流(脱标) </li><li>浮动的元素会一行内显示并且元素顶部对齐，不再保留原先的位置</li></ol><img src="image-20210722162037219.png" alt="image-20210722162037219" style="zoom: 80%;"><p><strong>注意：</strong> 浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子， 多出的盒子 会另起一行对齐。</p><ol start="3"><li>浮动的元素会具有行内块元素的特性</li></ol><p>任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有行内块元素相似的特性。 </p><ol><li>如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定 </li><li>浮动的盒子中间是没有缝隙的，是紧挨着一起的 </li><li>行内元素同理</li></ol><h3 id="1-6-浮动元素经常和标准流父级搭配使用"><a href="#1-6-浮动元素经常和标准流父级搭配使用" class="headerlink" title="1.6 浮动元素经常和标准流父级搭配使用"></a>1.6 浮动元素经常和标准流父级搭配使用</h3><p>为了约束浮动元素位置, 我们网页布局一般采取的策略是: </p><p><strong>先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置. 符合网页布局第一准侧。</strong></p><img src="image-20210722162441275.png" alt="image-20210722162441275" style="zoom: 50%;"><h2 id="2-常见网页布局"><a href="#2-常见网页布局" class="headerlink" title="2 常见网页布局"></a>2 常见网页布局</h2><h3 id="2-1-常见网页布局"><a href="#2-1-常见网页布局" class="headerlink" title="2.1 常见网页布局"></a>2.1 常见网页布局</h3><img src="image-20210722162619700.png" alt="image-20210722162619700" style="zoom: 67%;"><img src="image-20210722162642358.png" alt="image-20210722162642358" style="zoom:67%;"><h3 id="2-2-浮动布局注意点"><a href="#2-2-浮动布局注意点" class="headerlink" title="2.2 浮动布局注意点"></a>2.2 浮动布局注意点</h3><ol><li><p>浮动和标准流的父盒子搭配</p><p>先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置</p></li><li><p>一个元素浮动了，理论上其余的兄弟元素也要浮动</p><p>一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动，以防止引起问题。 </p><p>浮动的盒子只会影响浮动盒子后面的标准流,不会影响前面的标准流。</p></li></ol><h2 id="3-清除浮动"><a href="#3-清除浮动" class="headerlink" title="3 清除浮动"></a>3 清除浮动</h2><h3 id="3-1-为什么需要清除浮动？"><a href="#3-1-为什么需要清除浮动？" class="headerlink" title="3.1 为什么需要清除浮动？"></a>3.1 为什么需要清除浮动？</h3><p>由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子。</p><img src="image-20210722163018664.png" alt="image-20210722163018664" style="zoom: 67%;"><p>由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响。</p><h3 id="3-2-清除浮动本质"><a href="#3-2-清除浮动本质" class="headerlink" title="3.2 清除浮动本质"></a>3.2 清除浮动本质</h3><ul><li>清除浮动的本质是清除浮动元素造成的影响 </li><li>如果父盒子本身有高度，则不需要清除浮动 </li><li><strong>清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</strong></li></ul><h3 id="3-3-清除浮动的方法"><a href="#3-3-清除浮动的方法" class="headerlink" title="3.3 清除浮动的方法"></a>3.3 清除浮动的方法</h3><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">选择器{clear:属性值;} <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20210722163237967.png" alt="image-20210722163237967"></p><p>我们实际工作中， 几乎只用 <strong>clear: both</strong>; </p><p><strong>清除浮动的策略是：闭合浮动</strong>，只让浮动在父盒子内部影响,不影响父盒子外面的其他盒子。</p><p><strong>清楚浮动的方法：</strong></p><ol><li>额外标签法，也称为隔墙法，是 W3C 推荐的做法</li><li>父级添加 overflow 属性 </li><li>父级添加after伪元素 </li><li>父级添加双伪元素</li></ol><h4 id="3-3-1-额外标签法"><a href="#3-3-1-额外标签法" class="headerlink" title="3.3.1 额外标签法"></a>3.3.1 额外标签法</h4><p>额外标签法也称为隔墙法，是 W3C 推荐的做法。 </p><p>额外标签法会在浮动元素末尾添加一个空的标签。例如 <code>&lt;div style=" clear:both”&gt;&lt;/div&gt;</code> ，或者其他标签 （如 <code>&lt;br/&gt;</code> 等）。 </p><ul><li>优点： 通俗易懂，书写方便 </li><li>缺点： 添加许多无意义的标签，结构化较差 </li></ul><p>注意： 要求这个新的空标签必须是块级元素。</p><p>该方法不常用。</p><h4 id="3-3-2-父级添加-overflow"><a href="#3-3-2-父级添加-overflow" class="headerlink" title="3.3.2 父级添加 overflow"></a>3.3.2 父级添加 overflow</h4><p>可以给<strong>父级</strong>添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll 。 </p><ul><li>优点：代码简洁 </li><li>缺点：无法显示溢出的部分</li></ul><h4 id="3-3-3-after-伪元素法"><a href="#3-3-3-after-伪元素法" class="headerlink" title="3.3.3 :after 伪元素法"></a>3.3.3 :after 伪元素法</h4><p>:after 方式是额外标签法的升级版。也是给父元素添加：</p><pre class="line-numbers language-none"><code class="language-none">.clearfix:after {  content: "";  display: block;  height: 0;  clear: both;  visibility: hidden; } .clearfix { /* IE6、7 专有 */  *zoom: 1;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>优点：没有增加标签，结构更简单 </li><li>缺点：要去照顾低版本浏览器 </li><li>代表网站： 百度、淘宝网、网易等</li></ul><h4 id="3-3-4-双伪元素清除浮动"><a href="#3-3-4-双伪元素清除浮动" class="headerlink" title="3.3.4 双伪元素清除浮动"></a>3.3.4 双伪元素清除浮动</h4><p>也是给父元素添加：</p><pre class="line-numbers language-none"><code class="language-none">.clearfix:before,.clearfix:after { content:""; display:table; }.clearfix:after { clear:both;}.clearfix { *zoom:1;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>优点：代码更简洁 </li><li>缺点：要去照顾低版本浏览器 </li><li>代表网站：小米、腾讯等</li></ul><h3 id="3-4-清除浮动总结"><a href="#3-4-清除浮动总结" class="headerlink" title="3.4 清除浮动总结"></a>3.4 清除浮动总结</h3><p>为什么需要清除浮动？</p><ol><li>父级没高度。 </li><li>子盒子浮动了。 </li><li>影响下面布局了。</li></ol><p><img src="image-20210722164105476.png" alt="image-20210722164105476"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法基础归纳</title>
      <link href="/2021/07/21/suan-fa-ji-chu-gui-na/"/>
      <url>/2021/07/21/suan-fa-ji-chu-gui-na/</url>
      
        <content type="html"><![CDATA[<h1 id="算法设计与分析基础"><a href="#算法设计与分析基础" class="headerlink" title="算法设计与分析基础"></a>算法设计与分析基础</h1><h2 id="1-算法基础"><a href="#1-算法基础" class="headerlink" title="1. 算法基础"></a>1. 算法基础</h2><h3 id="1-1-渐进复杂度分析"><a href="#1-1-渐进复杂度分析" class="headerlink" title="1.1 渐进复杂度分析"></a>1.1 渐进复杂度分析</h3><h4 id="1-1-1-概述"><a href="#1-1-1-概述" class="headerlink" title="1.1.1 概述"></a>1.1.1 概述</h4><p>时间复杂度，空间复杂度  只考虑最高阶</p><h4 id="1-1-2-渐进复杂度分析"><a href="#1-1-2-渐进复杂度分析" class="headerlink" title="1.1.2 渐进复杂度分析"></a>1.1.2 渐进复杂度分析</h4><ol><li><p>大O，渐进上界记号，上界越低越准确，越有意义</p><p>如果存在两个正的常数c和n0，对于任意n≥n0，都有f(n)≤c×g(n)，则记为f(n)=O(g(n)),即g(n)为f(n)的上界。</p></li><li><p>大Ω，渐进下界记号</p></li><li><p>大Θ，渐进紧界记号</p></li></ol><p>重要结论：</p><ol><li><p>如果T1(n)=O(f(n))，T2(n)=O(g(n)),那么</p><ol><li><p>T1(n)+T2(n)= O(f(n)+g(n)) </p></li><li><p>T1(n)*T2(n)= O(f(n)*g(n)) </p></li></ol></li><li><p>对任意常数k，(logn)^k ≤ O(n)。</p></li></ol><p>(说明n的增长要快于log2n的任意次幂)</p><p>O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n2)&lt;O(n3)O(2^n)&lt;O(n!)&lt;O(n^n)</p><h4 id="1-1-3-算法的最好、最坏和平均情况"><a href="#1-1-3-算法的最好、最坏和平均情况" class="headerlink" title="1.1.3 算法的最好、最坏和平均情况"></a>1.1.3 算法的最好、最坏和平均情况</h4><p>通常算最坏情况，因为一般平均情况就是最坏情况</p><h4 id="1-1-4-时间复杂度分析的一般步骤"><a href="#1-1-4-时间复杂度分析的一般步骤" class="headerlink" title="1.1.4 时间复杂度分析的一般步骤"></a>1.1.4 时间复杂度分析的一般步骤</h4><h4 id="1-1-5-渐进空间复杂度分析"><a href="#1-1-5-渐进空间复杂度分析" class="headerlink" title="1.1.5 渐进空间复杂度分析"></a>1.1.5 渐进空间复杂度分析</h4><p>只考察临时变量所占空间，S(n)=O(g(n))、Ω(g(n))或Θ(g(n))</p><p>不考虑形参的空间，因为调用该算法的时候计算过一次</p><h3 id="1-2-递归方程及其求解方法"><a href="#1-2-递归方程及其求解方法" class="headerlink" title="1.2 递归方程及其求解方法"></a>1.2 递归方程及其求解方法</h3><ol><li><p>递归算法复杂度分析<br> 建立方程、求解方程、用渐进符号表示函数的阶</p></li><li><p>建立递归方程</p></li><li><p>求解递归方程</p><ol><li><p>代入法</p></li><li><p>递归树法</p></li><li><p>迭代法</p><p>从初始递归方程开始，反复用递归方程右边的等式代入左边的函数，直到得到初值。</p></li><li><p>主方法</p><p>T(n)=aT(n/b)+f(n)</p><img src="image-20210721063927567.png" alt="image-20210721063927567" style="zoom: 50%;"><p>不相等时，f(n)比n^log(b⁡)a大或小n^ε倍，否则主方法不成立，例如：logn&lt;n^ε</p></li></ol></li></ol><h2 id="2-分治法"><a href="#2-分治法" class="headerlink" title="2 分治法"></a>2 分治法</h2><h3 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h3><h4 id="2-1-1条件"><a href="#2-1-1条件" class="headerlink" title="2.1.1条件"></a>2.1.1条件</h4><ol><li><p>原问题与子问题形式相</p></li><li><p>不含公共子问题</p></li><li><p>子问题足够小的时候很容易求解</p></li></ol><h4 id="2-1-2步骤"><a href="#2-1-2步骤" class="headerlink" title="2.1.2步骤"></a>2.1.2步骤</h4><ol><li><p>划分：较小，相互独立的子问题</p></li><li><p>求解：容易求解则求解，不容易则递归</p></li><li><p>合并：子问题的解合并为原问题的解<br>k个子问题   k=1,减治法    k=2,二分法</p></li></ol><h4 id="2-1-3-求O-n"><a href="#2-1-3-求O-n" class="headerlink" title="2.1.3 求O(n)"></a>2.1.3 求O(n)</h4><p>主方法</p><h3 id="2-2-排序问题"><a href="#2-2-排序问题" class="headerlink" title="2.2 排序问题"></a>2.2 排序问题</h3><h4 id="2-2-1-快速排序-二分法"><a href="#2-2-1-快速排序-二分法" class="headerlink" title="2.2.1 快速排序  二分法"></a>2.2.1 快速排序  二分法</h4><p>平均(最好)时间复杂度: T(n) = O(nlogn)</p><p>最坏时间复杂度: T(n) = O(n2)</p><p>平均(最好)空间复杂度：O(logn)</p><p>最坏情况下空间复杂度：O(n)</p><h4 id="2-2-2-归并排序-二分法"><a href="#2-2-2-归并排序-二分法" class="headerlink" title="2.2.2 归并排序  二分法"></a>2.2.2 归并排序  二分法</h4><p>自底向上    T(n)=O(nlogn)</p><p>自顶向下    T(n)=O(nlogn)   S(n)=O(n)</p><h3 id="2-3-查找问题"><a href="#2-3-查找问题" class="headerlink" title="2.3 查找问题"></a>2.3 查找问题</h3><h4 id="2-3-1-折半查找-减治法"><a href="#2-3-1-折半查找-减治法" class="headerlink" title="2.3.1 折半查找   减治法"></a>2.3.1 折半查找   减治法</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/*给定有序数组R[low,high],输出值为k的元素的下表*/#include&lt;iostream&gt;using namespace std;int binSearch(int *R,int low,int high,int k){    int mid=(low+high)/2;    if(high&lt;low)    return -1;    if(k==R[mid])   return mid;    else if(k&lt;R[mid])   return binSearch(R,low,mid-1,k);    else return binSearch(R,mid+1,high,k);}int main(){    int R[7]={0,1,2,5,7,8,9};//第0位空出    int n=6,k=5;    int result=binSearch(R,1,n,k);    cout&lt;&lt;result;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-2-查找第k小元素-减治法"><a href="#2-3-2-查找第k小元素-减治法" class="headerlink" title="2.3.2 查找第k小元素     减治法"></a>2.3.2 查找第k小元素     减治法</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/*设无序序列 T =(r1, r2, …, rn)，T 的第k（1≤k≤n）小元素定义为T按升序排列后在第k个位置上的元素。给定一个序列T和一个整数k，寻找 T 的第k小元素的问题称为选择问题。算法——选择问题输入：无序序列{R1, R2, …, Rn}，位置k输出：返回第k小的元素值1.设置初始查找区间：i=1，j=n;2.以Ri为轴值对序列Ri~Rj进行一次划分，得到轴值的位置s;3.将轴值位置s与k比较  3.1 如果k=s，则将Rs作为结果返回；  3.2 如果k&lt;s，则j=s-1，转步骤2；  3.3 如果k&gt;s, 则i=s+1，转步骤2。*/#include&lt;iostream&gt;using namespace std;int partition(int *R,int s,int t){    R[0]=R[s];    int i=s,j=t;    while(i!=j){        while(j&gt;i&amp;&amp;R[j]&gt;=R[0])   j--;        R[i]=R[j];        while(i&lt;j&amp;&amp;R[i]&lt;=R[0])   i++;        R[j]=R[i];    }    R[i]=R[0];    return i;}int quickSelect(int *R,int s,int t,int k){    int i;    if(s&lt;t){        i=partition(R,s,t);        if(i==k)    return R[i];        else if(i&lt;k)    return quickSelect(R,i+1,t,k);        else if(i&gt;k)    return quickSelect(R,s,i-1,k);    }    else if(s==t&amp;&amp;s==k)    return R[s];}int main(){    int R[13]={0,5,3,8,1,10,6,9,12,17,4,15,22};    int k=6;//答案为8    int ans=quickSelect(R,1,12,k);    cout&lt;&lt;ans;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个问题虽然说是将原问题分解成了两个子问题，但是每次递归只选择了其中的一个子问题求解，不涉及问题的合并，所以是减治法。</p><h3 id="2-4-组合问题"><a href="#2-4-组合问题" class="headerlink" title="2.4 组合问题"></a>2.4 组合问题</h3><h4 id="2-4-1-最大子段问题"><a href="#2-4-1-最大子段问题" class="headerlink" title="2.4.1 最大子段问题"></a>2.4.1 最大子段问题</h4><ol><li><p>二分法</p><p>分为左边、右边、中间一共三段，左右两边分别递归，中间部分求mid左边的最大和s1以及右边的最大和s2,再相加得s1+s2</p><p>T(n)=O(nlogn)</p></li><li><p>在线处理法  有代码</p><p>仅扫描一次，T(n)=O(n)</p></li></ol><h4 id="2-4-2-棋盘覆盖问题-几何问题-分治法-四分"><a href="#2-4-2-棋盘覆盖问题-几何问题-分治法-四分" class="headerlink" title="2.4.2 棋盘覆盖问题  几何问题 分治法(四分)"></a>2.4.2 棋盘覆盖问题  几何问题 分治法(四分)</h4><h2 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3 动态规划"></a>3 动态规划</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>解决多阶段决策问题，用一个表来记录已解决的子问题</p><h4 id="3-1-1-条件"><a href="#3-1-1-条件" class="headerlink" title="3.1.1 条件"></a>3.1.1 条件</h4><ol><li><p>最优子结构，最优解包含的子问题的解也是最优的(反证法证明)</p></li><li><p>有重叠子问题</p></li><li><p>无后效性，某一状态一旦确定，不受以后决策的影响</p></li></ol><h4 id="3-1-2-步骤"><a href="#3-1-2-步骤" class="headerlink" title="3.1.2 步骤"></a>3.1.2 步骤</h4><ol><li><p>划分子问题</p></li><li><p>确定动态规划函数</p></li><li><p>填表，自底向上的计算最优解dp并保存，同时记录path信息</p></li><li><p>构造最优解，通过path信息回溯到得到最优解的过程</p></li></ol><h4 id="3-1-3-求O-n"><a href="#3-1-3-求O-n" class="headerlink" title="3.1.3 求O(n)"></a>3.1.3 求O(n)</h4><p>一般是看算法程序里有几层循环，有t层的话T(n)=O(n^t)</p><p>备忘录法的时间复杂度与一般动态规划相等，因为备忘录的最坏情况相当于一般动态规划</p><h3 id="3-2-求解树塔问题（三角形最长路径）"><a href="#3-2-求解树塔问题（三角形最长路径）" class="headerlink" title="3.2 求解树塔问题（三角形最长路径）"></a>3.2 求解树塔问题（三角形最长路径）</h3><ol><li><p>递归法 重复计算效率低</p></li><li><p>备忘录方法（自顶向下）</p><p>求解出的结果放在 dp 中，相同问题只计算一次，是一般动态规划方法的变形</p><p>代码就是在一般的递归法中加入一个查表的动作，查到以后直接输出结果，不需要重复计算；当需要计算的时候，要将结果返回之前保存到dp数组中</p></li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int a[6][6] = {0, 0, 0, 0, 0, 0,               0, 8, 0, 0, 0, 0,               0, 12, 15, 0, 0, 0,               0, 3, 9, 6, 0, 0,               0, 8, 10, 5, 12, 0,               0, 16, 4, 18, 10, 9};int m[6][6];int n = 5;int maxSum(int i, int j){    if (m[i][j] != -1)        return m[i][j];    if (i == n)        m[i][j] = a[i][j];    else    {        int x = maxSum(i + 1, j);        int y = maxSum(i + 1, j + 1);        m[i][j] = max(x, y) + a[i][j];    }    return m[i][j];}int main(){    memset(m, -1, sizeof(m));    cout &lt;&lt; maxSum(1, 1) &lt;&lt; endl;} //answer=60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>动态规划（自底向上）</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int a[6][6] = {0, 0, 0, 0, 0, 0,               0, 8, 0, 0, 0, 0,               0, 12, 15, 0, 0, 0,               0, 3, 9, 6, 0, 0,               0, 8, 10, 5, 12, 0,               0, 16, 4, 18, 10, 9};int n = 5;int maxSum(){    int i, j;    for (i = n - 1; i &gt;= 1; i--)    {        for (j = 1; j &lt;= i; j++)        {            a[i][j] = max(a[i + 1][j], a[i + 1][j + 1]) + a[i][j];        }    }    return a[1][1];}int main(){    cout &lt;&lt; maxSum() &lt;&lt; endl;} //answer=60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-最长递增子序列问题"><a href="#3-3-最长递增子序列问题" class="headerlink" title="3.3 最长递增子序列问题"></a>3.3 最长递增子序列问题</h3><p>动态规划</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define MAX 30//问题表示int a[] = {-1, 2, 1, 5, 3, 6, 4, 8, 9, 7}; //第0位空出int n = sizeof(a) / sizeof(a[0]);//求解结果表示int dp[MAX];void solve(){    dp[1] = 1;    for (int i = 2; i &lt;= n; i++)    {        dp[1] = 1;        for (int k = 1; k &lt; i; k++)        {            if (a[k] &lt; a[i] &amp;&amp; dp[i] &lt; dp[k] + 1)            {                dp[i] = dp[k] + 1;            }        }    }}int main(){    solve();    cout &lt;&lt; dp[n] &lt;&lt; endl;    return 0;} //answer=4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-最长公共子序列问题"><a href="#3-4-最长公共子序列问题" class="headerlink" title="3.4 最长公共子序列问题"></a>3.4 最长公共子序列问题</h3><p>动态规划</p><ol><li>通过 dp 求最优解 </li><li>通过 vector 回溯求最优解</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//类似0-1背包问题#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;//可以用vector向量回溯路径，本方法没有用到#include &lt;cstring&gt;using namespace std;#define MAX 51 //序列中最多的字符个数//问题表示string x = "abcbdb", y = "acbbabdbb"; //两个待求解序列int dp[MAX][MAX];                     //动态规划数组vector&lt;char&gt; subs;                    //存放LCSint trace[MAX];void LCSlength(){    //边界条件在初始化中已完成    for (int i = 1; i &lt;= x.length(); i++)    {        for (int j = 1; j &lt;= y.length(); j++)        {            //最后一个字符相等            if (x[i - 1] == y[j - 1])                dp[i][j] = dp[i - 1][j - 1] + 1;            //最后一个字符不相等            else                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);        }    }}void traceBack(){    int i = x.length(), j = y.length();    while (i != 0 &amp;&amp; j != 0)    {        //最后一个字符相等只有一种情况，        //就是dp[i-1][j-1]=dp[i][j]且dp[i][j]!=dp[i][j-1]且dp[i][j]!=dp[i-1][j]        if (dp[i][j] == dp[i][j - 1])        {            j = j - 1;            trace[i] = 0;        }        //这里要注意，因为先往左边找，再往上边找，所求的相同字符就在x字符串中        //如果先往上面找，则结论相反        else if (dp[i][j] == dp[i - 1][j])        {            i = i - 1;            trace[i] = 0;        }        else        {            trace[i] = 1;            i = i - 1;            j = j - 1;        }    }    for(int i=1;i&lt;=x.length();i++){        if (trace[i] != 0)        {            cout &lt;&lt; x[i-1] &lt;&lt; " ";        }    }}int main(){    memset(dp, 0, sizeof(dp));    memset(trace, 0, sizeof(trace));    LCSlength();    cout &lt;&lt; dp[x.length()][y.length()]&lt;&lt;endl;    traceBack();    } //answer=5,abbdb或acbdb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-0-1背包问题"><a href="#3-5-0-1背包问题" class="headerlink" title="3.5 0/1背包问题"></a>3.5 0/1背包问题</h3><p>动态规划</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 30//问题表示int n = 5, C = 10;                //5种物品,限制重量不超过10int w[MAXN] = {0, 2, 2, 6, 5, 4}; //下标0不用int v[MAXN] = {0, 6, 3, 5, 4, 6}; //下标0不用//求解结果表示int dp[MAXN][MAXN]; //i,rint x[MAXN];        //存放最优解int maxv;           //存放最优解的总价值void knapSack(){    //边界条件已在初始化中完成    for (int i = 1; i &lt;= n; i++)    { //第i件        for (int j = 1; j &lt;= C; j++)        { //剩余价值            //放不下            if (j &lt; w[i])            {                dp[i][j] = dp[i - 1][j];            }            //放得下的情况下，放还是不放？            else            {                dp[i][j] = max(dp[i - 1][j - w[i]] + v[i], dp[i - 1][j]);            }        }    }}void traceBack() //回推找到最优解{    int i = n, j = C; //从最后一个开始找    while (i != 0)    {        //前一个没放入        if (dp[i][j] == dp[i - 1][j])        {            x[i] = 0;        }        //放入了        else        {            x[i] = 1;            j = j - w[i];        }        i--; //回到上一层    }}int main(){    memset(dp, 0, sizeof(dp));    memset(x,0,sizeof(x));    knapSack();    maxv = dp[n][C];    cout &lt;&lt; maxv &lt;&lt; endl;    traceBack();    for(int i=1;i&lt;=n;i++){        if(x[i]==1){            cout&lt;&lt;i&lt;&lt;" ";        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-最优连乘矩阵问题"><a href="#3-6-最优连乘矩阵问题" class="headerlink" title="3.6 最优连乘矩阵问题"></a>3.6 最优连乘矩阵问题</h3><ol><li><p>动态规划</p></li><li><p>备忘录</p></li></ol><h3 id="3-7-TSP问题（旅行商问题）"><a href="#3-7-TSP问题（旅行商问题）" class="headerlink" title="3.7 TSP问题（旅行商问题）"></a>3.7 TSP问题（旅行商问题）</h3><p>动态规划</p><h2 id="4-贪心算法"><a href="#4-贪心算法" class="headerlink" title="4 贪心算法"></a>4 贪心算法</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>通常获得近似最优解</p><h4 id="4-1-1-条件"><a href="#4-1-1-条件" class="headerlink" title="4.1.1 条件"></a>4.1.1 条件</h4><ol><li><p>最优子结构</p></li><li><p>贪心选择性质：全局最优解可以通过一系列局部最优解得到</p><p>证明：数学归纳法</p><ol><li><p>问题的最优解可以修改为以贪心选择开始</p></li><li><p>贪心选择之后，原问题简化为一个更小的类似子问题</p></li><li><p>数学归纳法证明：通过每一步贪心选择，最终可获得以一个整体最优解</p></li></ol></li></ol><h4 id="4-1-2-步骤"><a href="#4-1-2-步骤" class="headerlink" title="4.1.2 步骤"></a>4.1.2 步骤</h4><p>1.分解</p><p>分解为若干个决策阶段，得到若干个决策子问题</p><p>2.决策</p><p>得到每个阶段的局部最优解，并缩小待求解问题的规模</p><p>3.合并</p><p>将各个阶段的局部最优解合并为全局最优解</p><p>0.有关概念</p><p>候选集和</p><p>解集合</p><p>选择函数：运用贪心策略指出哪个对象最有希望构成最优解</p><p>可行函数：判断加入新对象时是否可行</p><p>解决函数：判断是否构成完整解</p><h4 id="4-1-3（重点）与动态规划法比较"><a href="#4-1-3（重点）与动态规划法比较" class="headerlink" title="4.1.3（重点）与动态规划法比较"></a>4.1.3（重点）与动态规划法比较</h4><ol><li><p>相同点：都具有最优子结构性质</p></li><li><p>不同点：</p><ol><li><p>求解思路</p><p>动态规划：自底向上求解，求解过程依赖于子问题的解，在求出子问题之后再做出选择</p><p>贪心算法：自顶向下求解，求解过程不依赖于子问题的解，仅在当前状态下做出最好的选择，即局部最优选择</p></li><li><p>适用问题</p><p>动态规划：重叠子问题</p><p>贪心算法：贪心选择性质</p></li></ol></li></ol><h3 id="4-2-图着色问题"><a href="#4-2-图着色问题" class="headerlink" title="4.2 图着色问题"></a>4.2 图着色问题</h3><h3 id="4-3-TSP问题"><a href="#4-3-TSP问题" class="headerlink" title="4.3 TSP问题"></a>4.3 TSP问题</h3><h3 id="4-4-部分背包问题"><a href="#4-4-部分背包问题" class="headerlink" title="4.4 部分背包问题"></a>4.4 部分背包问题</h3><p>贪心算法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 6//问题表示int n = 5;double C = 100; //限重struct NodeType{    double w;    double v;    double p; //p=v/w    bool operator&lt;(const NodeType &amp;s) const    {        return p &gt; s.p; //按p递减排序    }};NodeType P[] = {{0}, {10, 20}, {20, 30}, {30, 66}, {40, 40}, {50, 60}}; //下标0不用//求解结果表示double V; //最大价值double x[MAXN];void Knap() //求解背包问题并返回总价值{    V = 0;                   //V初始化为0    double r = C;            //背包中能装入的余下重量    memset(x, 0, sizeof(x)); //初始化x向量    int i = 1;    while (P[i].w &lt; r) //物品i能够全部装入时循环    {        x[i] = 1;    //装入物品i        r -= P[i].w; //减少背包中能装入的余下重量        V += P[i].v; //累计总价值        i++;         //继续循环    }    if (r &gt; 0) //当余下重量大于0    {        x[i] = r / P[i].w;  //将物品i的一部分装入        V += x[i] * P[i].v; //累计总价值    }}int main(){    for (int i = 1; i &lt;= n; i++) //求v/w        P[i].p = P[i].v / P[i].w;    sort(P + 1, P + n + 1); //A[1..n]排序    Knap();    for (int j = 1; j &lt;= n; j++)        printf("%.2f, ", x[j]);    printf("Total Value=%.2f\n", V);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-5-活动安排问题"><a href="#4-5-活动安排问题" class="headerlink" title="4.5 活动安排问题"></a>4.5 活动安排问题</h3><p>贪心算法</p><p>贪心策略：剩余时间最大化，即按最早结束时间选择</p><p>证明：</p><ol><li><p>贪心选择性质：若1不是第一个选中的活动，而k是，可以证明e1≤ek的，所以一定存在一个以1开始的最优解</p></li><li><p>最优子结构：反证法，当一个问题的子解X-{1}=X’不是子问题的最优解，而Y’是最优解，则可以证明{1}+Y’是问题的最优解，这与前提相矛盾</p></li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;//问题表示struct Action //活动的类型声明{    int i;                                //活动标号    int b;                                //活动起始时间    int e;                                //活动结束时间    bool operator&lt;(const Action &amp;s) const //重载&lt;关系函数    {        return e &lt;= s.e; //用于按活动结束时间递增排序    }};int n = 11; //活动数int totalTime = 15;int order[12];Action a[] = {{0}, {1, 3, 5}, {2, 5, 7}, {3, 3, 8}, {4, 1, 4}, {5, 5, 9}, {6, 2, 13}, {7, 12, 15}, {8, 6, 10}, {9, 8, 11}, {10, 8, 12}, {11, 0, 6}};int greedy(){    int selected = 1; //选择第一个活动A[1]    int ans = 1;    order[1] = 1;    for (int i = 2; i &lt;= n; i++)     //扫描所有活动        if (a[i].b &gt;= a[selected].e) //找到一个相容活动        {            order[i] = 1;            selected = i; //选择A[i]活动            ans++;        }    return ans;}int main(){    memset(order, 0, sizeof(order));    sort(a + 1, a + n + 1);    cout &lt;&lt; "Max activity number:" &lt;&lt; greedy() &lt;&lt; endl;    for (int i = 1; i &lt;= n; i++)    {        if (order[i] == 1)        {            cout &lt;&lt; a[i].i &lt;&lt; " ";        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4 / 5 问题的解法都按照以下步骤：</p><ol><li><p>预处理：按照单位价值递减/最早结束时间递增排序</p></li><li><p>选择第一个活动</p></li><li><p>贪心选择后续活动，若不可行则结束选择</p></li></ol><h3 id="4-6-huffman编码问题"><a href="#4-6-huffman编码问题" class="headerlink" title="4.6 huffman编码问题"></a>4.6 huffman编码问题</h3><h3 id="4-7-dijkstra算法"><a href="#4-7-dijkstra算法" class="headerlink" title="4.7 dijkstra算法"></a>4.7 dijkstra算法</h3><h3 id="4-8-最小生成树问题"><a href="#4-8-最小生成树问题" class="headerlink" title="4.8 最小生成树问题"></a>4.8 最小生成树问题</h3><h2 id="5-回溯法"><a href="#5-回溯法" class="headerlink" title="5 回溯法"></a>5 回溯法</h2><h3 id="5-0-搜索算法的概述"><a href="#5-0-搜索算法的概述" class="headerlink" title="5.0 搜索算法的概述"></a>5.0 搜索算法的概述</h3><h4 id="5-0-1-问题的解"><a href="#5-0-1-问题的解" class="headerlink" title="5.0.1 问题的解"></a>5.0.1 问题的解</h4><p>可能解、可行解、最优解</p><h4 id="5-0-2-问题求解与搜索算法"><a href="#5-0-2-问题求解与搜索算法" class="headerlink" title="5.0.2 问题求解与搜索算法"></a>5.0.2 问题求解与搜索算法</h4><p>问题的表示：枚举对象、解的表示</p><p>求解的方法：递归、动态规划</p><p>搜索算法是一个通用的解法，设计树再遍历</p><p>还要进行优化，如剪枝用来避免无效搜索、启发式信息用来加速</p><h4 id="5-0-3-问题的解空间树"><a href="#5-0-3-问题的解空间树" class="headerlink" title="5.0.3 问题的解空间树"></a>5.0.3 问题的解空间树</h4><ol><li><p>概念</p></li><li><p>解空间树</p></li><li><p>解空间树可以形式化地定义为一个四元组（S，A，G，F）</p><p>S表示问题的初始状态，它是搜索的起点。</p><p>A是采取的操作符集合，初始状态和操作符隐含地定义了问题的解空间。</p><p>G表示目标测试，它判断给定的状态是否为目标状态。它可以是表示目标状态的一个状态集合，也可以是一个判定函数。</p><p>F代表路径耗散函数，它的定义需要具体问题具体分析。</p></li><li><p>搜索</p><p>就是在解空间树中从初始状态出发，执行特定的操作，试探地寻找目标状态的过程。</p></li><li><p>搜索的方法</p><p>枚举：DFS、BFS</p><p>枚举+优化：</p><ol><li><p>回溯算法：DFS+剪枝</p></li><li><p>分支限界算法：BFS+剪枝</p></li></ol><p>启发式搜索：基于规则的优化搜索算法</p><ol><li><p>DFS   stack</p></li><li><p>BFS   queue</p></li></ol></li></ol><h3 id="5-1-回溯法的概述"><a href="#5-1-回溯法的概述" class="headerlink" title="5.1 回溯法的概述"></a>5.1 回溯法的概述</h3><h4 id="5-1-1-设计思想"><a href="#5-1-1-设计思想" class="headerlink" title="5.1.1 设计思想"></a>5.1.1 设计思想</h4><ol><li><p>回溯=DFS+剪枝</p></li><li><p>剪枝策略</p><ol><li><p>约束函数剪枝(不可行解)</p><p>找到不合法的状态结点S，S的子树一定没有可行解</p></li><li><p>限界函数剪枝(非最优解)</p><p>最优化问题，访问的状态为S，存在一个判定函数，以S为根的子树不可能包含最优解</p></li><li><p>步骤</p><ol><li><p>针对所给问题，定义问题的状态表示，确定结点的扩展搜索规则，确定问题的解空间树；</p></li><li><p>以深度优先方式搜索解空间树，并在搜索过程中采用剪枝函数来避免无效搜索。</p></li></ol></li></ol></li></ol><h4 id="5-1-2-算法框架"><a href="#5-1-2-算法框架" class="headerlink" title="5.1.2 算法框架"></a>5.1.2 算法框架</h4><ol><li><p>递归回溯</p><ol><li><p>子集树</p></li><li><p>排列树</p></li></ol></li><li><p>迭代回溯</p></li><li><p>时空性能</p><ol><li><p>时间性能分析</p><p>最坏为指数阶：解空间树是子集树时对应算法的时间复杂度为O(2^n)(有或者没有)，排列树为O(n!)(全排列)。</p><p>一般情况下：加上剪枝策略后，回溯法的效率一般高于蛮力法。</p></li><li><p>空间性能分析</p><p>假设解空间树中从根结点到叶结点的最长路径的长度为h(n)，则回溯法所需的计算空间通常为O(h(n))。</p><p>显式地存储整个解空间则需要O(2^h(n))或O(h(n)!)内存空间。</p></li></ol></li></ol><h3 id="5-2-m着色问题"><a href="#5-2-m着色问题" class="headerlink" title="5.2 m着色问题"></a>5.2 m着色问题</h3><p>约束条件：相邻两点是否着色相同</p><p>T(n)=O(m^n)</p><h3 id="5-3-n皇后问题"><a href="#5-3-n皇后问题" class="headerlink" title="5.3 n皇后问题"></a>5.3 n皇后问题</h3><p>约束条件：每行或每列不存在两个元素，对角线上不存在两个元素</p><p>T(n)=O(n^n)</p><p>利用显式约束排除两个皇后在同一行或同一列的方法，可能解是（1,2，……,n）的一个排列，因此对应的解空间树中有n!个叶子节点，所以算法的时间复杂度可以降为O(n!) </p><h3 id="5-4-0-1背包问题"><a href="#5-4-0-1背包问题" class="headerlink" title="5.4 0-1背包问题"></a>5.4 0-1背包问题</h3><p>约束条件：剪除不可能获得可行解的子树</p><p>限界条件：剪除不可能获得最优解的子树</p><p>最坏复杂度即不考虑剪枝时的复杂度，T(n)=O(2^n)</p><h2 id="6-分支限界法"><a href="#6-分支限界法" class="headerlink" title="6 分支限界法"></a>6 分支限界法</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><h4 id="6-1-1-分支限界法"><a href="#6-1-1-分支限界法" class="headerlink" title="6.1.1 分支限界法"></a>6.1.1 分支限界法</h4><p>BFS+剪枝(限界)，找最优解</p><h4 id="6-1-2-设计思想"><a href="#6-1-2-设计思想" class="headerlink" title="6.1.2 设计思想"></a>6.1.2 设计思想</h4><ol><li><p>确定限界函数</p><ol><li>目标函数是求最大值：则设计上界限界函数ub，若si是sj的双亲结点，则满足ub(si)≥ub(sj)。当找到一个可行解ub(sk)后，将所有小于ub(sk)的结点剪枝。</li><li>目标函数是求最小值：则设计下界限界函数lb，若si是sj的双亲结点，则满足lb(si)≤lb(sj)。当找到一个可行解lb(sk)后，将所有大于lb(sk)的结点剪枝。</li></ol></li></ol><ol start="2"><li><p>组织待处理的活结点表</p><ol><li><p>队列式 queue</p></li><li><p>优先队列式 priority_queue</p><ol><li><p>计算起始结点（根结点）的优先级并加入优先队列（与特定问题相关的信息的函数值决定优先级）。</p></li><li><p>从优先队列中取出优先级最高的结点作为当前扩展结点，使搜索朝着解空间树上可能有最优解的分支推进，以便尽快地找出一个最优解。</p></li><li><p>对当前扩展结点，先从左到右地产生它的所有孩子结点，然后用约束条件检查，对所有满足约束条件的孩子结点计算优先级并加入优先队列。</p></li><li><p>重复步骤2和3，直到找到一个解或优先队列为空为止。</p></li></ol></li></ol></li><li><p>确定向量的各个分量</p><ol><li><p>对每个扩展结点保存从根结点到该结点的路径。         </p><p>每个结点带有一个可能的解向量。这种做法比较浪费空间，但实现起来简单，后面的示例均采用这种方式。</p></li><li><p>在搜索过程中构建搜索经过的树结构。</p><p>每个结点带有一个双亲结点指针，当找到最优解时，通过双亲指针找到对应的最优解向量。这种做法需保存搜索经过的树结构，每个结点增加一个指向双亲结点的指针。</p></li></ol></li><li><p>时间性能分析</p><p>在最坏情况下，时间复杂性是指数阶。</p></li></ol><h3 id="6-2-0-1背包问题"><a href="#6-2-0-1背包问题" class="headerlink" title="6.2 0-1背包问题"></a>6.2 0-1背包问题</h3><ol><li>队列式</li></ol><p>上界界限函数(贪心算法)</p><ol start="2"><li>优先队列式</li></ol><p>必须设计限界函数，因为优先级是以限界函数值为基础的</p><p>两种方法T(n)=O(2^n)</p><h3 id="6-3-TSP问题"><a href="#6-3-TSP问题" class="headerlink" title="6.3 TSP问题"></a>6.3 TSP问题</h3><ol><li><p>确定目标函数的下界lb。</p></li><li><p>确定目标函数值的计算方法（限界函数）。</p></li><li><p>基于下界，利用优先队列式分支限界法，搜索最优值和最优解。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础总结 3/7</title>
      <link href="/2021/07/20/css-3-7/"/>
      <url>/2021/07/20/css-3-7/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础总结-3-7"><a href="#CSS-基础总结-3-7" class="headerlink" title="CSS 基础总结 3/7"></a>CSS 基础总结 3/7</h1><h2 id="1-盒子模型"><a href="#1-盒子模型" class="headerlink" title="1 盒子模型"></a>1 盒子模型</h2><p>页面布局要学习三大核心：盒子模型，浮动和定位。学习好盒子模型能非常好的帮助我们布局页面。</p><h3 id="1-1-看透网页布局的本质"><a href="#1-1-看透网页布局的本质" class="headerlink" title="1.1 看透网页布局的本质"></a>1.1 看透网页布局的本质</h3><p>网页布局过程： </p><ol><li>先准备好相关的网页元素，网页元素基本都是盒子 Box 。 </li><li>利用 CSS 设置好盒子样式，然后摆放到相应位置。  </li><li>往盒子里面装内容。</li></ol><p>网页布局的核心本质： 就是利用 CSS 摆盒子。</p><h3 id="1-2-盒子模型（Box-Model）组成"><a href="#1-2-盒子模型（Box-Model）组成" class="headerlink" title="1.2 盒子模型（Box Model）组成"></a>1.2 盒子模型（Box Model）组成</h3><p><strong>盒子模型</strong>就是把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。</p><p>CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边框、外边距、内边距、和实际内容。</p><img src="image-20210720012136432.png" alt="image-20210720012136432"><h3 id="1-3-边框（border）"><a href="#1-3-边框（border）" class="headerlink" title="1.3 边框（border）"></a>1.3 边框（border）</h3><p>border可以设置元素的边框。边框有三部分组成：边框宽度(粗细)、边框样式、边框颜色。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">border : border-width border-style border-color<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20210720012238951.png" alt="image-20210720012238951"></p><p>边框样式 border-style 可以设置如下值：</p><ol><li>none：没有边框即忽略所有边框的宽度（默认值） </li><li>solid：边框为单实线(最为常用的) </li><li>dashed：边框为虚线  </li><li>dotted：边框为点线</li></ol><p>CSS 边框属性允许你指定一个元素边框的样式和颜色。</p><p>边框简写：</p><pre class="line-numbers language-none"><code class="language-none">border: 1px solid red; 没有顺序 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>边框分开写法：</p><pre class="line-numbers language-none"><code class="language-none">border-top: 1px solid red; /* 只设定上边框， 其余同理 */ <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-4-边框合并（border-collapse）"><a href="#1-4-边框合并（border-collapse）" class="headerlink" title="1.4 边框合并（border-collapse）"></a>1.4 边框合并（border-collapse）</h3><p>border-collapse 属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">border-collapse:collapse;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>border-collapse: collapse; 表示相邻边框合并在一起</li></ul><h3 id="1-5-边框会影响盒子实际大小"><a href="#1-5-边框会影响盒子实际大小" class="headerlink" title="1.5 边框会影响盒子实际大小"></a>1.5 边框会影响盒子实际大小</h3><p>边框会额外增加盒子的实际大小。</p><p>因此我们有两种方案解决: </p><ol><li>测量盒子大小的时候,不量边框</li><li>如果测量的时候包含了边框,则需要 width/height 减去边框宽度</li></ol><h3 id="1-6-内边距（padding）"><a href="#1-6-内边距（padding）" class="headerlink" title="1.6 内边距（padding）"></a>1.6 内边距（padding）</h3><p>padding 属性用于设置内边距，即边框与内容之间的距离。</p><p><img src="image-20210720171247931.png" alt="image-20210720171247931"></p><p>padding 属性可以有一到四个值。</p><p><img src="image-20210720171332665.png" alt="image-20210720171332665"></p><p>当我们给盒子指定 padding 值之后，发生了 2 件事情：</p><ol><li>内容和边框有了距离，添加了内边距。</li><li>padding影响了盒子实际大小。</li></ol><p>也就是说，如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子。</p><p><strong>解决方案：</strong> </p><p>如果保证盒子跟效果图大小保持一致，则让 width/height 减去多出来的内边距大小即可。</p><img src="image-20210720171713332.png" alt="image-20210720171713332" style="zoom: 80%;"><p>如何盒子本身没有指定width/height属性, 则此时padding不会撑开盒子大小。</p><h3 id="1-7-外边距（margin）"><a href="#1-7-外边距（margin）" class="headerlink" title="1.7 外边距（margin）"></a>1.7 外边距（margin）</h3><p>margin 属性用于设置外边距，即控制盒子和盒子之间的距离。</p><p><img src="image-20210720171801506.png" alt="image-20210720171801506"></p><p>margin 简写方式代表的意义跟 padding 完全一致。</p><p>外边距可以让块级盒子<strong>水平居中</strong>，但是必须满足两个条件：</p><ol><li>盒子必须指定了宽度（width）。 </li><li>盒子左右的外边距都设置为 auto 。</li></ol><pre class="line-numbers language-none"><code class="language-none">.header{ width:960px; margin:0 auto;}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常见的写法，以下三种都可以：</p><ul><li>margin-left: auto; margin-right: auto; </li><li>margin: auto; </li><li>margin: 0 auto;</li></ul><p>注意：以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 text-align:center 即可。</p><h3 id="1-8-外边距合并"><a href="#1-8-外边距合并" class="headerlink" title="1.8 外边距合并"></a>1.8 外边距合并</h3><p>使用 <strong>margin</strong> 定义块元素的<strong>垂直外边距</strong>时，可能会出现外边距的合并。</p><p>主要有两种情况: </p><ol><li><strong>相邻块元素垂直外边距的合并</strong></li></ol><p>当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。<strong>取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并。</strong></p><img src="image-20210720184210375.png" alt="image-20210720184210375" style="zoom: 80%;"><p><strong>解决方法：</strong></p><p>尽量只给一个盒子添加 margin 值。</p><ol start="2"><li><strong>嵌套块元素垂直外边距的塌陷</strong></li></ol><p>对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。</p><img src="image-20210720184357537.png" alt="image-20210720184357537" style="zoom: 80%;"><p><strong>解决方法：</strong> </p><ol><li>可以为父元素定义上边框。 </li><li>可以为父元素定义上内边距。 </li><li>可以为父元素添加 overflow:hidden。</li></ol><h3 id="1-9-清除内外边距"><a href="#1-9-清除内外边距" class="headerlink" title="1.9 清除内外边距"></a>1.9 清除内外边距</h3><p>网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。</p><pre class="line-numbers language-none"><code class="language-none">* { padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */ }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。但是转换为块级和行内块元素就可以。</p><h2 id="2-圆角边框-（border-radius）"><a href="#2-圆角边框-（border-radius）" class="headerlink" title="2 圆角边框 （border-radius）"></a>2 圆角边框 （border-radius）</h2><p>在 CSS3 中，新增了圆角边框样式，这样我们的盒子就可以变圆角了。</p><p><strong>border-radius</strong> 属性用于设置元素的外边框圆角。</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">border-radius:length;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>参数值可以为数值或百分比的形式 </li><li>如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为 50% </li><li>该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角 </li><li>分开可写为：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和 border-bottom-left-radius</li><li>兼容性 IE9+ 浏览器支持, 但是不会影响页面布局,可以放心使用.</li></ul><h2 id="3-盒子阴影-（box-shadow）"><a href="#3-盒子阴影-（box-shadow）" class="headerlink" title="3 盒子阴影 （box-shadow）"></a>3 盒子阴影 （box-shadow）</h2><p>CSS3 中新增了盒子阴影，我们可以使用 <strong>box-shadow</strong> 属性为盒子添加阴影。</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">box-shadow: h-shadow v-shadow blur spread color inset; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20210720184913803.png" alt="image-20210720184913803"></p><p><strong>注意：</strong> </p><ol><li>默认的是外阴影（outset），但是不可以写这个单词，否则造成阴影无效 </li><li>盒子阴影不占用空间，不会影响其他盒子排列</li></ol><h2 id="4-文字阴影-（text-shadow）"><a href="#4-文字阴影-（text-shadow）" class="headerlink" title="4 文字阴影 （text-shadow）"></a>4 文字阴影 （text-shadow）</h2><p>在 CSS3 中，我们可以使用 <strong>text-shadow</strong> 属性将阴影应用于文本。</p><p><strong>语法：</strong></p><pre class="line-numbers language-none"><code class="language-none">text-shadow: h-shadow v-shadow blur color;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20210720185059871.png" alt="image-20210720185059871"></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础总结 2/7</title>
      <link href="/2021/07/20/css-2-7/"/>
      <url>/2021/07/20/css-2-7/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础总结-2-7"><a href="#CSS-基础总结-2-7" class="headerlink" title="CSS 基础总结 2/7"></a>CSS 基础总结 2/7</h1><h2 id="0-Emmet-语法"><a href="#0-Emmet-语法" class="headerlink" title="0 Emmet 语法"></a>0 Emmet 语法</h2><h3 id="0-1-什么是-Emmet-语法"><a href="#0-1-什么是-Emmet-语法" class="headerlink" title="0.1 什么是 Emmet 语法"></a>0.1 什么是 Emmet 语法</h3><p>Emmet 语法的前身是 Zen coding ,它使用缩写来提高 HTML / CSS 的编写速度, VSCode内部已经集成该语法。</p><h3 id="0-2-快速生成HTML结构语法"><a href="#0-2-快速生成HTML结构语法" class="headerlink" title="0.2 快速生成HTML结构语法"></a>0.2 快速生成HTML结构语法</h3><table><thead><tr><th align="center">序号</th><th align="center">目的</th><th align="center">写法</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">多个相同标签</td><td align="center">标签 * 数字</td><td align="center">div*3</td></tr><tr><td align="center">2</td><td align="center">父子级关系的标签</td><td align="center">父标签 &gt; 子标签</td><td align="center">ul &gt; li</td></tr><tr><td align="center">3</td><td align="center">兄弟关系的标签</td><td align="center">兄弟标签 + 兄弟标签</td><td align="center">div+p</td></tr><tr><td align="center">4</td><td align="center">成带有类名或者id名字</td><td align="center">.类名 或 #id</td><td align="center">.demo 或 #two</td></tr><tr><td align="center">5</td><td align="center">类名是有顺序的</td><td align="center">自增符号 $</td><td align="center">div$*3</td></tr><tr><td align="center">6</td><td align="center">在生成的标签内部写内容</td><td align="center">用 { } 表示</td><td align="center">div{内容}</td></tr></tbody></table><h3 id="0-3-快速生成CSS样式语法"><a href="#0-3-快速生成CSS样式语法" class="headerlink" title="0.3 快速生成CSS样式语法"></a>0.3 快速生成CSS样式语法</h3><p>CSS 基本采取单词首字母简写形式即可。</p><p>比如 lh26px 可以生成 line-height: 26px。</p><h2 id="1-CSS-的三大特性"><a href="#1-CSS-的三大特性" class="headerlink" title="1 CSS 的三大特性"></a>1 CSS 的三大特性</h2><p>CSS 有三个非常重要的三个特性：层叠性、继承性、优先级。</p><h3 id="1-1-层叠性"><a href="#1-1-层叠性" class="headerlink" title="1.1 层叠性"></a>1.1 层叠性</h3><p><strong>相同选择器</strong>给设置相同的样式，此时一个样式就会<strong>覆盖（层叠）</strong>另一个冲突的样式。层叠性主要解决样式冲突的问题。</p><p> 层叠性原则： </p><ul><li>样式冲突，遵循的原则是<strong>就近原则</strong>，哪个样式离结构近，就执行哪个样式</li><li>样式不冲突，不会层叠</li></ul><img src="image-20210720002056617.png" alt="image-20210720002056617" style="zoom: 67%;"><h3 id="1-2-继承性"><a href="#1-2-继承性" class="headerlink" title="1.2 继承性"></a>1.2 继承性</h3><p>CSS中的继承: 子标签会继承父标签的某些样式，如文本颜色和字号。</p><img src="image-20210720002108649.png" alt="image-20210720002108649" style="zoom: 80%;"><ul><li>恰当地使用继承可以简化代码，降低 CSS 样式的复杂性</li><li>子元素可以继承父元素的样式（text-，font-，line-这些元素开头的可以继承，以及color属性）</li></ul><p><strong>行高的继承性</strong></p><pre class="line-numbers language-none"><code class="language-none">body { font:12px/1.5 Microsoft YaHei；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>行高可以跟单位也可以不跟单位 </li><li>如果子元素没有设置行高，则会继承父元素的行高为 1.5 </li><li>此时子元素的行高是：当前子元素的文字大小 * 1.5  </li><li>body 行高 1.5 这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高</li></ul><h3 id="1-3-优先级"><a href="#1-3-优先级" class="headerlink" title="1.3 优先级"></a>1.3 优先级</h3><p>当同一个元素指定多个选择器，就会有优先级的产生。 </p><ul><li>选择器相同，则执行层叠性 </li><li>选择器不同，则根据<strong>选择器权重</strong>执行</li></ul><p>选择器权重如下表所示</p><p><img src="image-20210720002624121.png" alt="image-20210720002624121"></p><p><strong>优先级注意点：</strong></p><ol><li>权重是有4组数字组成，但是不会有进位。 </li><li>可以理解为类选择器永远大于元素选择器，id选择器永远大于类选择器，以此类推……</li><li>等级判断从左向右，如果某一位数值相同，则判断下一位数值。 </li><li><strong>继承的权重是0</strong>， 如果该元素没有<strong>直接选中</strong>，不管父元素权重多高，子元素得到的权重都是 0。</li></ol><p><strong>权重叠加：</strong>如果是复合选择器，则会有权重叠加，需要计算权重。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础总结 1/7</title>
      <link href="/2021/07/19/css-1-7/"/>
      <url>/2021/07/19/css-1-7/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-基础总结-1-7"><a href="#CSS-基础总结-1-7" class="headerlink" title="CSS 基础总结 1/7"></a>CSS 基础总结 1/7</h1><h2 id="1-CSS-简介"><a href="#1-CSS-简介" class="headerlink" title="1 CSS 简介"></a>1 CSS 简介</h2><h3 id="1-1-CSS-的作用"><a href="#1-1-CSS-的作用" class="headerlink" title="1.1 CSS 的作用"></a>1.1 CSS 的作用</h3><ol><li>HTML 主要做结构，显示元素内容。</li><li>CSS 用于美化 HTML，布局网页。</li><li>CSS 最大价值: 由 HTML 专注去做结构呈现，样式交给 CSS，即结构（HTML）与样式（CSS）相分离。</li></ol><h3 id="1-2-CSS-语法规范"><a href="#1-2-CSS-语法规范" class="headerlink" title="1.2 CSS 语法规范"></a>1.2 CSS 语法规范</h3><p>CSS 规则由两个主要的部分构成：选择器以及一条或多条声明。</p><p><img src="image-20210719184810221.png" alt="image-20210719184810221"></p><ul><li>选择器是用于指定 CSS 样式的 HTML 标签，花括号内是对该对象设置的具体样式。</li><li>属性和属性值以“键值对”的形式出现。</li><li>属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。</li><li>属性和属性值之间用英文“:”分开。</li><li>多个“键值对”之间用英文“;”进行区分。</li></ul><p>所有的样式，都包含在 <code>&lt;style&gt;</code>  标签内，表示是样式表。 <code>&lt;style&gt;</code>  一般写到 <code>&lt;/head&gt;</code> 上方。 </p><pre class="line-numbers language-none"><code class="language-none">&lt;head&gt;&lt;style&gt;h4 {color: blue;font-size: 100px;}&lt;/style&gt;&lt;/head&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-CSS-推荐代码风格"><a href="#1-3-CSS-推荐代码风格" class="headerlink" title="1.3 CSS 推荐代码风格"></a>1.3 CSS 推荐代码风格</h3><ol><li>展开格式</li></ol><pre class="line-numbers language-none"><code class="language-none">h3 { color: pink; font-size: 20px; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>全部小写</li></ol><p>样式选择器，属性名，属性值关键字全部使用小写字母。</p><ol start="3"><li><p>空格规范</p><ol><li>属性值前面，冒号后面，保留一个空格；</li><li>选择器（标签）和大括号中间保留空格。</li></ol></li></ol><h2 id="2-CSS-基础选择器"><a href="#2-CSS-基础选择器" class="headerlink" title="2 CSS 基础选择器"></a>2 CSS 基础选择器</h2><p><strong>参考文档：<a href="https://www.w3school.com.cn/cssref/css_selectors.asp">CSS 选择器参考手册 (w3school.com.cn)</a></strong></p><h3 id="2-1-选择器的作用"><a href="#2-1-选择器的作用" class="headerlink" title="2.1 选择器的作用"></a>2.1 选择器的作用</h3><p>选对指定的标签，设置正确的标签样式。</p><h3 id="2-2-选择器分类"><a href="#2-2-选择器分类" class="headerlink" title="2.2 选择器分类"></a>2.2 选择器分类</h3><p>分为<strong>基础选择器</strong>和<strong>复合选择器</strong>两个大类。</p><p>基础选择器：</p><ul><li><p>基础选择器是由单个选择器组成的</p></li><li><p>基础选择器又包括：标签选择器、类选择器、id 选择器和通配符选择器</p></li></ul><h3 id="2-3-标签选择器"><a href="#2-3-标签选择器" class="headerlink" title="2.3 标签选择器"></a>2.3 标签选择器</h3><p>   标签选择器（元素选择器）是指用 HTML 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式。</p><ul><li>语法：</li></ul><pre class="line-numbers language-none"><code class="language-none">标签名{   属性1: 属性值1;    属性2: 属性值2;    属性3: 属性值3;    ...} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>作用：标签选择器可以把某一类标签全部选择出来，比如所有的 <code>&lt;div&gt;</code> 标签和所有的 <code>&lt;span&gt;</code> 标签。</p></li><li><p>优点：能快速为页面中同类型的标签统一设置样式。</p></li><li><p>缺点：不能设计差异化样式，只能选择全部的当前标签。</p></li></ul><h3 id="2-4-类选择器"><a href="#2-4-类选择器" class="headerlink" title="2.4 类选择器"></a>2.4 类选择器</h3><p>   如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器。</p><p>   类选择器在 HTML 中以 class 属性表示，在 CSS 中，类选择器以一个点“.”号显示。</p><ul><li>语法：</li></ul><pre class="line-numbers language-none"><code class="language-none">.类名 { 属性1: 属性值1;  ...} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  例如，将所有拥有 red 类的 HTML 元素均为红色。 </p><pre class="line-numbers language-none"><code class="language-none">.red { color: red; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  构需要用<strong>class属性</strong>来调用 class 类的意思:</p><pre class="line-numbers language-none"><code class="language-none">&lt;div class=‘red’&gt; 变红色 &lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>注意<ol><li>类选择器使用“.”（英文点号）进行标识，后面紧跟类名（自定义，我们自己命名的）。 </li><li>可以理解为给这个标签起了一个名字，来表示。</li><li>长名称或词组可以使用中横线来为选择器命名。</li></ol></li></ul><p><strong>多类名</strong></p><p>我们可以给一个标签指定多个类名，从而达到更多的选择目的。 这些类名都可以选出这个标签。 简单理解就是一个标签有多个名字。</p><pre class="line-numbers language-none"><code class="language-none">&lt;div class="red font20"&gt;亚瑟&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p>多类名使用方式</p><ol><li>在标签 class 属性中写多个类名 </li><li>多个类名中间必须用空格分开</li><li>这个标签就可以分别具有这些类名的样式</li></ol></li><li><p>多类名开发中使用场景</p><ol><li>可以把一些标签元素相同的样式（共同的部分）放到一个类里面。</li><li>这些标签都可以调用这个公共的类和自己独有的类。</li><li>从而节省CSS代码，方便统一修改。</li></ol></li></ol><h3 id="2-5-id-选择器"><a href="#2-5-id-选择器" class="headerlink" title="2.5 id 选择器"></a>2.5 id 选择器</h3><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。 HTML 元素以 id 属性来设置 id 选择器，CSS 中 id 选择器以“#” 来定义。</p><ul><li>语法</li></ul><pre class="line-numbers language-none"><code class="language-none">#id名 { 属性1: 属性值1;  ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>例如，将 id 为 nav 元素中的内容设置为红色。</p><pre class="line-numbers language-none"><code class="language-none">#nav { color:red;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>id 属性只能在每个 HTML 文档中出现一次。</p><p><strong>id 选择器和类选择器的区别</strong></p><ol><li>类选择器（class）好比人的名字，一个人可以有多个名字，同时一个名字也可以被多个人使用。</li><li>id 选择器好比人的身份证号码，是唯一的，不得重复。 </li><li>id 选择器和类选择器最大的不同在于使用次数上。 </li><li>类选择器在修改样式中用的最多，id 选择器一般用于页面唯一性的元素上，经常和 JavaScript 搭配使用。</li></ol><h3 id="2-6-通配符选择器"><a href="#2-6-通配符选择器" class="headerlink" title="2.6 通配符选择器"></a>2.6 通配符选择器</h3><p>在 CSS 中，通配符选择器使用“*”定义，它表示选取页面中所有元素（标签）。</p><ul><li>语法</li></ul><pre class="line-numbers language-none"><code class="language-none">* { 属性1: 属性值1;  ...} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通配符选择器不需要调用， 自动就给所有的元素使用样式。在特殊情况下才使用。</p><pre class="line-numbers language-none"><code class="language-none">* { margin: 0; padding: 0;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7-基础选择器总结"><a href="#2-7-基础选择器总结" class="headerlink" title="2.7 基础选择器总结"></a>2.7 基础选择器总结</h3><p><img src="image-20210719192838584.png" alt="image-20210719192838584"></p><p> 如果是修改样式， 类选择器是使用最多的。</p><h2 id="3-CSS-字体属性"><a href="#3-CSS-字体属性" class="headerlink" title="3 CSS 字体属性"></a>3 CSS 字体属性</h2><p>CSS Fonts (字体)属性用于定义字体系列、大小、粗细、和文字样式（如斜体）。</p><h3 id="3-1-字体系列-font-family"><a href="#3-1-字体系列-font-family" class="headerlink" title="3.1 字体系列 font-family"></a>3.1 字体系列 font-family</h3><pre class="line-numbers language-none"><code class="language-none">p { font-family:"微软雅黑";} div {font-family: Arial,"Microsoft Yahei", "微软雅黑";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>各种字体之间必须使用英文状态下的逗号隔开</li><li>一般情况下，如果有空格隔开的多个单词组成的字体，加引号</li><li>尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示</li><li>最常见的几个字体：body {font-family: ‘Microsoft YaHei’,tahoma,arial,’Hiragino Sans GB’; }</li></ul><h3 id="3-2-字体大小-font-size"><a href="#3-2-字体大小-font-size" class="headerlink" title="3.2 字体大小 font-size"></a>3.2 字体大小 font-size</h3><pre class="line-numbers language-none"><code class="language-none">p {  font-size: 20px; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-3-字体粗细-font-weight"><a href="#3-3-字体粗细-font-weight" class="headerlink" title="3.3 字体粗细 font-weight"></a>3.3 字体粗细 font-weight</h3><pre class="line-numbers language-none"><code class="language-none">p {  font-weight: bold;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20210719193250229.png" alt="image-20210719193250229"></p><h3 id="3-4-文字样式-font-style"><a href="#3-4-文字样式-font-style" class="headerlink" title="3.4 文字样式  font-style"></a>3.4 文字样式  font-style</h3><pre class="line-numbers language-none"><code class="language-none">p {  font-style: normal;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20210719193345332.png" alt="image-20210719193345332"></p><h3 id="3-5-字体复合属性"><a href="#3-5-字体复合属性" class="headerlink" title="3.5 字体复合属性"></a>3.5 字体复合属性</h3><pre class="line-numbers language-none"><code class="language-none">body {  font: font-style font-weight font-size/line-height font-family;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>使用 font 属性时，必须按上面语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开</li><li>不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用</li></ul><h3 id="3-6-字体属性总结"><a href="#3-6-字体属性总结" class="headerlink" title="3.6 字体属性总结"></a>3.6 字体属性总结</h3><p><img src="image-20210719193627743.png" alt="image-20210719193627743"></p><h2 id="4-CSS-文本属性"><a href="#4-CSS-文本属性" class="headerlink" title="4 CSS 文本属性"></a>4 CSS 文本属性</h2><p>CSS Text（文本）属性可定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。</p><h3 id="4-1-文本颜色-color"><a href="#4-1-文本颜色-color" class="headerlink" title="4.1 文本颜色 color"></a>4.1 文本颜色 color</h3><pre class="line-numbers language-none"><code class="language-none">div {  color: red;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20210719193920785.png" alt="image-20210719193920785"></p><p>开发中最常用的是十六进制</p><h3 id="4-2-对齐文本-text-align"><a href="#4-2-对齐文本-text-align" class="headerlink" title="4.2 对齐文本 text-align"></a>4.2 对齐文本 text-align</h3><pre class="line-numbers language-none"><code class="language-none">div {  text-align: center;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20210719194011034.png" alt="image-20210719194011034"></p><h3 id="4-3-装饰文本-text-decoration"><a href="#4-3-装饰文本-text-decoration" class="headerlink" title="4.3 装饰文本 text-decoration"></a>4.3 装饰文本 text-decoration</h3><pre class="line-numbers language-none"><code class="language-none">div {  text-decoration：underline；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20210719194101748.png" alt="image-20210719194101748"></p><h3 id="4-4-文本缩进-text-indent"><a href="#4-4-文本缩进-text-indent" class="headerlink" title="4.4 文本缩进 text-indent"></a>4.4 文本缩进 text-indent</h3><p>text-indent 属性用来指定文本的第一行的缩进，通常是将段落的首行缩进。</p><pre class="line-numbers language-none"><code class="language-none">div {  /* text-indent: 10px; */ text-indent: 2em;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过设置该属性，所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值。</p><p>em 是一个相对单位，就是当前元素（font-size) 1 个文字的大小, 如果当前元素没有设置大小，则会按照父元 素的 1 个文字大小。</p><h3 id="4-5-行间距-line-height"><a href="#4-5-行间距-line-height" class="headerlink" title="4.5 行间距 line-height"></a>4.5 行间距 line-height</h3><p>line-height 属性用于设置行间的距离（行高）。可以控制文字行与行之间的距离。</p><pre class="line-numbers language-none"><code class="language-none">p {  line-height: 26px;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="image-20210719194423651.png" alt="image-20210719194423651" style="zoom: 67%;"><h3 id="4-6-文本属性总结"><a href="#4-6-文本属性总结" class="headerlink" title="4.6 文本属性总结"></a>4.6 文本属性总结</h3><p><img src="image-20210719194459302.png" alt="image-20210719194459302"></p><h2 id="5-CSS-的引入方式"><a href="#5-CSS-的引入方式" class="headerlink" title="5 CSS 的引入方式"></a>5 CSS 的引入方式</h2><h3 id="5-1-CSS-的三种样式表"><a href="#5-1-CSS-的三种样式表" class="headerlink" title="5.1 CSS 的三种样式表"></a>5.1 CSS 的三种样式表</h3><p>按照 CSS 样式书写的位置（或者引入的方式），CSS 样式表可以分为三大类： </p><ol><li>行内样式表（行内式） </li><li>内部样式表（嵌入式） </li><li>外部样式表（链接式）</li></ol><h3 id="5-2-内部样式表"><a href="#5-2-内部样式表" class="headerlink" title="5.2 内部样式表"></a>5.2 内部样式表</h3><p>内部样式表（内嵌样式表）是写到 HTML 页面内部. 是将所有的 CSS 代码抽取出来，单独放到一个 <code>&lt;style&gt;</code> 标签中。</p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt; div { color: red; font-size: 12px; }&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><code>&lt;style&gt;</code> 标签理论上可以放在 HTML 文档的任何地方，但一般会放在文档的 <code>&lt;head&gt;</code> 标签中</li><li>通过此种方式，可以方便控制当前整个页面中的元素样式设置</li><li>代码结构清晰，但是并没有实现结构与样式完全分离</li><li>使用内部样式表设定 CSS，通常也被称为嵌入式引入，这种方式是我们练习时常用的方式</li></ol><h3 id="5-3-行内样式表"><a href="#5-3-行内样式表" class="headerlink" title="5.3 行内样式表"></a>5.3 行内样式表</h3><p>行内样式表（内联样式表）是在元素标签内部的 style 属性中设定 CSS 样式。适合于修改简单样式。</p><pre class="line-numbers language-none"><code class="language-none">&lt;div style="color: red; font-size: 12px;"&gt;内容&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>style 其实就是标签的属性，在双引号中间，写法要符合 CSS 规范 </li><li>可以控制当前的标签设置样式 </li><li>由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简 单样式的时候，可以考虑使用 </li><li>使用行内样式表设定 CSS，通常也被称为行内式引入</li></ul><h3 id="5-4-外部样式表"><a href="#5-4-外部样式表" class="headerlink" title="5.4 外部样式表"></a>5.4 外部样式表</h3><p>实际开发都是外部样式表. 适合于样式比较多的情况. 核心是:样式单独写到CSS 文件中，之后把CSS文件引入 到 HTML 页面中使用。</p><p>引入外部样式表分为两步：</p><ol><li>新建一个后缀名为 .css 的样式文件，把所有 CSS 代码都放入此文件中。 </li><li>在 HTML 页面中，使用 标签引入这个文件。</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;link rel="stylesheet" href="css文件路径"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20210719195028696.png" alt="image-20210719195028696"></p><p>使用外部样式表设定 CSS，通常也被称为外链式或链接式引入，这种方式是开发中常用的方式</p><h3 id="5-5-CSS-引入方式总结"><a href="#5-5-CSS-引入方式总结" class="headerlink" title="5.5 CSS 引入方式总结"></a>5.5 CSS 引入方式总结</h3><p><img src="image-20210719195121023.png" alt="image-20210719195121023"></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 的基本用法</title>
      <link href="/2021/07/19/git-de-ji-ben-yong-fa/"/>
      <url>/2021/07/19/git-de-ji-ben-yong-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Git使用的基本技巧"><a href="#Git使用的基本技巧" class="headerlink" title="Git使用的基本技巧"></a>Git使用的基本技巧</h1><h2 id="1-什么是-Git"><a href="#1-什么是-Git" class="headerlink" title="1 什么是 Git"></a>1 什么是 Git</h2><p>Git 是用于Linux内核开发的版本控制工具。与 CVS、 Subversion 一类的集中式版本控制工具不同，它采用了分布式版本库的作法，不需要服务器端软件，就可以运作版本控制，使得源代码的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux 内核这样的大项目来说自然很重要。 Git 最为出色的是它的合并追踪（merge tracing）能力。</p><h2 id="2-Git-的安装"><a href="#2-Git-的安装" class="headerlink" title="2 Git 的安装"></a>2 Git 的安装</h2><h3 id="2-1-安装-Git"><a href="#2-1-安装-Git" class="headerlink" title="2.1 安装 Git"></a>2.1 安装 Git</h3><p>从官网上下载 Git 安装即可。在任一文件夹中右键出现<code>Git Bash Here</code>，点击该选项能打开命令窗口，即表示安装成功。</p><p>首先需要设置全局参数：名字和邮箱地址。</p><pre class="line-numbers language-none"><code class="language-none">$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入git config –global –list命令可以显示设置过的全局变量，如下：</p><pre class="line-numbers language-none"><code class="language-none">$ git config --global --listcore.editor="D:\Microsoft VS Code\Code.exe" --waituser.name=tzhiyuser.email=2570986081@qq.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-创建版本库"><a href="#2-2-创建版本库" class="headerlink" title="2.2 创建版本库"></a>2.2 创建版本库</h3><p><strong>版本库</strong>又名仓库，英文名 repository ，你可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录。</p><p>第二步，通过<code>git init</code>命令把这个目录变成 Git 可以管理的仓库。</p><pre class="line-numbers language-none"><code class="language-none">$ cd /e/githubup$ mkdir demo$ cd /e/githubup/demo$ pwd/e/githubup/demo$ git initInitialized empty Git repository in E:/GitHubUp/demo/.git/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，在文件夹内新增了一个以 .git 命名的隐藏文件。到这里，一个真正的仓库就创建好了!</p><h2 id="3-Git-的目录结构"><a href="#3-Git-的目录结构" class="headerlink" title="3 Git 的目录结构"></a>3 Git 的目录结构</h2><p>在使用 Git 之前，我们要了解 Git 的主要结构是什么。</p><p>git中加入了暂存区的概念，分为工作区，版本库中的暂存区，分支等概念。git版本库的模型如下图所示：</p><p><img src="GitConstruction.png"></p><p>上图描述了 git 对象的在不同的生命周期中不同的存储位置，通过不同的 git 命令改变 git 对象的存储生命周期。</p><ol><li><p>工作区(workspace)</p><p> 就是我们当前工作空间，也就是我们当前能在本地文件夹下面看到的文件结构。初始化工作空间或者工作空间 clean 的时候，文件内容和 index 暂存区是一致的，随着修改，工作区文件在没有 add 到暂存区时候，工作区将和暂存区是不一致的。</p></li><li><p>暂存区 (index)</p><p> 老版本概念也叫 Cache 区，就是文件暂时存放的地方，所有暂时存放在暂存区中的文件将随着一个 commit 一起提交到 local repository 此时 local repository 里面文件将完全被暂存区所取代。暂存区是 git 架构设计中非常重要和难理解的一部分。</p></li><li><p>本地仓库 (local repository)</p><p> git 是分布式版本控制系统，和其他版本控制系统不同的是他可以完全去中心化工作，你可以不用和中央服务器 (remote server) 进行通信，在本地即可进行全部离线操作，包括 log，history，commit，diff 等等。完成离线操作最核心是因为 git 有一个几乎和远程一样的本地仓库，所有本地离线操作都可以在本地完成，等需要的时候再和远程服务进行交互。</p></li><li><p>远程仓库 (remote repository)</p><p> 中心化仓库，所有人共享，本地仓库会需要和远程仓库进行交互，也就能将其他所有人内容更新到本地仓库把自己内容上传分享给其他人。结构大体和本地仓库一样。</p></li></ol><p>使用 Git 命令后文件的变化</p><p><img src="GitCommand.png"></p><p>Git管理的是修改，当使用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>所以在每次使用git commit之前，所有修改过的文件都必须重新进行git add，将工作区(workspace)中的修改提交到暂存区(index)中，否则即使进行了git commit本地仓库中也将不会出现修改。</p><h2 id="4-版本管理"><a href="#4-版本管理" class="headerlink" title="4 版本管理"></a>4 版本管理</h2><h3 id="4-1-添加文件到版本库"><a href="#4-1-添加文件到版本库" class="headerlink" title="4.1 添加文件到版本库"></a>4.1 添加文件到版本库</h3><h4 id="4-1-1-在刚创建的-Git-仓库下创建一个-readme-txt-文件"><a href="#4-1-1-在刚创建的-Git-仓库下创建一个-readme-txt-文件" class="headerlink" title="4.1.1 在刚创建的 Git 仓库下创建一个 readme.txt 文件:"></a>4.1.1 在刚创建的 Git 仓库下创建一个 <code>readme.txt</code> 文件:</h4><pre class="line-numbers language-none"><code class="language-none">this is readme.txthello git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-1-2-使用-git-add-命令将文件提交到暂存区。"><a href="#4-1-2-使用-git-add-命令将文件提交到暂存区。" class="headerlink" title="4.1.2 使用 git add 命令将文件提交到暂存区。"></a>4.1.2 使用 <code>git add</code> 命令将文件提交到暂存区。</h4><pre class="line-numbers language-none"><code class="language-none">$ git add readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用 <code>git add .</code>来一次性提交所有的改动。</p><h4 id="4-1-3-使用-git-commit-命令将文件提交到本地仓库。"><a href="#4-1-3-使用-git-commit-命令将文件提交到本地仓库。" class="headerlink" title="4.1.3 使用 git commit 命令将文件提交到本地仓库。"></a>4.1.3 使用 <code>git commit</code> 命令将文件提交到本地仓库。</h4><pre class="line-numbers language-none"><code class="language-none">$ git commit -m "new readme file"[master (root-commit) ea52515] new readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>-m</code> 后面输入的是本次提交的说明。</p><h3 id="4-2-状态管理"><a href="#4-2-状态管理" class="headerlink" title="4.2 状态管理"></a>4.2 状态管理</h3><h4 id="4-2-1-修改-readme-txt-文件为如下"><a href="#4-2-1-修改-readme-txt-文件为如下" class="headerlink" title="4.2.1 修改 readme.txt 文件为如下"></a>4.2.1 修改 readme.txt 文件为如下</h4><pre class="line-numbers language-none"><code class="language-none">this is a file named readme.txthello git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-2-2-使用-git-status-查看当前状态"><a href="#4-2-2-使用-git-status-查看当前状态" class="headerlink" title="4.2.2 使用 git status 查看当前状态"></a>4.2.2 使用 <code>git status</code> 查看当前状态</h4><pre class="line-numbers language-none"><code class="language-none">$ git statusOn branch masterChanges not staged for commit:  (use "git add &lt;file&gt;..." to update what will be committed)  (use "git restore &lt;file&gt;..." to discard changes in working directory)        modified:   readme.txtno changes added to commit (use "git add" and/or "git commit -a")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git status</code> 命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt 被修改过了，但还没有准备提交的修改。</p><h4 id="4-2-3-使用-git-diff-查看修改的内容"><a href="#4-2-3-使用-git-diff-查看修改的内容" class="headerlink" title="4.2.3 使用 git diff 查看修改的内容"></a>4.2.3 使用 <code>git diff</code> 查看修改的内容</h4><pre class="line-numbers language-none"><code class="language-none">$ git diffdiff --git a/readme.txt b/readme.txtindex 4ead6b0..2d611cb 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-this is readme.txt+this is a file named readme.txt hello git\ No newline at end of file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到文件的被修改的状况。</p><h4 id="4-2-4-使用-git-status-查看-add-之后的状态"><a href="#4-2-4-使用-git-status-查看-add-之后的状态" class="headerlink" title="4.2.4 使用 git status 查看 add 之后的状态"></a>4.2.4 使用 <code>git status</code> 查看 add 之后的状态</h4><p>首先提交修改到暂存区。</p><pre class="line-numbers language-none"><code class="language-none">$ git add .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 <code>git status</code> 查看当前状态。</p><pre class="line-numbers language-none"><code class="language-none">$ git statusOn branch masterChanges to be committed:  (use "git restore --staged &lt;file&gt;..." to unstage)        modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git 告诉我们将要被提交的修改包括 readme.txt。</p><p>提交到本地仓库。</p><pre class="line-numbers language-none"><code class="language-none">$ git commit -m "readme.txt version2"[master 6daed76] readme.txt version2 1 file changed, 1 insertion(+), 1 deletion(-)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再次使用 <code>git status</code> 查看当前状态。</p><pre class="line-numbers language-none"><code class="language-none">$ git statusOn branch masternothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Git 告诉我们当前没有需要提交的修改，工作目录是干净（working tree clean）的。</p><h3 id="4-3-版本回退"><a href="#4-3-版本回退" class="headerlink" title="4.3 版本回退"></a>4.3 版本回退</h3><p>在 Git 中，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在 Git 中被称为 commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个 commit 恢复，然后继续工作，而不是把几个月的工作成果全部丢失。下面对这个功能进行演示。</p><h4 id="4-3-1-再次修改-readme-txt，并提交到本地仓库"><a href="#4-3-1-再次修改-readme-txt，并提交到本地仓库" class="headerlink" title="4.3.1 再次修改 readme.txt，并提交到本地仓库"></a>4.3.1 再次修改 readme.txt，并提交到本地仓库</h4><p>修改后的 readme.txt：</p><pre class="line-numbers language-none"><code class="language-none">this is a file named readme.txthello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提交到本地仓库：</p><pre class="line-numbers language-none"><code class="language-none">$ git add .$ git commit -m "readme.txt version3"[master 4a6cf89] readme.txt version3 1 file changed, 1 insertion(+), 1 deletion(-)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-2-使用-git-log-命令查看版本库状态"><a href="#4-3-2-使用-git-log-命令查看版本库状态" class="headerlink" title="4.3.2 使用 git log 命令查看版本库状态"></a>4.3.2 使用 <code>git log</code> 命令查看版本库状态</h4><pre class="line-numbers language-none"><code class="language-none">$ git logcommit 4a6cf892a3b737a8e95934acac251bb60d118068 (HEAD -&gt; master)Author: tzhiy &lt;2570986081@qq.com&gt;Date:   Sun Jul 18 15:37:04 2021 +0800    readme.txt version3commit 6daed765e7b45a03c96fcb658f5e61b6a170b438Author: tzhiy &lt;2570986081@qq.com&gt;Date:   Sun Jul 18 15:19:22 2021 +0800    readme.txt version2commit ea5251506b165792227d36ad8f874e403760d5baAuthor: tzhiy &lt;2570986081@qq.com&gt;Date:   Sun Jul 18 15:04:44 2021 +0800    new readme file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git log</code> 命令显示从最近到最远的提交日志。commit id 就是版本号。HEAD 表示当前的版本，上一个版本用 HEAD^ 表示，上上一个用 HEAD^^ 表示，上 100 个版本用 HEAD~100 表示。</p><h4 id="4-3-3-使用-git-reset-命令回退到以前的版本"><a href="#4-3-3-使用-git-reset-命令回退到以前的版本" class="headerlink" title="4.3.3 使用 git reset 命令回退到以前的版本"></a>4.3.3 使用 <code>git reset</code> 命令回退到以前的版本</h4><pre class="line-numbers language-none"><code class="language-none">$ git reset --hard HEAD^HEAD is now at 6daed76 readme.txt version2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到readme.txt 的内容回退到version2：</p><pre class="line-numbers language-none"><code class="language-none">this is a file named readme.txthello git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再次使用 <code>git log</code> 查看版本库状态：</p><pre class="line-numbers language-none"><code class="language-none">$ git logcommit 6daed765e7b45a03c96fcb658f5e61b6a170b438 (HEAD -&gt; master)Author: tzhiy &lt;2570986081@qq.com&gt;Date:   Sun Jul 18 15:19:22 2021 +0800    readme.txt version2commit ea5251506b165792227d36ad8f874e403760d5baAuthor: tzhiy &lt;2570986081@qq.com&gt;Date:   Sun Jul 18 15:04:44 2021 +0800    new readme file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 version3 版本不见了，那怎么通过刚刚的方法回到 version3 版本呢？我们还可以用 commit id 跳转到其它的版本，可以通过之前的版本库状态查到 version3 的 commit id 是 4a6cf89…：</p><pre class="line-numbers language-none"><code class="language-none">$ git reset --hard 4a6cfHEAD is now at 4a6cf89 readme.txt version3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>又回到 version3 了！</p><p>Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的 HEAD 指针，当你回退版本的时候， Git 仅仅是把 HEAD 从指向 version3。</p><h4 id="4-3-4-使用-git-reflog-命令查看每一次改动"><a href="#4-3-4-使用-git-reflog-命令查看每一次改动" class="headerlink" title="4.3.4 使用 git reflog 命令查看每一次改动"></a>4.3.4 使用 <code>git reflog</code> 命令查看每一次改动</h4><p>你回退到了某个版本，关掉了电脑之后想恢复到新版本怎么办？找不到新版本的commit id怎么办？Git提供了一个命令 <code>git reflog</code> 用来记录你的每一次命令：</p><pre class="line-numbers language-none"><code class="language-none">$ git reflog4a6cf89 (HEAD -&gt; master) HEAD@{0}: reset: moving to 4a6cf6daed76 HEAD@{1}: reset: moving to HEAD^4a6cf89 (HEAD -&gt; master) HEAD@{2}: commit: readme.txt version36daed76 HEAD@{3}: commit: readme.txt version2ea52515 HEAD@{4}: commit (initial): new readme file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们就可以知道每次执行命令所对应的 commit id 了。</p><h3 id="4-4-撤销修改"><a href="#4-4-撤销修改" class="headerlink" title="4.4 撤销修改"></a>4.4 撤销修改</h3><h4 id="4-4-1-丢弃工作区的修改"><a href="#4-4-1-丢弃工作区的修改" class="headerlink" title="4.4.1 丢弃工作区的修改"></a>4.4.1 丢弃工作区的修改</h4><p>场景 1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 <code>git checkout -- file</code>。</p><p>命令 <code>git checkout -- readme.txt</code> 意思就是，把 readme.txt 文件在工作区的修改全部撤销，这里有两种情况：</p><ol><li><p>readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p></li><li><p>readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p></li></ol><p>总之，就是让这个文件回到最近一次 <code>git commit</code> 或 <code>git add</code> 时的状态。</p><p>例如，将 readme.txt 的内容作修改:</p><pre class="line-numbers language-none"><code class="language-none">this is a file named readme.txthello worldbalabala<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">$ git checkout -- readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>撤销后的 readme.txt:</p><pre class="line-numbers language-none"><code class="language-none">this is a file named readme.txthello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-4-2-丢弃暂存区的修改"><a href="#4-4-2-丢弃暂存区的修改" class="headerlink" title="4.4.2 丢弃暂存区的修改"></a>4.4.2 丢弃暂存区的修改</h4><p>场景 2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 <code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景 1 操作。</p><p>用命令 <code>git reset HEAD &lt;file&gt;</code> 可以把暂存区的修改撤销掉（unstage），重新放回工作区。</p><pre class="line-numbers language-none"><code class="language-none">$ git reset HEAD readme.txtUnstaged changes after reset:Mreadme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>git reset</code> 命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用 HEAD 时，表示最新的版本。</p><h4 id="4-4-3-丢弃本地仓库的修改"><a href="#4-4-3-丢弃本地仓库的修改" class="headerlink" title="4.4.3 丢弃本地仓库的修改"></a>4.4.3 丢弃本地仓库的修改</h4><p>场景 3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p><h2 id="5-远程仓库"><a href="#5-远程仓库" class="headerlink" title="5 远程仓库"></a>5 远程仓库</h2><h2 id="6-分支管理"><a href="#6-分支管理" class="headerlink" title="6 分支管理"></a>6 分支管理</h2><p>参考：</p><ol><li>Git - 维基百科</li><li>廖雪峰的官方网站</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 基础总结</title>
      <link href="/2021/07/17/chu-shi-html/"/>
      <url>/2021/07/17/chu-shi-html/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-基础总结"><a href="#HTML-基础总结" class="headerlink" title="HTML 基础总结"></a>HTML 基础总结</h1><h2 id="HTML-简介"><a href="#HTML-简介" class="headerlink" title="HTML 简介"></a>HTML 简介</h2><h3 id="1-网页"><a href="#1-网页" class="headerlink" title="1 网页"></a>1 网页</h3><h4 id="1-1-什么是网页"><a href="#1-1-什么是网页" class="headerlink" title="1.1 什么是网页"></a>1.1 什么是网页</h4><p><strong>网站</strong>是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。  </p><p><strong>网页</strong>是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，常见以 .htm 或 .html 后缀结尾的文件，因此将其俗称为 HTML 文件。  </p><h4 id="1-2-什么是-HTML"><a href="#1-2-什么是-HTML" class="headerlink" title="1.2 什么是 HTML"></a>1.2 什么是 HTML</h4><p><strong>HTML</strong> 指的是<strong>超文本标记语言 (Hyper Text Markup Language)</strong> ，它是用来描述网页的一种语言，由标签组成。  </p><p>超文本：超越文本限制，超级链接文本。  </p><h4 id="1-3-网页的形成"><a href="#1-3-网页的形成" class="headerlink" title="1.3 网页的形成"></a>1.3 网页的形成</h4><p>网页是由网页元素组成的，这些元素是利用 HTML 标签描述出来，然后通过浏览器解析来显示给用户的。  </p><p>前端人员开发代码 —-&gt; 浏览器显示代码（解析、渲染） —-&gt; 生成最后的 Web 页面  </p><h3 id="2-常用浏览器"><a href="#2-常用浏览器" class="headerlink" title="2 常用浏览器"></a>2 常用浏览器</h3><h3 id="3-Web-标准"><a href="#3-Web-标准" class="headerlink" title="3 Web 标准"></a>3 Web 标准</h3><p><strong>Web 标准</strong>是由 W3C 组织和其他标准化组织制定的<strong>一系列标准的集合</strong>。W3C（万维网联盟）是国际最著名的标准化组织。  </p><h4 id="3-1-为什么要学习-Web-标准"><a href="#3-1-为什么要学习-Web-标准" class="headerlink" title="3.1 为什么要学习 Web 标准"></a>3.1 为什么要学习 Web 标准</h4><p>遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有很多优点。  </p><h4 id="3-2-Web-标准的构成"><a href="#3-2-Web-标准的构成" class="headerlink" title="3.2 Web 标准的构成"></a>3.2 Web 标准的构成</h4><p>主要包括<strong>结构（Structure）</strong> 、<strong>表现（Presentation）</strong>和<strong>行为（Behavior）</strong>三个方面。  </p><table><thead><tr><th>标准</th><th>说明</th></tr></thead><tbody><tr><td>结构</td><td>用于对<strong>网页元素</strong>进行整理和分类，如HTML</td></tr><tr><td>表现</td><td>用于设置网页版式、颜色、大小等<strong>外观样式</strong>，如CSS</td></tr><tr><td>行为</td><td>指网页模型的定义以及<strong>交互</strong>的编写，如JavaScript</td></tr></tbody></table><p>Web 标准提出的最佳体验方案：结构、样式、行为相分离。  </p><h2 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h2><h3 id="1-HTML语法规范"><a href="#1-HTML语法规范" class="headerlink" title="1 HTML语法规范"></a>1 HTML语法规范</h3><h4 id="1-1-基本语法概述"><a href="#1-1-基本语法概述" class="headerlink" title="1.1 基本语法概述"></a>1.1 基本语法概述</h4><p>由尖括号包围，分为单标签和双标签。  </p><h4 id="1-2-标签关系"><a href="#1-2-标签关系" class="headerlink" title="1.2 标签关系"></a>1.2 标签关系</h4><p><strong>包含关系</strong>和<strong>并列关系</strong>。  </p><h3 id="2-HTML-基本结构标签"><a href="#2-HTML-基本结构标签" class="headerlink" title="2 HTML 基本结构标签"></a>2 HTML 基本结构标签</h3><p>每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写。   </p><p><code>&lt;html&gt;、&lt;head&gt;、&lt;title&gt;、&lt;body&gt;</code>  </p><h3 id="3-网页开发工具"><a href="#3-网页开发工具" class="headerlink" title="3 网页开发工具"></a>3 网页开发工具</h3><h3 id="4-HTML-常用标签"><a href="#4-HTML-常用标签" class="headerlink" title="4 HTML 常用标签"></a>4 HTML 常用标签</h3><table><thead><tr><th>语义</th><th>格式</th><th>属性</th></tr></thead><tbody><tr><td>标题标签</td><td><code>&lt;h1&gt;~&lt;h6&gt;</code></td><td></td></tr><tr><td>段落和换行</td><td><code>&lt;p&gt;</code> <code>&lt;br&gt;</code></td><td></td></tr><tr><td>加粗和倾斜</td><td><code>&lt;strong&gt;</code> <code>&lt;em&gt;</code></td><td></td></tr><tr><td>盒子</td><td><code>&lt;div&gt;</code> <code> &lt;span&gt;</code></td><td></td></tr><tr><td>图像</td><td><code>&lt;img  src="图像URL"&gt;</code></td><td>src / alt / title / width / height</td></tr><tr><td>超链接</td><td><code>&lt;a&gt;</code></td><td>herf / target(打开方式)</td></tr></tbody></table><p>超链接分类：内部链接、外部链接、空链接、下载链接、锚点链接、网页元素链接  </p><h3 id="5-HTML-中的注释和特殊字符"><a href="#5-HTML-中的注释和特殊字符" class="headerlink" title="5 HTML 中的注释和特殊字符"></a>5 HTML 中的注释和特殊字符</h3><h4 id="5-1-注释"><a href="#5-1-注释" class="headerlink" title="5.1 注释"></a>5.1 注释</h4><p><code>&lt;!--  --&gt;</code> 快捷键：<code>ctrl</code>+<code>/</code>  </p><h4 id="5-2-特殊字符"><a href="#5-2-特殊字符" class="headerlink" title="5.2 特殊字符"></a>5.2 特殊字符</h4><table><thead><tr><th align="center">特殊字符</th><th align="center">代码</th></tr></thead><tbody><tr><td align="center">（空格）</td><td align="center">&amp;nbsp</td></tr><tr><td align="center"><code>&lt;</code></td><td align="center">&amp;lt</td></tr><tr><td align="center"><code>&gt;</code></td><td align="center">&amp;gt</td></tr></tbody></table><h3 id="6-表格标签-lt-table-gt"><a href="#6-表格标签-lt-table-gt" class="headerlink" title="6 表格标签 <table>"></a>6 表格标签 <code>&lt;table&gt;</code></h3><h4 id="6-1-基本语法"><a href="#6-1-基本语法" class="headerlink" title="6.1 基本语法"></a>6.1 基本语法</h4><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td><code>&lt;table&gt;</code></td><td>用于定义表格的标签</td></tr><tr><td><code>&lt;tr&gt;</code></td><td>表格中的行，必须嵌套在 <code>&lt;table&gt; &lt;/table&gt;</code>标签中</td></tr><tr><td><code>&lt;td&gt;</code></td><td>表格中的单元格，必须嵌套在<code>&lt;tr&gt;&lt;/tr&gt;</code>标签中</td></tr><tr><td><code>&lt;th&gt;</code></td><td>表格中的表头，必须嵌套在<code>&lt;tr&gt;&lt;/tr&gt;</code>标签中</td></tr></tbody></table><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td><code>&lt;thead&gt;</code></td><td>表格的头部区域</td></tr><tr><td><code>&lt;tbody&gt;</code></td><td>表格的主体</td></tr></tbody></table><p>用于分清表格结构</p><h4 id="6-2-合并单元格"><a href="#6-2-合并单元格" class="headerlink" title="6.2 合并单元格"></a>6.2 合并单元格</h4><table><thead><tr><th align="center">合并方式</th><th align="center">属性描述</th></tr></thead><tbody><tr><td align="center">跨行合并</td><td align="center">rowspan=”合并单元格的个数”</td></tr><tr><td align="center">跨列合并</td><td align="center">colspan=”合并单元格的个数”</td></tr></tbody></table><p><strong>步骤：</strong></p><ol><li>先确定是跨行还是跨列合并。</li><li>找到目标单元格. 写上合并方式 = 合并的单元格数量。比如：<code>&lt;td colspan="2"&gt;&lt;/td&gt;</code>。</li><li>删除多余的单元格。   </li></ol><h3 id="7-列表标签"><a href="#7-列表标签" class="headerlink" title="7 列表标签"></a>7 列表标签</h3><table><thead><tr><th align="center">标签</th><th align="center">名称</th></tr></thead><tbody><tr><td align="center"><code>&lt;ul&gt;</code></td><td align="center">无序列表</td></tr><tr><td align="center"><code>&lt;li&gt;</code></td><td align="center">列表项</td></tr><tr><td align="center"><code>&lt;ol&gt;</code></td><td align="center">有序列表</td></tr><tr><td align="center"><code>&lt;dl&gt;</code></td><td align="center">自定义列表</td></tr><tr><td align="center"><code>&lt;dt&gt;</code></td><td align="center">定义项目</td></tr><tr><td align="center"><code>&lt;dd&gt;</code></td><td align="center">描述项目</td></tr></tbody></table><h4 id="7-1-无序列表"><a href="#7-1-无序列表" class="headerlink" title="7.1 无序列表"></a>7.1 无序列表</h4><pre class="line-numbers language-none"><code class="language-none">&lt;ul&gt;    &lt;li&gt;列表项1&lt;/li&gt;    &lt;li&gt;列表项2&lt;/li&gt;    ...&lt;/ul&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-2-有序列表"><a href="#7-2-有序列表" class="headerlink" title="7.2 有序列表"></a>7.2 有序列表</h4><pre class="line-numbers language-none"><code class="language-none">&lt;ol&gt;    &lt;li&gt;列表项1&lt;/li&gt;    &lt;li&gt;列表项2&lt;/li&gt;    ...&lt;/ol&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-3-自定义列表"><a href="#7-3-自定义列表" class="headerlink" title="7.3 自定义列表"></a>7.3 自定义列表</h4><pre class="line-numbers language-none"><code class="language-none">&lt;dl&gt;    &lt;dt&gt;名词1&lt;/dt&gt;    &lt;dd&gt;名词1解释1&lt;/dd&gt;    &lt;dd&gt;名词1解释2&lt;/dd&gt;    &lt;dt&gt;名词2&lt;/dt&gt;    ...&lt;/dl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-表单标签"><a href="#8-表单标签" class="headerlink" title="8 表单标签"></a>8 表单标签</h3><h4 id="8-1-表单的作用"><a href="#8-1-表单的作用" class="headerlink" title="8.1 表单的作用"></a>8.1 表单的作用</h4><p>收集用户信息。  </p><h4 id="8-2-表单的组成"><a href="#8-2-表单的组成" class="headerlink" title="8.2 表单的组成"></a>8.2 表单的组成</h4><p>表单域、表单控件（也称为表单元素）和提示信息。   </p><h4 id="8-3-表单域"><a href="#8-3-表单域" class="headerlink" title="8.3 表单域"></a>8.3 表单域</h4><p>表单域是一个包含表单元素的区域。    </p><p>在 HTML 标签中，<code>&lt;form&gt;</code> 标签用于定义表单域，以实现用户信息的收集和传递。  </p><p><code>&lt;form&gt;</code> 会把它范围内的表单元素信息提交给服务器。</p><table><thead><tr><th>属性</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td>URL地址</td><td>指定接受并处理表单数据的URL地址</td></tr><tr><td>method</td><td>get / post</td><td>设置表单提交方式</td></tr><tr><td>name</td><td>名称</td><td>指定表单名称</td></tr></tbody></table><h4 id="8-4-表单控件"><a href="#8-4-表单控件" class="headerlink" title="8.4 表单控件"></a>8.4 表单控件</h4><h5 id="8-4-1-lt-input-gt-表单元素"><a href="#8-4-1-lt-input-gt-表单元素" class="headerlink" title="8.4.1 <input>表单元素"></a>8.4.1 <code>&lt;input&gt;</code>表单元素</h5><p>在英文单词中，input 是输入的意思，而在表单元素中 <code>&lt;input&gt;</code> 标签用于收集用户信息。  </p><p>type属性用于指定不同的控件类型。</p><table><thead><tr><th>属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td>button</td><td align="center">普通按钮</td></tr><tr><td>checkbox</td><td align="center">多选按钮</td></tr><tr><td>file</td><td align="center">文件上传</td></tr><tr><td>password</td><td align="center">密码字段</td></tr><tr><td>radio</td><td align="center">单选按钮</td></tr><tr><td>submit</td><td align="center">提交按钮</td></tr><tr><td>text</td><td align="center">单行输入字段</td></tr></tbody></table><p>随用随查。  </p><p>除了type属性之外，<code>&lt;input&gt;</code>还有其他属性，常用的如下：  </p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>规定input元素名称</td></tr><tr><td>value</td><td>规定input元素值</td></tr><tr><td>checked</td><td>规定首次加载时应当被选中</td></tr><tr><td>maxlength</td><td>规定输入字符串最大长度</td></tr></tbody></table><h5 id="8-4-2-lt-label-gt-标签"><a href="#8-4-2-lt-label-gt-标签" class="headerlink" title="8.4.2 <label>标签"></a>8.4.2 <code>&lt;label&gt;</code>标签</h5><p><code>&lt;label&gt;</code> 标签为 input 元素定义标注（标签）。  </p><p><code>&lt;label&gt;</code> 标签用于绑定一个表单元素, 当点击<code>&lt;label&gt;</code> 标签内的文本时，浏览器就会自动将焦点(光标)转到或者</p><p>选择对应的表单元素上，用来增加用户体验。  </p><h5 id="8-4-3-lt-select-gt-表单元素"><a href="#8-4-3-lt-select-gt-表单元素" class="headerlink" title="8.4.3 <select>表单元素"></a>8.4.3 <code>&lt;select&gt;</code>表单元素</h5><p>定义下拉列表。</p><pre class="line-numbers language-none"><code class="language-none">&lt;select&gt;    &lt;option&gt;选项1&lt;/option&gt;    &lt;option&gt;选项2&lt;/option&gt;    &lt;option&gt;选项3&lt;/option&gt;&lt;/select&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p><code>&lt;select&gt;</code> 中至少包含一对<code>&lt;option&gt;</code> 。  </p></li><li><p>在<code>&lt;option&gt;</code> 中定义 selected = “selected” 时，当前项即为默认选中项。  </p></li></ol><h5 id="8-4-4-lt-textarea-gt-标签"><a href="#8-4-4-lt-textarea-gt-标签" class="headerlink" title="8.4.4 <textarea>标签"></a>8.4.4 <code>&lt;textarea&gt;</code>标签</h5><p>在表单元素中，<code>&lt;textarea&gt;</code> 标签是用于定义多行文本输入的控件。</p><pre class="line-numbers language-none"><code class="language-none">&lt;textarea rows="3" cols="20"&gt;    文本内容&lt;/textarea&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 使用方法</title>
      <link href="/2021/06/18/markdown/"/>
      <url>/2021/06/18/markdown/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-使用方法"><a href="#Markdown-使用方法" class="headerlink" title="Markdown 使用方法"></a>Markdown 使用方法</h1><h2 id="1-什么是-Markdown"><a href="#1-什么是-Markdown" class="headerlink" title="1 什么是 Markdown"></a>1 什么是 Markdown</h2><p>Markdown语言的目的是希望大家使用易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的XHTML（或是HTML）。  </p><p>简单地说，Markdown与HTML语言一样，使用一些符号代替样式。但是它比HTML语言更加简单。  </p><h3 id="Markdown文件的工作原理"><a href="#Markdown文件的工作原理" class="headerlink" title="Markdown文件的工作原理"></a>Markdown文件的工作原理</h3><p>Markdown文件在显示时先被处理器转化为HTML文件，再通过web浏览器显示出来。</p><p><img src="principle.png"></p><p>被转化的过程中文件样式如下：  </p><p><img src="transfer.png"></p><p>Markdown 的本质是让我们回归到内容本身，注重文章本身的结构，而不是样式。 </p><h2 id="2-怎么使用-Markdown"><a href="#2-怎么使用-Markdown" class="headerlink" title="2 怎么使用 Markdown"></a>2 怎么使用 Markdown</h2><h3 id="2-1-标题"><a href="#2-1-标题" class="headerlink" title="2.1 标题"></a>2.1 标题</h3><p>Markdown的标题写法有两种</p><h4 id="2-1-1-ATX-标题"><a href="#2-1-1-ATX-标题" class="headerlink" title="2.1.1 ATX 标题"></a>2.1.1 ATX 标题</h4><p>在标题文本的前面加 “#” 来表示，”#” 的个数代表标题的级数， “#” 后面加上一个空格，最多有六级标题。</p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none"># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题##### 这是六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2-Setext-标题"><a href="#2-1-2-Setext-标题" class="headerlink" title="2.1.2 Setext 标题"></a>2.1.2 Setext 标题</h4><p>在文字下方加上两个以上的 “=” （一阶标题）或者 “-“ （二阶标题）。</p><h3 id="2-2-字体"><a href="#2-2-字体" class="headerlink" title="2.2 字体"></a>2.2 字体</h3><p>修改字体通过将要修改的文字部分用 “*” 或者 “~” 包围，基本功能如下：</p><table><thead><tr><th align="center">功能</th><th align="center">示例</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">加粗</td><td align="center"><code>**加粗**</code></td><td align="center"><strong>加粗</strong></td></tr><tr><td align="center">斜体</td><td align="center"><code>*斜体*</code></td><td align="center"><em>斜体</em></td></tr><tr><td align="center">斜体加粗</td><td align="center"><code>***斜体加粗***</code></td><td align="center"><em><strong>斜体加粗</strong></em></td></tr><tr><td align="center">删除线</td><td align="center"><code>~~删除线~~</code></td><td align="center"><del>删除线</del></td></tr></tbody></table><h3 id="2-3-引用"><a href="#2-3-引用" class="headerlink" title="2.3 引用"></a>2.3 引用</h3><p>在要引用的文字前加上”&gt;”即可表示引用，也可多层嵌套。</p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none">&gt;引用&gt;&gt;引用之引用&gt;&gt;&gt;&gt;引用之引用之引用之引用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>效果</li></ul><blockquote><p>引用</p><blockquote><p>引用之引用</p><blockquote><blockquote><p>引用之引用之引用之引用</p></blockquote></blockquote></blockquote></blockquote><h3 id="2-4-分割线"><a href="#2-4-分割线" class="headerlink" title="2.4 分割线"></a>2.4 分割线</h3><p>用三个或三个以上的”-“或”*”表示即可，在使用<code>---</code>分割时注意与上文空行，否则会解析为Setext二级标题。</p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none">***----<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>效果</li></ul><hr><hr><h3 id="2-5-表格"><a href="#2-5-表格" class="headerlink" title="2.5 表格"></a>2.5 表格</h3><ul><li>语法</li></ul><pre class="line-numbers language-none"><code class="language-none">| 表头 | 表头  | 表头 || ---- | :---: | ---: || 内容 | 内容  | 内容 || 内容 | 内容  | 内容 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在第二行分割表头和内容，”-“ 符号至少有一个。<br>当前列的表格内的文字默认居左，在两边加 “:” 表示居中，在右边加 “:” 表示居右。  </p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none">| 省内排名 |         大学         | 全国排名 || :------: | :------------------: | :------: ||    1     |     华中科技大学     |    8     ||    2     |       武汉大学       |    9     ||    3     |     华中农业大学     |    42    ||    4     |     华中师范大学     |    46    ||    5     | 中国地质大学（武汉） |    48    ||    6     |     武汉理工大学     |    55    |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果</li></ul><table><thead><tr><th align="center">省内排名</th><th align="center">大学</th><th align="center">全国排名</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">华中科技大学</td><td align="center">8</td></tr><tr><td align="center">2</td><td align="center">武汉大学</td><td align="center">9</td></tr><tr><td align="center">3</td><td align="center">华中农业大学</td><td align="center">42</td></tr><tr><td align="center">4</td><td align="center">华中师范大学</td><td align="center">46</td></tr><tr><td align="center">5</td><td align="center">中国地质大学（武汉）</td><td align="center">48</td></tr><tr><td align="center">6</td><td align="center">武汉理工大学</td><td align="center">55</td></tr></tbody></table><h3 id="2-6-图片"><a href="#2-6-图片" class="headerlink" title="2.6 图片"></a>2.6 图片</h3><p>插入图片</p><ul><li>格式</li></ul><pre class="line-numbers language-none"><code class="language-none">![alt](图片地址 "title")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当图片加载不出来的时候会显示alt的内容；<br>当鼠标悬停在图片上时，显示title处的内容。<br>alt和title的内容可以不写。</p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none">![](markdown.png)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>效果</li></ul><p><img src="markdown.png"></p><h3 id="2-7-超链接"><a href="#2-7-超链接" class="headerlink" title="2.7 超链接"></a>2.7 超链接</h3><p>在文本中插入超链接后，点击超链接即可跳转到对应的网站。</p><ul><li>语法</li></ul><pre class="line-numbers language-none"><code class="language-none">[超链接名](超链接地址 "title")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>title的含义与图片处解释相同，可以不写。</p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none">[百度](http://baidu.com)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>效果</li></ul><p><a href="http://baidu.com/">百度</a>  </p><h3 id="2-8-列表"><a href="#2-8-列表" class="headerlink" title="2.8 列表"></a>2.8 列表</h3><p>列表分为有序列表和无序列表。</p><h4 id="2-8-1-无序列表"><a href="#2-8-1-无序列表" class="headerlink" title="2.8.1 无序列表"></a>2.8.1 无序列表</h4><ul><li>语法<br>无序列表用 “-“ 、 “+” 、 “*” 任何一种都可以。</li></ul><pre class="line-numbers language-none"><code class="language-none">- 列表内容+ 列表内容* 列表内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意： “-“ 、 “+” 、 “*” 跟内容之间都要有一个空格。</p><ul><li>效果</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><h4 id="2-8-2-有序列表"><a href="#2-8-2-有序列表" class="headerlink" title="2.8.2 有序列表"></a>2.8.2 有序列表</h4><ul><li>语法</li></ul><p>数字加”.”</p><pre class="line-numbers language-none"><code class="language-none">1. 列表内容2. 列表内容3. 列表内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：序号跟内容之间要有空格</p><ul><li>效果</li></ul><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><h4 id="2-8-3-列表的嵌套"><a href="#2-8-3-列表的嵌套" class="headerlink" title="2.8.3 列表的嵌套"></a>2.8.3 列表的嵌套</h4><p>在上一级和下一级之间加三个空格即可。</p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none">1. 列表内容   + 列表内容   + 列表内容2. 列表内容   + 列表内容+ 列表内容   + 列表内容      + 列表内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果</li></ul><ol><li>列表内容<ul><li>列表内容</li><li>列表内容</li></ul></li><li>列表内容<ul><li>列表内容</li></ul></li></ol><ul><li>列表内容<ul><li>列表内容<ul><li>列表内容</li></ul></li></ul></li></ul><h3 id="2-9-代码"><a href="#2-9-代码" class="headerlink" title="2.9 代码"></a>2.9 代码</h3><p>单行代码用两个反引号”`”括起来即可<br>代码块用”```”括起来，且两边的反引号要单独占一行</p><ul><li>示例</li></ul><pre class="line-numbers language-none"><code class="language-none">`代码内容`(```  代码...  代码...  代码...```)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（这里加括号是为了防止转译，实际上没有）</p><ul><li>效果</li></ul><p><code>代码内容</code></p><pre class="line-numbers language-none"><code class="language-none">代码...代码...代码...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>基本语法如上，它的功能还不止这些，Markdown还可以用来画流程图等等。</p><h2 id="3-Markdown-语法规范"><a href="#3-Markdown-语法规范" class="headerlink" title="3 Markdown 语法规范"></a>3 Markdown 语法规范</h2><p>Markdown 设计之初没有明确的语法规范，随着 Markdown 被更多的人使用，这种不规范直接导致了多种 Markdown 语法的变体，Markdown 解析器也变得混乱，无法统一。</p><p>2017 年 GitHub 发布了 Markdown GFM（GitHub Flavored Markdown） 标准规范，并且修改了 GitHub 的 Markdown 解析器以规范用户行为。</p><h3 id="3-1-语法规范建议"><a href="#3-1-语法规范建议" class="headerlink" title="3.1 语法规范建议"></a>3.1 语法规范建议</h3><p>推荐使用 GitHub GFM 规范。</p><h3 id="3-2-标题格式建议"><a href="#3-2-标题格式建议" class="headerlink" title="3.2 标题格式建议"></a>3.2 标题格式建议</h3><p>推荐使用 ATX 标题规范。<br>文章中尽量避免四级标题，三级标题下的并列内容建议使用列表。</p><h3 id="3-3-空行"><a href="#3-3-空行" class="headerlink" title="3.3 空行"></a>3.3 空行</h3><ul><li>不要有多余的空行<br>在 Markdown 文本中，想要做到渲染后真换行通常是使用两个空格加一个回车换行符，或者粗暴地空一行，但是不要连续空两行及以上。  </li><li>文件末尾空一行<br>强烈建议文件末尾空一行，大多数格式检查工具都会检查文件末尾的空行。文件末尾增加空行的可能原因是为了方便进行文件拼接处理。</li><li>标题前后各空一行  </li></ul><h3 id="3-4-空格"><a href="#3-4-空格" class="headerlink" title="3.4 空格"></a>3.4 空格</h3><ul><li>中英文之间需要增加空格</li><li>中文与数字之间需要增加空格</li><li>数字与单位之间需要增加空格</li><li>全角标点与其他字符之间不加空格</li></ul><h3 id="3-5-标点符号"><a href="#3-5-标点符号" class="headerlink" title="3.5 标点符号"></a>3.5 标点符号</h3><p>不重复使用标点符号</p><h3 id="3-6-全角和半角"><a href="#3-6-全角和半角" class="headerlink" title="3.6 全角和半角"></a>3.6 全角和半角</h3><ul><li>使用全角中文标点</li><li>数字使用半角字符</li><li>遇到完整的英文整句、特殊名词，其内容使用半角标点</li></ul><h3 id="3-7-名词"><a href="#3-7-名词" class="headerlink" title="3.7 名词"></a>3.7 名词</h3><ul><li>专有名词使用正确的大小写</li><li>不要使用不地道的缩写</li></ul><h3 id="3-8-有争议的点"><a href="#3-8-有争议的点" class="headerlink" title="3.8 有争议的点"></a>3.8 有争议的点</h3><p>无论是否遵循下述规则，从语法的角度来讲都是 <strong>正确</strong> 的。</p><ul><li><p>链接之间增加空格</p></li><li><p>加粗、斜体、高亮文本前后加空格</p></li><li><p>列表缩进</p><ul><li>建议使用 4 个空格进行文本缩进，尤其是遇到有序列表或者无序列表的时候。另外，在使用无序列表或者有序列表的时候，建议在上下级之间空一行，同级之间可以不空行。</li></ul></li><li><p>/ 的使用<br>建议 / 字符前后留空格，充当路径描述符的时候除外。</p></li><li><p>简体中文使用直角引号</p></li></ul><p>参考：  </p><ol><li><a href="http://gfm.docschina.org/zh-hans/">GitHub 风格的 Markdown 规范</a></li><li><a href="https://github.com/sparanoid/chinese-copywriting-guidelines">中文文案排版指北</a></li><li><a href="https://zh.wikipedia.org/wiki/Markdown">Markdown - 维基百科</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
